// Code generated by counterfeiter. DO NOT EDIT.
package commandsfakes

import (
	"sync"

	"github.com/jesseduffield/lazygit/pkg/commands"
	"github.com/jesseduffield/lazygit/pkg/commands/loaders"
	"github.com/jesseduffield/lazygit/pkg/commands/models"
	"github.com/jesseduffield/lazygit/pkg/commands/oscommands"
	"github.com/jesseduffield/lazygit/pkg/commands/patch"
	"github.com/jesseduffield/lazygit/pkg/commands/types"
	"github.com/jesseduffield/lazygit/pkg/gui/filetree"
	"github.com/sirupsen/logrus"
)

type FakeIGit struct {
	AbortMergeStub        func() error
	abortMergeMutex       sync.RWMutex
	abortMergeArgsForCall []struct {
	}
	abortMergeReturns struct {
		result1 error
	}
	abortMergeReturnsOnCall map[int]struct {
		result1 error
	}
	AbortRebaseStub        func() error
	abortRebaseMutex       sync.RWMutex
	abortRebaseArgsForCall []struct {
	}
	abortRebaseReturns struct {
		result1 error
	}
	abortRebaseReturnsOnCall map[int]struct {
		result1 error
	}
	AddRemoteStub        func(string, string) error
	addRemoteMutex       sync.RWMutex
	addRemoteArgsForCall []struct {
		arg1 string
		arg2 string
	}
	addRemoteReturns struct {
		result1 error
	}
	addRemoteReturnsOnCall map[int]struct {
		result1 error
	}
	AllBranchesCmdObjStub        func() types.ICmdObj
	allBranchesCmdObjMutex       sync.RWMutex
	allBranchesCmdObjArgsForCall []struct {
	}
	allBranchesCmdObjReturns struct {
		result1 types.ICmdObj
	}
	allBranchesCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	AmendToStub        func(string) error
	amendToMutex       sync.RWMutex
	amendToArgsForCall []struct {
		arg1 string
	}
	amendToReturns struct {
		result1 error
	}
	amendToReturnsOnCall map[int]struct {
		result1 error
	}
	ApplyPatchStub        func(string, ...string) error
	applyPatchMutex       sync.RWMutex
	applyPatchArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	applyPatchReturns struct {
		result1 error
	}
	applyPatchReturnsOnCall map[int]struct {
		result1 error
	}
	BeforeAndAfterFileForRenameStub        func(*models.File) (*models.File, *models.File, error)
	beforeAndAfterFileForRenameMutex       sync.RWMutex
	beforeAndAfterFileForRenameArgsForCall []struct {
		arg1 *models.File
	}
	beforeAndAfterFileForRenameReturns struct {
		result1 *models.File
		result2 *models.File
		result3 error
	}
	beforeAndAfterFileForRenameReturnsOnCall map[int]struct {
		result1 *models.File
		result2 *models.File
		result3 error
	}
	BeginInteractiveRebaseForCommitStub        func([]*models.Commit, int) error
	beginInteractiveRebaseForCommitMutex       sync.RWMutex
	beginInteractiveRebaseForCommitArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
	}
	beginInteractiveRebaseForCommitReturns struct {
		result1 error
	}
	beginInteractiveRebaseForCommitReturnsOnCall map[int]struct {
		result1 error
	}
	BranchesStub        func() commands.IBranchesMgr
	branchesMutex       sync.RWMutex
	branchesArgsForCall []struct {
	}
	branchesReturns struct {
		result1 commands.IBranchesMgr
	}
	branchesReturnsOnCall map[int]struct {
		result1 commands.IBranchesMgr
	}
	BuildGitCmdObjFromStrStub        func(string) types.ICmdObj
	buildGitCmdObjFromStrMutex       sync.RWMutex
	buildGitCmdObjFromStrArgsForCall []struct {
		arg1 string
	}
	buildGitCmdObjFromStrReturns struct {
		result1 types.ICmdObj
	}
	buildGitCmdObjFromStrReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	BuildShellCmdObjStub        func(string) types.ICmdObj
	buildShellCmdObjMutex       sync.RWMutex
	buildShellCmdObjArgsForCall []struct {
		arg1 string
	}
	buildShellCmdObjReturns struct {
		result1 types.ICmdObj
	}
	buildShellCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	CatFileStub        func(string) (string, error)
	catFileMutex       sync.RWMutex
	catFileArgsForCall []struct {
		arg1 string
	}
	catFileReturns struct {
		result1 string
		result2 error
	}
	catFileReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CheckRemoteBranchExistsStub        func(*models.Branch) bool
	checkRemoteBranchExistsMutex       sync.RWMutex
	checkRemoteBranchExistsArgsForCall []struct {
		arg1 *models.Branch
	}
	checkRemoteBranchExistsReturns struct {
		result1 bool
	}
	checkRemoteBranchExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	CheckoutStub        func(string, commands.CheckoutOptions) error
	checkoutMutex       sync.RWMutex
	checkoutArgsForCall []struct {
		arg1 string
		arg2 commands.CheckoutOptions
	}
	checkoutReturns struct {
		result1 error
	}
	checkoutReturnsOnCall map[int]struct {
		result1 error
	}
	CheckoutFileStub        func(string, string) error
	checkoutFileMutex       sync.RWMutex
	checkoutFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	checkoutFileReturns struct {
		result1 error
	}
	checkoutFileReturnsOnCall map[int]struct {
		result1 error
	}
	CherryPickCommitsStub        func([]*models.Commit) error
	cherryPickCommitsMutex       sync.RWMutex
	cherryPickCommitsArgsForCall []struct {
		arg1 []*models.Commit
	}
	cherryPickCommitsReturns struct {
		result1 error
	}
	cherryPickCommitsReturnsOnCall map[int]struct {
		result1 error
	}
	CommitsStub        func() commands.ICommitsMgr
	commitsMutex       sync.RWMutex
	commitsArgsForCall []struct {
	}
	commitsReturns struct {
		result1 commands.ICommitsMgr
	}
	commitsReturnsOnCall map[int]struct {
		result1 commands.ICommitsMgr
	}
	ContinueRebaseStub        func() error
	continueRebaseMutex       sync.RWMutex
	continueRebaseArgsForCall []struct {
	}
	continueRebaseReturns struct {
		result1 error
	}
	continueRebaseReturnsOnCall map[int]struct {
		result1 error
	}
	CreateLightweightTagStub        func(string, string) error
	createLightweightTagMutex       sync.RWMutex
	createLightweightTagArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createLightweightTagReturns struct {
		result1 error
	}
	createLightweightTagReturnsOnCall map[int]struct {
		result1 error
	}
	CurrentBranchNameStub        func() (string, string, error)
	currentBranchNameMutex       sync.RWMutex
	currentBranchNameArgsForCall []struct {
	}
	currentBranchNameReturns struct {
		result1 string
		result2 string
		result3 error
	}
	currentBranchNameReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	DeleteBranchStub        func(string, bool) error
	deleteBranchMutex       sync.RWMutex
	deleteBranchArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	deleteBranchReturns struct {
		result1 error
	}
	deleteBranchReturnsOnCall map[int]struct {
		result1 error
	}
	DeletePatchesFromCommitStub        func([]*models.Commit, int, *patch.PatchManager) error
	deletePatchesFromCommitMutex       sync.RWMutex
	deletePatchesFromCommitArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
	}
	deletePatchesFromCommitReturns struct {
		result1 error
	}
	deletePatchesFromCommitReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteRemoteBranchStub        func(string, string) error
	deleteRemoteBranchMutex       sync.RWMutex
	deleteRemoteBranchArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteRemoteBranchReturns struct {
		result1 error
	}
	deleteRemoteBranchReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTagStub        func(string) error
	deleteTagMutex       sync.RWMutex
	deleteTagArgsForCall []struct {
		arg1 string
	}
	deleteTagReturns struct {
		result1 error
	}
	deleteTagReturnsOnCall map[int]struct {
		result1 error
	}
	DiffEndArgsStub        func(string, string, bool, string) string
	diffEndArgsMutex       sync.RWMutex
	diffEndArgsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 string
	}
	diffEndArgsReturns struct {
		result1 string
	}
	diffEndArgsReturnsOnCall map[int]struct {
		result1 string
	}
	DiscardAllDirChangesStub        func(*filetree.FileNode) error
	discardAllDirChangesMutex       sync.RWMutex
	discardAllDirChangesArgsForCall []struct {
		arg1 *filetree.FileNode
	}
	discardAllDirChangesReturns struct {
		result1 error
	}
	discardAllDirChangesReturnsOnCall map[int]struct {
		result1 error
	}
	DiscardAllFileChangesStub        func(*models.File) error
	discardAllFileChangesMutex       sync.RWMutex
	discardAllFileChangesArgsForCall []struct {
		arg1 *models.File
	}
	discardAllFileChangesReturns struct {
		result1 error
	}
	discardAllFileChangesReturnsOnCall map[int]struct {
		result1 error
	}
	DiscardAnyUnstagedFileChangesStub        func() error
	discardAnyUnstagedFileChangesMutex       sync.RWMutex
	discardAnyUnstagedFileChangesArgsForCall []struct {
	}
	discardAnyUnstagedFileChangesReturns struct {
		result1 error
	}
	discardAnyUnstagedFileChangesReturnsOnCall map[int]struct {
		result1 error
	}
	DiscardOldFileChangesStub        func([]*models.Commit, int, string) error
	discardOldFileChangesMutex       sync.RWMutex
	discardOldFileChangesArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}
	discardOldFileChangesReturns struct {
		result1 error
	}
	discardOldFileChangesReturnsOnCall map[int]struct {
		result1 error
	}
	DiscardUnstagedDirChangesStub        func(*filetree.FileNode) error
	discardUnstagedDirChangesMutex       sync.RWMutex
	discardUnstagedDirChangesArgsForCall []struct {
		arg1 *filetree.FileNode
	}
	discardUnstagedDirChangesReturns struct {
		result1 error
	}
	discardUnstagedDirChangesReturnsOnCall map[int]struct {
		result1 error
	}
	DiscardUnstagedFileChangesStub        func(*models.File) error
	discardUnstagedFileChangesMutex       sync.RWMutex
	discardUnstagedFileChangesArgsForCall []struct {
		arg1 *models.File
	}
	discardUnstagedFileChangesReturns struct {
		result1 error
	}
	discardUnstagedFileChangesReturnsOnCall map[int]struct {
		result1 error
	}
	EditFileCmdObjStub        func(string) (types.ICmdObj, error)
	editFileCmdObjMutex       sync.RWMutex
	editFileCmdObjArgsForCall []struct {
		arg1 string
	}
	editFileCmdObjReturns struct {
		result1 types.ICmdObj
		result2 error
	}
	editFileCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
		result2 error
	}
	EditRebaseTodoStub        func(int, string) error
	editRebaseTodoMutex       sync.RWMutex
	editRebaseTodoArgsForCall []struct {
		arg1 int
		arg2 string
	}
	editRebaseTodoReturns struct {
		result1 error
	}
	editRebaseTodoReturnsOnCall map[int]struct {
		result1 error
	}
	FastForwardStub        func(string, string, string) error
	fastForwardMutex       sync.RWMutex
	fastForwardArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	fastForwardReturns struct {
		result1 error
	}
	fastForwardReturnsOnCall map[int]struct {
		result1 error
	}
	FetchStub        func(commands.FetchOptions) error
	fetchMutex       sync.RWMutex
	fetchArgsForCall []struct {
		arg1 commands.FetchOptions
	}
	fetchReturns struct {
		result1 error
	}
	fetchReturnsOnCall map[int]struct {
		result1 error
	}
	FetchInBackgroundStub        func(commands.FetchOptions) error
	fetchInBackgroundMutex       sync.RWMutex
	fetchInBackgroundArgsForCall []struct {
		arg1 commands.FetchOptions
	}
	fetchInBackgroundReturns struct {
		result1 error
	}
	fetchInBackgroundReturnsOnCall map[int]struct {
		result1 error
	}
	FetchRemoteStub        func(string) error
	fetchRemoteMutex       sync.RWMutex
	fetchRemoteArgsForCall []struct {
		arg1 string
	}
	fetchRemoteReturns struct {
		result1 error
	}
	fetchRemoteReturnsOnCall map[int]struct {
		result1 error
	}
	FindRemoteForBranchInConfigStub        func(string) (string, error)
	findRemoteForBranchInConfigMutex       sync.RWMutex
	findRemoteForBranchInConfigArgsForCall []struct {
		arg1 string
	}
	findRemoteForBranchInConfigReturns struct {
		result1 string
		result2 error
	}
	findRemoteForBranchInConfigReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FlowFinishStub        func(string, string) types.ICmdObj
	flowFinishMutex       sync.RWMutex
	flowFinishArgsForCall []struct {
		arg1 string
		arg2 string
	}
	flowFinishReturns struct {
		result1 types.ICmdObj
	}
	flowFinishReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	FlowStartStub        func(string, string) types.ICmdObj
	flowStartMutex       sync.RWMutex
	flowStartArgsForCall []struct {
		arg1 string
		arg2 string
	}
	flowStartReturns struct {
		result1 types.ICmdObj
	}
	flowStartReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	GenerateGenericRebaseTodoStub        func([]*models.Commit, int, string) (string, string, error)
	generateGenericRebaseTodoMutex       sync.RWMutex
	generateGenericRebaseTodoArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}
	generateGenericRebaseTodoReturns struct {
		result1 string
		result2 string
		result3 error
	}
	generateGenericRebaseTodoReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	GenericAbortCmdObjStub        func() types.ICmdObj
	genericAbortCmdObjMutex       sync.RWMutex
	genericAbortCmdObjArgsForCall []struct {
	}
	genericAbortCmdObjReturns struct {
		result1 types.ICmdObj
	}
	genericAbortCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	GenericContinueCmdObjStub        func() types.ICmdObj
	genericContinueCmdObjMutex       sync.RWMutex
	genericContinueCmdObjArgsForCall []struct {
	}
	genericContinueCmdObjReturns struct {
		result1 types.ICmdObj
	}
	genericContinueCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	GenericMergeOrRebaseActionStub        func(string, string) error
	genericMergeOrRebaseActionMutex       sync.RWMutex
	genericMergeOrRebaseActionArgsForCall []struct {
		arg1 string
		arg2 string
	}
	genericMergeOrRebaseActionReturns struct {
		result1 error
	}
	genericMergeOrRebaseActionReturnsOnCall map[int]struct {
		result1 error
	}
	GenericMergeOrRebaseCmdObjStub        func(string) types.ICmdObj
	genericMergeOrRebaseCmdObjMutex       sync.RWMutex
	genericMergeOrRebaseCmdObjArgsForCall []struct {
		arg1 string
	}
	genericMergeOrRebaseCmdObjReturns struct {
		result1 types.ICmdObj
	}
	genericMergeOrRebaseCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	GetBranchGraphStub        func(string) (string, error)
	getBranchGraphMutex       sync.RWMutex
	getBranchGraphArgsForCall []struct {
		arg1 string
	}
	getBranchGraphReturns struct {
		result1 string
		result2 error
	}
	getBranchGraphReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetBranchGraphCmdObjStub        func(string) types.ICmdObj
	getBranchGraphCmdObjMutex       sync.RWMutex
	getBranchGraphCmdObjArgsForCall []struct {
		arg1 string
	}
	getBranchGraphCmdObjReturns struct {
		result1 types.ICmdObj
	}
	getBranchGraphCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	GetBranchUpstreamDifferenceCountStub        func(string) (string, string)
	getBranchUpstreamDifferenceCountMutex       sync.RWMutex
	getBranchUpstreamDifferenceCountArgsForCall []struct {
		arg1 string
	}
	getBranchUpstreamDifferenceCountReturns struct {
		result1 string
		result2 string
	}
	getBranchUpstreamDifferenceCountReturnsOnCall map[int]struct {
		result1 string
		result2 string
	}
	GetCommitDifferencesStub        func(string, string) (string, string)
	getCommitDifferencesMutex       sync.RWMutex
	getCommitDifferencesArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getCommitDifferencesReturns struct {
		result1 string
		result2 string
	}
	getCommitDifferencesReturnsOnCall map[int]struct {
		result1 string
		result2 string
	}
	GetConfigValueStub        func(string) string
	getConfigValueMutex       sync.RWMutex
	getConfigValueArgsForCall []struct {
		arg1 string
	}
	getConfigValueReturns struct {
		result1 string
	}
	getConfigValueReturnsOnCall map[int]struct {
		result1 string
	}
	GetCurrentBranchUpstreamDifferenceCountStub        func() (string, string)
	getCurrentBranchUpstreamDifferenceCountMutex       sync.RWMutex
	getCurrentBranchUpstreamDifferenceCountArgsForCall []struct {
	}
	getCurrentBranchUpstreamDifferenceCountReturns struct {
		result1 string
		result2 string
	}
	getCurrentBranchUpstreamDifferenceCountReturnsOnCall map[int]struct {
		result1 string
		result2 string
	}
	GetFilesInDiffStub        func(string, string, bool) ([]*models.CommitFile, error)
	getFilesInDiffMutex       sync.RWMutex
	getFilesInDiffArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
	}
	getFilesInDiffReturns struct {
		result1 []*models.CommitFile
		result2 error
	}
	getFilesInDiffReturnsOnCall map[int]struct {
		result1 []*models.CommitFile
		result2 error
	}
	GetGitFlowRegexpConfigStub        func() (string, error)
	getGitFlowRegexpConfigMutex       sync.RWMutex
	getGitFlowRegexpConfigArgsForCall []struct {
	}
	getGitFlowRegexpConfigReturns struct {
		result1 string
		result2 error
	}
	getGitFlowRegexpConfigReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetLogStub        func() *logrus.Entry
	getLogMutex       sync.RWMutex
	getLogArgsForCall []struct {
	}
	getLogReturns struct {
		result1 *logrus.Entry
	}
	getLogReturnsOnCall map[int]struct {
		result1 *logrus.Entry
	}
	GetOSStub        func() *oscommands.OS
	getOSMutex       sync.RWMutex
	getOSArgsForCall []struct {
	}
	getOSReturns struct {
		result1 *oscommands.OS
	}
	getOSReturnsOnCall map[int]struct {
		result1 *oscommands.OS
	}
	GetPagerStub        func(int) string
	getPagerMutex       sync.RWMutex
	getPagerArgsForCall []struct {
		arg1 int
	}
	getPagerReturns struct {
		result1 string
	}
	getPagerReturnsOnCall map[int]struct {
		result1 string
	}
	GetPushToCurrentStub        func() bool
	getPushToCurrentMutex       sync.RWMutex
	getPushToCurrentArgsForCall []struct {
	}
	getPushToCurrentReturns struct {
		result1 bool
	}
	getPushToCurrentReturnsOnCall map[int]struct {
		result1 bool
	}
	GetReflogCommitsStub        func(*models.Commit, string) ([]*models.Commit, bool, error)
	getReflogCommitsMutex       sync.RWMutex
	getReflogCommitsArgsForCall []struct {
		arg1 *models.Commit
		arg2 string
	}
	getReflogCommitsReturns struct {
		result1 []*models.Commit
		result2 bool
		result3 error
	}
	getReflogCommitsReturnsOnCall map[int]struct {
		result1 []*models.Commit
		result2 bool
		result3 error
	}
	GetRemoteURLStub        func() string
	getRemoteURLMutex       sync.RWMutex
	getRemoteURLArgsForCall []struct {
	}
	getRemoteURLReturns struct {
		result1 string
	}
	getRemoteURLReturnsOnCall map[int]struct {
		result1 string
	}
	GetRemotesStub        func() ([]*models.Remote, error)
	getRemotesMutex       sync.RWMutex
	getRemotesArgsForCall []struct {
	}
	getRemotesReturns struct {
		result1 []*models.Remote
		result2 error
	}
	getRemotesReturnsOnCall map[int]struct {
		result1 []*models.Remote
		result2 error
	}
	GetRewordCommitCmdObjStub        func([]*models.Commit, int) (types.ICmdObj, error)
	getRewordCommitCmdObjMutex       sync.RWMutex
	getRewordCommitCmdObjArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
	}
	getRewordCommitCmdObjReturns struct {
		result1 types.ICmdObj
		result2 error
	}
	getRewordCommitCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
		result2 error
	}
	GetStashEntriesStub        func(string) []*models.StashEntry
	getStashEntriesMutex       sync.RWMutex
	getStashEntriesArgsForCall []struct {
		arg1 string
	}
	getStashEntriesReturns struct {
		result1 []*models.StashEntry
	}
	getStashEntriesReturnsOnCall map[int]struct {
		result1 []*models.StashEntry
	}
	GetStatusFilesStub        func(loaders.LoadStatusFilesOpts) []*models.File
	getStatusFilesMutex       sync.RWMutex
	getStatusFilesArgsForCall []struct {
		arg1 loaders.LoadStatusFilesOpts
	}
	getStatusFilesReturns struct {
		result1 []*models.File
	}
	getStatusFilesReturnsOnCall map[int]struct {
		result1 []*models.File
	}
	GetSubmoduleConfigsStub        func() ([]*models.SubmoduleConfig, error)
	getSubmoduleConfigsMutex       sync.RWMutex
	getSubmoduleConfigsArgsForCall []struct {
	}
	getSubmoduleConfigsReturns struct {
		result1 []*models.SubmoduleConfig
		result2 error
	}
	getSubmoduleConfigsReturnsOnCall map[int]struct {
		result1 []*models.SubmoduleConfig
		result2 error
	}
	GetTagsStub        func() ([]*models.Tag, error)
	getTagsMutex       sync.RWMutex
	getTagsArgsForCall []struct {
	}
	getTagsReturns struct {
		result1 []*models.Tag
		result2 error
	}
	getTagsReturnsOnCall map[int]struct {
		result1 []*models.Tag
		result2 error
	}
	GetUpstreamForBranchStub        func(string) (string, error)
	getUpstreamForBranchMutex       sync.RWMutex
	getUpstreamForBranchArgsForCall []struct {
		arg1 string
	}
	getUpstreamForBranchReturns struct {
		result1 string
		result2 error
	}
	getUpstreamForBranchReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	IgnoreStub        func(string) error
	ignoreMutex       sync.RWMutex
	ignoreArgsForCall []struct {
		arg1 string
	}
	ignoreReturns struct {
		result1 error
	}
	ignoreReturnsOnCall map[int]struct {
		result1 error
	}
	InteractiveRebaseStub        func([]*models.Commit, int, string) error
	interactiveRebaseMutex       sync.RWMutex
	interactiveRebaseArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}
	interactiveRebaseReturns struct {
		result1 error
	}
	interactiveRebaseReturnsOnCall map[int]struct {
		result1 error
	}
	InteractiveRebaseCmdObjStub        func(string, string, bool) types.ICmdObj
	interactiveRebaseCmdObjMutex       sync.RWMutex
	interactiveRebaseCmdObjArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
	}
	interactiveRebaseCmdObjReturns struct {
		result1 types.ICmdObj
	}
	interactiveRebaseCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	IsBareRepoStub        func() bool
	isBareRepoMutex       sync.RWMutex
	isBareRepoArgsForCall []struct {
	}
	isBareRepoReturns struct {
		result1 bool
	}
	isBareRepoReturnsOnCall map[int]struct {
		result1 bool
	}
	IsHeadDetachedStub        func() bool
	isHeadDetachedMutex       sync.RWMutex
	isHeadDetachedArgsForCall []struct {
	}
	isHeadDetachedReturns struct {
		result1 bool
	}
	isHeadDetachedReturnsOnCall map[int]struct {
		result1 bool
	}
	IsInMergeStateStub        func() (bool, error)
	isInMergeStateMutex       sync.RWMutex
	isInMergeStateArgsForCall []struct {
	}
	isInMergeStateReturns struct {
		result1 bool
		result2 error
	}
	isInMergeStateReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	MergeStub        func(string, commands.MergeOpts) error
	mergeMutex       sync.RWMutex
	mergeArgsForCall []struct {
		arg1 string
		arg2 commands.MergeOpts
	}
	mergeReturns struct {
		result1 error
	}
	mergeReturnsOnCall map[int]struct {
		result1 error
	}
	MergeOrRebaseStub        func() string
	mergeOrRebaseMutex       sync.RWMutex
	mergeOrRebaseArgsForCall []struct {
	}
	mergeOrRebaseReturns struct {
		result1 string
	}
	mergeOrRebaseReturnsOnCall map[int]struct {
		result1 string
	}
	MoveCommitDownStub        func([]*models.Commit, int) error
	moveCommitDownMutex       sync.RWMutex
	moveCommitDownArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
	}
	moveCommitDownReturns struct {
		result1 error
	}
	moveCommitDownReturnsOnCall map[int]struct {
		result1 error
	}
	MovePatchIntoIndexStub        func([]*models.Commit, int, *patch.PatchManager, bool) error
	movePatchIntoIndexMutex       sync.RWMutex
	movePatchIntoIndexArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
		arg4 bool
	}
	movePatchIntoIndexReturns struct {
		result1 error
	}
	movePatchIntoIndexReturnsOnCall map[int]struct {
		result1 error
	}
	MovePatchToSelectedCommitStub        func([]*models.Commit, int, int, *patch.PatchManager) error
	movePatchToSelectedCommitMutex       sync.RWMutex
	movePatchToSelectedCommitArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 int
		arg4 *patch.PatchManager
	}
	movePatchToSelectedCommitReturns struct {
		result1 error
	}
	movePatchToSelectedCommitReturnsOnCall map[int]struct {
		result1 error
	}
	MoveTodoDownStub        func(int) error
	moveTodoDownMutex       sync.RWMutex
	moveTodoDownArgsForCall []struct {
		arg1 int
	}
	moveTodoDownReturns struct {
		result1 error
	}
	moveTodoDownReturnsOnCall map[int]struct {
		result1 error
	}
	NewPatchManagerStub        func() *patch.PatchManager
	newPatchManagerMutex       sync.RWMutex
	newPatchManagerArgsForCall []struct {
	}
	newPatchManagerReturns struct {
		result1 *patch.PatchManager
	}
	newPatchManagerReturnsOnCall map[int]struct {
		result1 *patch.PatchManager
	}
	OpenMergeToolCmdObjStub        func() types.ICmdObj
	openMergeToolCmdObjMutex       sync.RWMutex
	openMergeToolCmdObjArgsForCall []struct {
	}
	openMergeToolCmdObjReturns struct {
		result1 types.ICmdObj
	}
	openMergeToolCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	PullPatchIntoNewCommitStub        func([]*models.Commit, int, *patch.PatchManager) error
	pullPatchIntoNewCommitMutex       sync.RWMutex
	pullPatchIntoNewCommitArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
	}
	pullPatchIntoNewCommitReturns struct {
		result1 error
	}
	pullPatchIntoNewCommitReturnsOnCall map[int]struct {
		result1 error
	}
	PushStub        func(commands.PushOpts) (bool, error)
	pushMutex       sync.RWMutex
	pushArgsForCall []struct {
		arg1 commands.PushOpts
	}
	pushReturns struct {
		result1 bool
		result2 error
	}
	pushReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PushTagStub        func(string, string) error
	pushTagMutex       sync.RWMutex
	pushTagArgsForCall []struct {
		arg1 string
		arg2 string
	}
	pushTagReturns struct {
		result1 error
	}
	pushTagReturnsOnCall map[int]struct {
		result1 error
	}
	QuoteStub        func(string) string
	quoteMutex       sync.RWMutex
	quoteArgsForCall []struct {
		arg1 string
	}
	quoteReturns struct {
		result1 string
	}
	quoteReturnsOnCall map[int]struct {
		result1 string
	}
	RebaseBranchStub        func(string) error
	rebaseBranchMutex       sync.RWMutex
	rebaseBranchArgsForCall []struct {
		arg1 string
	}
	rebaseBranchReturns struct {
		result1 error
	}
	rebaseBranchReturnsOnCall map[int]struct {
		result1 error
	}
	RebaseModeStub        func() (commands.WorkingTreeState, error)
	rebaseModeMutex       sync.RWMutex
	rebaseModeArgsForCall []struct {
	}
	rebaseModeReturns struct {
		result1 commands.WorkingTreeState
		result2 error
	}
	rebaseModeReturnsOnCall map[int]struct {
		result1 commands.WorkingTreeState
		result2 error
	}
	RemoveRemoteStub        func(string) error
	removeRemoteMutex       sync.RWMutex
	removeRemoteArgsForCall []struct {
		arg1 string
	}
	removeRemoteReturns struct {
		result1 error
	}
	removeRemoteReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveTrackedFilesStub        func(string) error
	removeTrackedFilesMutex       sync.RWMutex
	removeTrackedFilesArgsForCall []struct {
		arg1 string
	}
	removeTrackedFilesReturns struct {
		result1 error
	}
	removeTrackedFilesReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveUntrackedDirFilesStub        func(*filetree.FileNode) error
	removeUntrackedDirFilesMutex       sync.RWMutex
	removeUntrackedDirFilesArgsForCall []struct {
		arg1 *filetree.FileNode
	}
	removeUntrackedDirFilesReturns struct {
		result1 error
	}
	removeUntrackedDirFilesReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveUntrackedFilesStub        func() error
	removeUntrackedFilesMutex       sync.RWMutex
	removeUntrackedFilesArgsForCall []struct {
	}
	removeUntrackedFilesReturns struct {
		result1 error
	}
	removeUntrackedFilesReturnsOnCall map[int]struct {
		result1 error
	}
	RenameBranchStub        func(string, string) error
	renameBranchMutex       sync.RWMutex
	renameBranchArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameBranchReturns struct {
		result1 error
	}
	renameBranchReturnsOnCall map[int]struct {
		result1 error
	}
	RenameRemoteStub        func(string, string) error
	renameRemoteMutex       sync.RWMutex
	renameRemoteArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameRemoteReturns struct {
		result1 error
	}
	renameRemoteReturnsOnCall map[int]struct {
		result1 error
	}
	ResetAndCleanStub        func() error
	resetAndCleanMutex       sync.RWMutex
	resetAndCleanArgsForCall []struct {
	}
	resetAndCleanReturns struct {
		result1 error
	}
	resetAndCleanReturnsOnCall map[int]struct {
		result1 error
	}
	ResetHardStub        func(string) error
	resetHardMutex       sync.RWMutex
	resetHardArgsForCall []struct {
		arg1 string
	}
	resetHardReturns struct {
		result1 error
	}
	resetHardReturnsOnCall map[int]struct {
		result1 error
	}
	ResetMixedStub        func(string) error
	resetMixedMutex       sync.RWMutex
	resetMixedArgsForCall []struct {
		arg1 string
	}
	resetMixedReturns struct {
		result1 error
	}
	resetMixedReturnsOnCall map[int]struct {
		result1 error
	}
	ResetSoftStub        func(string) error
	resetSoftMutex       sync.RWMutex
	resetSoftArgsForCall []struct {
		arg1 string
	}
	resetSoftReturns struct {
		result1 error
	}
	resetSoftReturnsOnCall map[int]struct {
		result1 error
	}
	ResetSubmodulesStub        func([]*models.SubmoduleConfig) error
	resetSubmodulesMutex       sync.RWMutex
	resetSubmodulesArgsForCall []struct {
		arg1 []*models.SubmoduleConfig
	}
	resetSubmodulesReturns struct {
		result1 error
	}
	resetSubmodulesReturnsOnCall map[int]struct {
		result1 error
	}
	ResetToRefStub        func(string, string, commands.ResetToCommitOptions) error
	resetToRefMutex       sync.RWMutex
	resetToRefArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 commands.ResetToCommitOptions
	}
	resetToRefReturns struct {
		result1 error
	}
	resetToRefReturnsOnCall map[int]struct {
		result1 error
	}
	RunStub        func(types.ICmdObj) error
	runMutex       sync.RWMutex
	runArgsForCall []struct {
		arg1 types.ICmdObj
	}
	runReturns struct {
		result1 error
	}
	runReturnsOnCall map[int]struct {
		result1 error
	}
	RunGitCmdFromStrStub        func(string) error
	runGitCmdFromStrMutex       sync.RWMutex
	runGitCmdFromStrArgsForCall []struct {
		arg1 string
	}
	runGitCmdFromStrReturns struct {
		result1 error
	}
	runGitCmdFromStrReturnsOnCall map[int]struct {
		result1 error
	}
	RunWithOutputStub        func(types.ICmdObj) (string, error)
	runWithOutputMutex       sync.RWMutex
	runWithOutputArgsForCall []struct {
		arg1 types.ICmdObj
	}
	runWithOutputReturns struct {
		result1 string
		result2 error
	}
	runWithOutputReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SetBranchUpstreamStub        func(string, string, string) error
	setBranchUpstreamMutex       sync.RWMutex
	setBranchUpstreamArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	setBranchUpstreamReturns struct {
		result1 error
	}
	setBranchUpstreamReturnsOnCall map[int]struct {
		result1 error
	}
	SetCredentialHandlersStub        func(func(types.CredentialKind) string, func(error))
	setCredentialHandlersMutex       sync.RWMutex
	setCredentialHandlersArgsForCall []struct {
		arg1 func(types.CredentialKind) string
		arg2 func(error)
	}
	SetUpstreamBranchStub        func(string) error
	setUpstreamBranchMutex       sync.RWMutex
	setUpstreamBranchArgsForCall []struct {
		arg1 string
	}
	setUpstreamBranchReturns struct {
		result1 error
	}
	setUpstreamBranchReturnsOnCall map[int]struct {
		result1 error
	}
	ShowFileDiffStub        func(string, string, bool, string, bool) (string, error)
	showFileDiffMutex       sync.RWMutex
	showFileDiffArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 string
		arg5 bool
	}
	showFileDiffReturns struct {
		result1 string
		result2 error
	}
	showFileDiffReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ShowFileDiffCmdObjStub        func(string, string, bool, string, bool, bool) types.ICmdObj
	showFileDiffCmdObjMutex       sync.RWMutex
	showFileDiffCmdObjArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 string
		arg5 bool
		arg6 bool
	}
	showFileDiffCmdObjReturns struct {
		result1 types.ICmdObj
	}
	showFileDiffCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	ShowStashEntryCmdObjStub        func(int) types.ICmdObj
	showStashEntryCmdObjMutex       sync.RWMutex
	showStashEntryCmdObjArgsForCall []struct {
		arg1 int
	}
	showStashEntryCmdObjReturns struct {
		result1 types.ICmdObj
	}
	showStashEntryCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	SkipEditorStub        func(types.ICmdObj)
	skipEditorMutex       sync.RWMutex
	skipEditorArgsForCall []struct {
		arg1 types.ICmdObj
	}
	SquashAllAboveFixupCommitsStub        func(string) error
	squashAllAboveFixupCommitsMutex       sync.RWMutex
	squashAllAboveFixupCommitsArgsForCall []struct {
		arg1 string
	}
	squashAllAboveFixupCommitsReturns struct {
		result1 error
	}
	squashAllAboveFixupCommitsReturnsOnCall map[int]struct {
		result1 error
	}
	StageAllStub        func() error
	stageAllMutex       sync.RWMutex
	stageAllArgsForCall []struct {
	}
	stageAllReturns struct {
		result1 error
	}
	stageAllReturnsOnCall map[int]struct {
		result1 error
	}
	StageFileStub        func(string) error
	stageFileMutex       sync.RWMutex
	stageFileArgsForCall []struct {
		arg1 string
	}
	stageFileReturns struct {
		result1 error
	}
	stageFileReturnsOnCall map[int]struct {
		result1 error
	}
	StashDoStub        func(int, string) error
	stashDoMutex       sync.RWMutex
	stashDoArgsForCall []struct {
		arg1 int
		arg2 string
	}
	stashDoReturns struct {
		result1 error
	}
	stashDoReturnsOnCall map[int]struct {
		result1 error
	}
	StashSaveStub        func(string) error
	stashSaveMutex       sync.RWMutex
	stashSaveArgsForCall []struct {
		arg1 string
	}
	stashSaveReturns struct {
		result1 error
	}
	stashSaveReturnsOnCall map[int]struct {
		result1 error
	}
	StashSaveStagedChangesStub        func(string) error
	stashSaveStagedChangesMutex       sync.RWMutex
	stashSaveStagedChangesArgsForCall []struct {
		arg1 string
	}
	stashSaveStagedChangesReturns struct {
		result1 error
	}
	stashSaveStagedChangesReturnsOnCall map[int]struct {
		result1 error
	}
	SubmoduleAddStub        func(string, string, string) error
	submoduleAddMutex       sync.RWMutex
	submoduleAddArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	submoduleAddReturns struct {
		result1 error
	}
	submoduleAddReturnsOnCall map[int]struct {
		result1 error
	}
	SubmoduleBulkDeinitCmdObjStub        func() types.ICmdObj
	submoduleBulkDeinitCmdObjMutex       sync.RWMutex
	submoduleBulkDeinitCmdObjArgsForCall []struct {
	}
	submoduleBulkDeinitCmdObjReturns struct {
		result1 types.ICmdObj
	}
	submoduleBulkDeinitCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	SubmoduleBulkInitCmdObjStub        func() types.ICmdObj
	submoduleBulkInitCmdObjMutex       sync.RWMutex
	submoduleBulkInitCmdObjArgsForCall []struct {
	}
	submoduleBulkInitCmdObjReturns struct {
		result1 types.ICmdObj
	}
	submoduleBulkInitCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	SubmoduleBulkUpdateCmdObjStub        func() types.ICmdObj
	submoduleBulkUpdateCmdObjMutex       sync.RWMutex
	submoduleBulkUpdateCmdObjArgsForCall []struct {
	}
	submoduleBulkUpdateCmdObjReturns struct {
		result1 types.ICmdObj
	}
	submoduleBulkUpdateCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	SubmoduleDeleteStub        func(*models.SubmoduleConfig) error
	submoduleDeleteMutex       sync.RWMutex
	submoduleDeleteArgsForCall []struct {
		arg1 *models.SubmoduleConfig
	}
	submoduleDeleteReturns struct {
		result1 error
	}
	submoduleDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	SubmoduleForceBulkUpdateCmdObjStub        func() types.ICmdObj
	submoduleForceBulkUpdateCmdObjMutex       sync.RWMutex
	submoduleForceBulkUpdateCmdObjArgsForCall []struct {
	}
	submoduleForceBulkUpdateCmdObjReturns struct {
		result1 types.ICmdObj
	}
	submoduleForceBulkUpdateCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	SubmoduleInitStub        func(string) error
	submoduleInitMutex       sync.RWMutex
	submoduleInitArgsForCall []struct {
		arg1 string
	}
	submoduleInitReturns struct {
		result1 error
	}
	submoduleInitReturnsOnCall map[int]struct {
		result1 error
	}
	SubmoduleResetStub        func(*models.SubmoduleConfig) error
	submoduleResetMutex       sync.RWMutex
	submoduleResetArgsForCall []struct {
		arg1 *models.SubmoduleConfig
	}
	submoduleResetReturns struct {
		result1 error
	}
	submoduleResetReturnsOnCall map[int]struct {
		result1 error
	}
	SubmoduleStashStub        func(*models.SubmoduleConfig) error
	submoduleStashMutex       sync.RWMutex
	submoduleStashArgsForCall []struct {
		arg1 *models.SubmoduleConfig
	}
	submoduleStashReturns struct {
		result1 error
	}
	submoduleStashReturnsOnCall map[int]struct {
		result1 error
	}
	SubmoduleUpdateStub        func(string) error
	submoduleUpdateMutex       sync.RWMutex
	submoduleUpdateArgsForCall []struct {
		arg1 string
	}
	submoduleUpdateReturns struct {
		result1 error
	}
	submoduleUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	SubmoduleUpdateUrlStub        func(string, string, string) error
	submoduleUpdateUrlMutex       sync.RWMutex
	submoduleUpdateUrlArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	submoduleUpdateUrlReturns struct {
		result1 error
	}
	submoduleUpdateUrlReturnsOnCall map[int]struct {
		result1 error
	}
	UnStageFileStub        func([]string, bool) error
	unStageFileMutex       sync.RWMutex
	unStageFileArgsForCall []struct {
		arg1 []string
		arg2 bool
	}
	unStageFileReturns struct {
		result1 error
	}
	unStageFileReturnsOnCall map[int]struct {
		result1 error
	}
	UnstageAllStub        func() error
	unstageAllMutex       sync.RWMutex
	unstageAllArgsForCall []struct {
	}
	unstageAllReturns struct {
		result1 error
	}
	unstageAllReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateRemoteUrlStub        func(string, string) error
	updateRemoteUrlMutex       sync.RWMutex
	updateRemoteUrlArgsForCall []struct {
		arg1 string
		arg2 string
	}
	updateRemoteUrlReturns struct {
		result1 error
	}
	updateRemoteUrlReturnsOnCall map[int]struct {
		result1 error
	}
	UsingGpgStub        func() bool
	usingGpgMutex       sync.RWMutex
	usingGpgArgsForCall []struct {
	}
	usingGpgReturns struct {
		result1 bool
	}
	usingGpgReturnsOnCall map[int]struct {
		result1 bool
	}
	WithSpanStub        func(string) commands.IGit
	withSpanMutex       sync.RWMutex
	withSpanArgsForCall []struct {
		arg1 string
	}
	withSpanReturns struct {
		result1 commands.IGit
	}
	withSpanReturnsOnCall map[int]struct {
		result1 commands.IGit
	}
	WorkingTreeStateStub        func() commands.WorkingTreeState
	workingTreeStateMutex       sync.RWMutex
	workingTreeStateArgsForCall []struct {
	}
	workingTreeStateReturns struct {
		result1 commands.WorkingTreeState
	}
	workingTreeStateReturnsOnCall map[int]struct {
		result1 commands.WorkingTreeState
	}
	WorktreeFileDiffStub        func(*models.File, bool, bool) string
	worktreeFileDiffMutex       sync.RWMutex
	worktreeFileDiffArgsForCall []struct {
		arg1 *models.File
		arg2 bool
		arg3 bool
	}
	worktreeFileDiffReturns struct {
		result1 string
	}
	worktreeFileDiffReturnsOnCall map[int]struct {
		result1 string
	}
	WorktreeFileDiffCmdObjStub        func(models.IFile, bool, bool) types.ICmdObj
	worktreeFileDiffCmdObjMutex       sync.RWMutex
	worktreeFileDiffCmdObjArgsForCall []struct {
		arg1 models.IFile
		arg2 bool
		arg3 bool
	}
	worktreeFileDiffCmdObjReturns struct {
		result1 types.ICmdObj
	}
	worktreeFileDiffCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIGit) AbortMerge() error {
	fake.abortMergeMutex.Lock()
	ret, specificReturn := fake.abortMergeReturnsOnCall[len(fake.abortMergeArgsForCall)]
	fake.abortMergeArgsForCall = append(fake.abortMergeArgsForCall, struct {
	}{})
	stub := fake.AbortMergeStub
	fakeReturns := fake.abortMergeReturns
	fake.recordInvocation("AbortMerge", []interface{}{})
	fake.abortMergeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) AbortMergeCallCount() int {
	fake.abortMergeMutex.RLock()
	defer fake.abortMergeMutex.RUnlock()
	return len(fake.abortMergeArgsForCall)
}

func (fake *FakeIGit) AbortMergeCalls(stub func() error) {
	fake.abortMergeMutex.Lock()
	defer fake.abortMergeMutex.Unlock()
	fake.AbortMergeStub = stub
}

func (fake *FakeIGit) AbortMergeReturns(result1 error) {
	fake.abortMergeMutex.Lock()
	defer fake.abortMergeMutex.Unlock()
	fake.AbortMergeStub = nil
	fake.abortMergeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) AbortMergeReturnsOnCall(i int, result1 error) {
	fake.abortMergeMutex.Lock()
	defer fake.abortMergeMutex.Unlock()
	fake.AbortMergeStub = nil
	if fake.abortMergeReturnsOnCall == nil {
		fake.abortMergeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.abortMergeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) AbortRebase() error {
	fake.abortRebaseMutex.Lock()
	ret, specificReturn := fake.abortRebaseReturnsOnCall[len(fake.abortRebaseArgsForCall)]
	fake.abortRebaseArgsForCall = append(fake.abortRebaseArgsForCall, struct {
	}{})
	stub := fake.AbortRebaseStub
	fakeReturns := fake.abortRebaseReturns
	fake.recordInvocation("AbortRebase", []interface{}{})
	fake.abortRebaseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) AbortRebaseCallCount() int {
	fake.abortRebaseMutex.RLock()
	defer fake.abortRebaseMutex.RUnlock()
	return len(fake.abortRebaseArgsForCall)
}

func (fake *FakeIGit) AbortRebaseCalls(stub func() error) {
	fake.abortRebaseMutex.Lock()
	defer fake.abortRebaseMutex.Unlock()
	fake.AbortRebaseStub = stub
}

func (fake *FakeIGit) AbortRebaseReturns(result1 error) {
	fake.abortRebaseMutex.Lock()
	defer fake.abortRebaseMutex.Unlock()
	fake.AbortRebaseStub = nil
	fake.abortRebaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) AbortRebaseReturnsOnCall(i int, result1 error) {
	fake.abortRebaseMutex.Lock()
	defer fake.abortRebaseMutex.Unlock()
	fake.AbortRebaseStub = nil
	if fake.abortRebaseReturnsOnCall == nil {
		fake.abortRebaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.abortRebaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) AddRemote(arg1 string, arg2 string) error {
	fake.addRemoteMutex.Lock()
	ret, specificReturn := fake.addRemoteReturnsOnCall[len(fake.addRemoteArgsForCall)]
	fake.addRemoteArgsForCall = append(fake.addRemoteArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AddRemoteStub
	fakeReturns := fake.addRemoteReturns
	fake.recordInvocation("AddRemote", []interface{}{arg1, arg2})
	fake.addRemoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) AddRemoteCallCount() int {
	fake.addRemoteMutex.RLock()
	defer fake.addRemoteMutex.RUnlock()
	return len(fake.addRemoteArgsForCall)
}

func (fake *FakeIGit) AddRemoteCalls(stub func(string, string) error) {
	fake.addRemoteMutex.Lock()
	defer fake.addRemoteMutex.Unlock()
	fake.AddRemoteStub = stub
}

func (fake *FakeIGit) AddRemoteArgsForCall(i int) (string, string) {
	fake.addRemoteMutex.RLock()
	defer fake.addRemoteMutex.RUnlock()
	argsForCall := fake.addRemoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) AddRemoteReturns(result1 error) {
	fake.addRemoteMutex.Lock()
	defer fake.addRemoteMutex.Unlock()
	fake.AddRemoteStub = nil
	fake.addRemoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) AddRemoteReturnsOnCall(i int, result1 error) {
	fake.addRemoteMutex.Lock()
	defer fake.addRemoteMutex.Unlock()
	fake.AddRemoteStub = nil
	if fake.addRemoteReturnsOnCall == nil {
		fake.addRemoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addRemoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) AllBranchesCmdObj() types.ICmdObj {
	fake.allBranchesCmdObjMutex.Lock()
	ret, specificReturn := fake.allBranchesCmdObjReturnsOnCall[len(fake.allBranchesCmdObjArgsForCall)]
	fake.allBranchesCmdObjArgsForCall = append(fake.allBranchesCmdObjArgsForCall, struct {
	}{})
	stub := fake.AllBranchesCmdObjStub
	fakeReturns := fake.allBranchesCmdObjReturns
	fake.recordInvocation("AllBranchesCmdObj", []interface{}{})
	fake.allBranchesCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) AllBranchesCmdObjCallCount() int {
	fake.allBranchesCmdObjMutex.RLock()
	defer fake.allBranchesCmdObjMutex.RUnlock()
	return len(fake.allBranchesCmdObjArgsForCall)
}

func (fake *FakeIGit) AllBranchesCmdObjCalls(stub func() types.ICmdObj) {
	fake.allBranchesCmdObjMutex.Lock()
	defer fake.allBranchesCmdObjMutex.Unlock()
	fake.AllBranchesCmdObjStub = stub
}

func (fake *FakeIGit) AllBranchesCmdObjReturns(result1 types.ICmdObj) {
	fake.allBranchesCmdObjMutex.Lock()
	defer fake.allBranchesCmdObjMutex.Unlock()
	fake.AllBranchesCmdObjStub = nil
	fake.allBranchesCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) AllBranchesCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.allBranchesCmdObjMutex.Lock()
	defer fake.allBranchesCmdObjMutex.Unlock()
	fake.AllBranchesCmdObjStub = nil
	if fake.allBranchesCmdObjReturnsOnCall == nil {
		fake.allBranchesCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.allBranchesCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) AmendTo(arg1 string) error {
	fake.amendToMutex.Lock()
	ret, specificReturn := fake.amendToReturnsOnCall[len(fake.amendToArgsForCall)]
	fake.amendToArgsForCall = append(fake.amendToArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AmendToStub
	fakeReturns := fake.amendToReturns
	fake.recordInvocation("AmendTo", []interface{}{arg1})
	fake.amendToMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) AmendToCallCount() int {
	fake.amendToMutex.RLock()
	defer fake.amendToMutex.RUnlock()
	return len(fake.amendToArgsForCall)
}

func (fake *FakeIGit) AmendToCalls(stub func(string) error) {
	fake.amendToMutex.Lock()
	defer fake.amendToMutex.Unlock()
	fake.AmendToStub = stub
}

func (fake *FakeIGit) AmendToArgsForCall(i int) string {
	fake.amendToMutex.RLock()
	defer fake.amendToMutex.RUnlock()
	argsForCall := fake.amendToArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) AmendToReturns(result1 error) {
	fake.amendToMutex.Lock()
	defer fake.amendToMutex.Unlock()
	fake.AmendToStub = nil
	fake.amendToReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) AmendToReturnsOnCall(i int, result1 error) {
	fake.amendToMutex.Lock()
	defer fake.amendToMutex.Unlock()
	fake.AmendToStub = nil
	if fake.amendToReturnsOnCall == nil {
		fake.amendToReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.amendToReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ApplyPatch(arg1 string, arg2 ...string) error {
	fake.applyPatchMutex.Lock()
	ret, specificReturn := fake.applyPatchReturnsOnCall[len(fake.applyPatchArgsForCall)]
	fake.applyPatchArgsForCall = append(fake.applyPatchArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2})
	stub := fake.ApplyPatchStub
	fakeReturns := fake.applyPatchReturns
	fake.recordInvocation("ApplyPatch", []interface{}{arg1, arg2})
	fake.applyPatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ApplyPatchCallCount() int {
	fake.applyPatchMutex.RLock()
	defer fake.applyPatchMutex.RUnlock()
	return len(fake.applyPatchArgsForCall)
}

func (fake *FakeIGit) ApplyPatchCalls(stub func(string, ...string) error) {
	fake.applyPatchMutex.Lock()
	defer fake.applyPatchMutex.Unlock()
	fake.ApplyPatchStub = stub
}

func (fake *FakeIGit) ApplyPatchArgsForCall(i int) (string, []string) {
	fake.applyPatchMutex.RLock()
	defer fake.applyPatchMutex.RUnlock()
	argsForCall := fake.applyPatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) ApplyPatchReturns(result1 error) {
	fake.applyPatchMutex.Lock()
	defer fake.applyPatchMutex.Unlock()
	fake.ApplyPatchStub = nil
	fake.applyPatchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ApplyPatchReturnsOnCall(i int, result1 error) {
	fake.applyPatchMutex.Lock()
	defer fake.applyPatchMutex.Unlock()
	fake.ApplyPatchStub = nil
	if fake.applyPatchReturnsOnCall == nil {
		fake.applyPatchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyPatchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) BeforeAndAfterFileForRename(arg1 *models.File) (*models.File, *models.File, error) {
	fake.beforeAndAfterFileForRenameMutex.Lock()
	ret, specificReturn := fake.beforeAndAfterFileForRenameReturnsOnCall[len(fake.beforeAndAfterFileForRenameArgsForCall)]
	fake.beforeAndAfterFileForRenameArgsForCall = append(fake.beforeAndAfterFileForRenameArgsForCall, struct {
		arg1 *models.File
	}{arg1})
	stub := fake.BeforeAndAfterFileForRenameStub
	fakeReturns := fake.beforeAndAfterFileForRenameReturns
	fake.recordInvocation("BeforeAndAfterFileForRename", []interface{}{arg1})
	fake.beforeAndAfterFileForRenameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIGit) BeforeAndAfterFileForRenameCallCount() int {
	fake.beforeAndAfterFileForRenameMutex.RLock()
	defer fake.beforeAndAfterFileForRenameMutex.RUnlock()
	return len(fake.beforeAndAfterFileForRenameArgsForCall)
}

func (fake *FakeIGit) BeforeAndAfterFileForRenameCalls(stub func(*models.File) (*models.File, *models.File, error)) {
	fake.beforeAndAfterFileForRenameMutex.Lock()
	defer fake.beforeAndAfterFileForRenameMutex.Unlock()
	fake.BeforeAndAfterFileForRenameStub = stub
}

func (fake *FakeIGit) BeforeAndAfterFileForRenameArgsForCall(i int) *models.File {
	fake.beforeAndAfterFileForRenameMutex.RLock()
	defer fake.beforeAndAfterFileForRenameMutex.RUnlock()
	argsForCall := fake.beforeAndAfterFileForRenameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) BeforeAndAfterFileForRenameReturns(result1 *models.File, result2 *models.File, result3 error) {
	fake.beforeAndAfterFileForRenameMutex.Lock()
	defer fake.beforeAndAfterFileForRenameMutex.Unlock()
	fake.BeforeAndAfterFileForRenameStub = nil
	fake.beforeAndAfterFileForRenameReturns = struct {
		result1 *models.File
		result2 *models.File
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIGit) BeforeAndAfterFileForRenameReturnsOnCall(i int, result1 *models.File, result2 *models.File, result3 error) {
	fake.beforeAndAfterFileForRenameMutex.Lock()
	defer fake.beforeAndAfterFileForRenameMutex.Unlock()
	fake.BeforeAndAfterFileForRenameStub = nil
	if fake.beforeAndAfterFileForRenameReturnsOnCall == nil {
		fake.beforeAndAfterFileForRenameReturnsOnCall = make(map[int]struct {
			result1 *models.File
			result2 *models.File
			result3 error
		})
	}
	fake.beforeAndAfterFileForRenameReturnsOnCall[i] = struct {
		result1 *models.File
		result2 *models.File
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIGit) BeginInteractiveRebaseForCommit(arg1 []*models.Commit, arg2 int) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.beginInteractiveRebaseForCommitMutex.Lock()
	ret, specificReturn := fake.beginInteractiveRebaseForCommitReturnsOnCall[len(fake.beginInteractiveRebaseForCommitArgsForCall)]
	fake.beginInteractiveRebaseForCommitArgsForCall = append(fake.beginInteractiveRebaseForCommitArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
	}{arg1Copy, arg2})
	stub := fake.BeginInteractiveRebaseForCommitStub
	fakeReturns := fake.beginInteractiveRebaseForCommitReturns
	fake.recordInvocation("BeginInteractiveRebaseForCommit", []interface{}{arg1Copy, arg2})
	fake.beginInteractiveRebaseForCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) BeginInteractiveRebaseForCommitCallCount() int {
	fake.beginInteractiveRebaseForCommitMutex.RLock()
	defer fake.beginInteractiveRebaseForCommitMutex.RUnlock()
	return len(fake.beginInteractiveRebaseForCommitArgsForCall)
}

func (fake *FakeIGit) BeginInteractiveRebaseForCommitCalls(stub func([]*models.Commit, int) error) {
	fake.beginInteractiveRebaseForCommitMutex.Lock()
	defer fake.beginInteractiveRebaseForCommitMutex.Unlock()
	fake.BeginInteractiveRebaseForCommitStub = stub
}

func (fake *FakeIGit) BeginInteractiveRebaseForCommitArgsForCall(i int) ([]*models.Commit, int) {
	fake.beginInteractiveRebaseForCommitMutex.RLock()
	defer fake.beginInteractiveRebaseForCommitMutex.RUnlock()
	argsForCall := fake.beginInteractiveRebaseForCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) BeginInteractiveRebaseForCommitReturns(result1 error) {
	fake.beginInteractiveRebaseForCommitMutex.Lock()
	defer fake.beginInteractiveRebaseForCommitMutex.Unlock()
	fake.BeginInteractiveRebaseForCommitStub = nil
	fake.beginInteractiveRebaseForCommitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) BeginInteractiveRebaseForCommitReturnsOnCall(i int, result1 error) {
	fake.beginInteractiveRebaseForCommitMutex.Lock()
	defer fake.beginInteractiveRebaseForCommitMutex.Unlock()
	fake.BeginInteractiveRebaseForCommitStub = nil
	if fake.beginInteractiveRebaseForCommitReturnsOnCall == nil {
		fake.beginInteractiveRebaseForCommitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.beginInteractiveRebaseForCommitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) Branches() commands.IBranchesMgr {
	fake.branchesMutex.Lock()
	ret, specificReturn := fake.branchesReturnsOnCall[len(fake.branchesArgsForCall)]
	fake.branchesArgsForCall = append(fake.branchesArgsForCall, struct {
	}{})
	stub := fake.BranchesStub
	fakeReturns := fake.branchesReturns
	fake.recordInvocation("Branches", []interface{}{})
	fake.branchesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) BranchesCallCount() int {
	fake.branchesMutex.RLock()
	defer fake.branchesMutex.RUnlock()
	return len(fake.branchesArgsForCall)
}

func (fake *FakeIGit) BranchesCalls(stub func() commands.IBranchesMgr) {
	fake.branchesMutex.Lock()
	defer fake.branchesMutex.Unlock()
	fake.BranchesStub = stub
}

func (fake *FakeIGit) BranchesReturns(result1 commands.IBranchesMgr) {
	fake.branchesMutex.Lock()
	defer fake.branchesMutex.Unlock()
	fake.BranchesStub = nil
	fake.branchesReturns = struct {
		result1 commands.IBranchesMgr
	}{result1}
}

func (fake *FakeIGit) BranchesReturnsOnCall(i int, result1 commands.IBranchesMgr) {
	fake.branchesMutex.Lock()
	defer fake.branchesMutex.Unlock()
	fake.BranchesStub = nil
	if fake.branchesReturnsOnCall == nil {
		fake.branchesReturnsOnCall = make(map[int]struct {
			result1 commands.IBranchesMgr
		})
	}
	fake.branchesReturnsOnCall[i] = struct {
		result1 commands.IBranchesMgr
	}{result1}
}

func (fake *FakeIGit) BuildGitCmdObjFromStr(arg1 string) types.ICmdObj {
	fake.buildGitCmdObjFromStrMutex.Lock()
	ret, specificReturn := fake.buildGitCmdObjFromStrReturnsOnCall[len(fake.buildGitCmdObjFromStrArgsForCall)]
	fake.buildGitCmdObjFromStrArgsForCall = append(fake.buildGitCmdObjFromStrArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.BuildGitCmdObjFromStrStub
	fakeReturns := fake.buildGitCmdObjFromStrReturns
	fake.recordInvocation("BuildGitCmdObjFromStr", []interface{}{arg1})
	fake.buildGitCmdObjFromStrMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) BuildGitCmdObjFromStrCallCount() int {
	fake.buildGitCmdObjFromStrMutex.RLock()
	defer fake.buildGitCmdObjFromStrMutex.RUnlock()
	return len(fake.buildGitCmdObjFromStrArgsForCall)
}

func (fake *FakeIGit) BuildGitCmdObjFromStrCalls(stub func(string) types.ICmdObj) {
	fake.buildGitCmdObjFromStrMutex.Lock()
	defer fake.buildGitCmdObjFromStrMutex.Unlock()
	fake.BuildGitCmdObjFromStrStub = stub
}

func (fake *FakeIGit) BuildGitCmdObjFromStrArgsForCall(i int) string {
	fake.buildGitCmdObjFromStrMutex.RLock()
	defer fake.buildGitCmdObjFromStrMutex.RUnlock()
	argsForCall := fake.buildGitCmdObjFromStrArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) BuildGitCmdObjFromStrReturns(result1 types.ICmdObj) {
	fake.buildGitCmdObjFromStrMutex.Lock()
	defer fake.buildGitCmdObjFromStrMutex.Unlock()
	fake.BuildGitCmdObjFromStrStub = nil
	fake.buildGitCmdObjFromStrReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) BuildGitCmdObjFromStrReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.buildGitCmdObjFromStrMutex.Lock()
	defer fake.buildGitCmdObjFromStrMutex.Unlock()
	fake.BuildGitCmdObjFromStrStub = nil
	if fake.buildGitCmdObjFromStrReturnsOnCall == nil {
		fake.buildGitCmdObjFromStrReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.buildGitCmdObjFromStrReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) BuildShellCmdObj(arg1 string) types.ICmdObj {
	fake.buildShellCmdObjMutex.Lock()
	ret, specificReturn := fake.buildShellCmdObjReturnsOnCall[len(fake.buildShellCmdObjArgsForCall)]
	fake.buildShellCmdObjArgsForCall = append(fake.buildShellCmdObjArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.BuildShellCmdObjStub
	fakeReturns := fake.buildShellCmdObjReturns
	fake.recordInvocation("BuildShellCmdObj", []interface{}{arg1})
	fake.buildShellCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) BuildShellCmdObjCallCount() int {
	fake.buildShellCmdObjMutex.RLock()
	defer fake.buildShellCmdObjMutex.RUnlock()
	return len(fake.buildShellCmdObjArgsForCall)
}

func (fake *FakeIGit) BuildShellCmdObjCalls(stub func(string) types.ICmdObj) {
	fake.buildShellCmdObjMutex.Lock()
	defer fake.buildShellCmdObjMutex.Unlock()
	fake.BuildShellCmdObjStub = stub
}

func (fake *FakeIGit) BuildShellCmdObjArgsForCall(i int) string {
	fake.buildShellCmdObjMutex.RLock()
	defer fake.buildShellCmdObjMutex.RUnlock()
	argsForCall := fake.buildShellCmdObjArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) BuildShellCmdObjReturns(result1 types.ICmdObj) {
	fake.buildShellCmdObjMutex.Lock()
	defer fake.buildShellCmdObjMutex.Unlock()
	fake.BuildShellCmdObjStub = nil
	fake.buildShellCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) BuildShellCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.buildShellCmdObjMutex.Lock()
	defer fake.buildShellCmdObjMutex.Unlock()
	fake.BuildShellCmdObjStub = nil
	if fake.buildShellCmdObjReturnsOnCall == nil {
		fake.buildShellCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.buildShellCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) CatFile(arg1 string) (string, error) {
	fake.catFileMutex.Lock()
	ret, specificReturn := fake.catFileReturnsOnCall[len(fake.catFileArgsForCall)]
	fake.catFileArgsForCall = append(fake.catFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CatFileStub
	fakeReturns := fake.catFileReturns
	fake.recordInvocation("CatFile", []interface{}{arg1})
	fake.catFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) CatFileCallCount() int {
	fake.catFileMutex.RLock()
	defer fake.catFileMutex.RUnlock()
	return len(fake.catFileArgsForCall)
}

func (fake *FakeIGit) CatFileCalls(stub func(string) (string, error)) {
	fake.catFileMutex.Lock()
	defer fake.catFileMutex.Unlock()
	fake.CatFileStub = stub
}

func (fake *FakeIGit) CatFileArgsForCall(i int) string {
	fake.catFileMutex.RLock()
	defer fake.catFileMutex.RUnlock()
	argsForCall := fake.catFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) CatFileReturns(result1 string, result2 error) {
	fake.catFileMutex.Lock()
	defer fake.catFileMutex.Unlock()
	fake.CatFileStub = nil
	fake.catFileReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) CatFileReturnsOnCall(i int, result1 string, result2 error) {
	fake.catFileMutex.Lock()
	defer fake.catFileMutex.Unlock()
	fake.CatFileStub = nil
	if fake.catFileReturnsOnCall == nil {
		fake.catFileReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.catFileReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) CheckRemoteBranchExists(arg1 *models.Branch) bool {
	fake.checkRemoteBranchExistsMutex.Lock()
	ret, specificReturn := fake.checkRemoteBranchExistsReturnsOnCall[len(fake.checkRemoteBranchExistsArgsForCall)]
	fake.checkRemoteBranchExistsArgsForCall = append(fake.checkRemoteBranchExistsArgsForCall, struct {
		arg1 *models.Branch
	}{arg1})
	stub := fake.CheckRemoteBranchExistsStub
	fakeReturns := fake.checkRemoteBranchExistsReturns
	fake.recordInvocation("CheckRemoteBranchExists", []interface{}{arg1})
	fake.checkRemoteBranchExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) CheckRemoteBranchExistsCallCount() int {
	fake.checkRemoteBranchExistsMutex.RLock()
	defer fake.checkRemoteBranchExistsMutex.RUnlock()
	return len(fake.checkRemoteBranchExistsArgsForCall)
}

func (fake *FakeIGit) CheckRemoteBranchExistsCalls(stub func(*models.Branch) bool) {
	fake.checkRemoteBranchExistsMutex.Lock()
	defer fake.checkRemoteBranchExistsMutex.Unlock()
	fake.CheckRemoteBranchExistsStub = stub
}

func (fake *FakeIGit) CheckRemoteBranchExistsArgsForCall(i int) *models.Branch {
	fake.checkRemoteBranchExistsMutex.RLock()
	defer fake.checkRemoteBranchExistsMutex.RUnlock()
	argsForCall := fake.checkRemoteBranchExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) CheckRemoteBranchExistsReturns(result1 bool) {
	fake.checkRemoteBranchExistsMutex.Lock()
	defer fake.checkRemoteBranchExistsMutex.Unlock()
	fake.CheckRemoteBranchExistsStub = nil
	fake.checkRemoteBranchExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) CheckRemoteBranchExistsReturnsOnCall(i int, result1 bool) {
	fake.checkRemoteBranchExistsMutex.Lock()
	defer fake.checkRemoteBranchExistsMutex.Unlock()
	fake.CheckRemoteBranchExistsStub = nil
	if fake.checkRemoteBranchExistsReturnsOnCall == nil {
		fake.checkRemoteBranchExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.checkRemoteBranchExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) Checkout(arg1 string, arg2 commands.CheckoutOptions) error {
	fake.checkoutMutex.Lock()
	ret, specificReturn := fake.checkoutReturnsOnCall[len(fake.checkoutArgsForCall)]
	fake.checkoutArgsForCall = append(fake.checkoutArgsForCall, struct {
		arg1 string
		arg2 commands.CheckoutOptions
	}{arg1, arg2})
	stub := fake.CheckoutStub
	fakeReturns := fake.checkoutReturns
	fake.recordInvocation("Checkout", []interface{}{arg1, arg2})
	fake.checkoutMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) CheckoutCallCount() int {
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	return len(fake.checkoutArgsForCall)
}

func (fake *FakeIGit) CheckoutCalls(stub func(string, commands.CheckoutOptions) error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = stub
}

func (fake *FakeIGit) CheckoutArgsForCall(i int) (string, commands.CheckoutOptions) {
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	argsForCall := fake.checkoutArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) CheckoutReturns(result1 error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = nil
	fake.checkoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) CheckoutReturnsOnCall(i int, result1 error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = nil
	if fake.checkoutReturnsOnCall == nil {
		fake.checkoutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkoutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) CheckoutFile(arg1 string, arg2 string) error {
	fake.checkoutFileMutex.Lock()
	ret, specificReturn := fake.checkoutFileReturnsOnCall[len(fake.checkoutFileArgsForCall)]
	fake.checkoutFileArgsForCall = append(fake.checkoutFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CheckoutFileStub
	fakeReturns := fake.checkoutFileReturns
	fake.recordInvocation("CheckoutFile", []interface{}{arg1, arg2})
	fake.checkoutFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) CheckoutFileCallCount() int {
	fake.checkoutFileMutex.RLock()
	defer fake.checkoutFileMutex.RUnlock()
	return len(fake.checkoutFileArgsForCall)
}

func (fake *FakeIGit) CheckoutFileCalls(stub func(string, string) error) {
	fake.checkoutFileMutex.Lock()
	defer fake.checkoutFileMutex.Unlock()
	fake.CheckoutFileStub = stub
}

func (fake *FakeIGit) CheckoutFileArgsForCall(i int) (string, string) {
	fake.checkoutFileMutex.RLock()
	defer fake.checkoutFileMutex.RUnlock()
	argsForCall := fake.checkoutFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) CheckoutFileReturns(result1 error) {
	fake.checkoutFileMutex.Lock()
	defer fake.checkoutFileMutex.Unlock()
	fake.CheckoutFileStub = nil
	fake.checkoutFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) CheckoutFileReturnsOnCall(i int, result1 error) {
	fake.checkoutFileMutex.Lock()
	defer fake.checkoutFileMutex.Unlock()
	fake.CheckoutFileStub = nil
	if fake.checkoutFileReturnsOnCall == nil {
		fake.checkoutFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkoutFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) CherryPickCommits(arg1 []*models.Commit) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.cherryPickCommitsMutex.Lock()
	ret, specificReturn := fake.cherryPickCommitsReturnsOnCall[len(fake.cherryPickCommitsArgsForCall)]
	fake.cherryPickCommitsArgsForCall = append(fake.cherryPickCommitsArgsForCall, struct {
		arg1 []*models.Commit
	}{arg1Copy})
	stub := fake.CherryPickCommitsStub
	fakeReturns := fake.cherryPickCommitsReturns
	fake.recordInvocation("CherryPickCommits", []interface{}{arg1Copy})
	fake.cherryPickCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) CherryPickCommitsCallCount() int {
	fake.cherryPickCommitsMutex.RLock()
	defer fake.cherryPickCommitsMutex.RUnlock()
	return len(fake.cherryPickCommitsArgsForCall)
}

func (fake *FakeIGit) CherryPickCommitsCalls(stub func([]*models.Commit) error) {
	fake.cherryPickCommitsMutex.Lock()
	defer fake.cherryPickCommitsMutex.Unlock()
	fake.CherryPickCommitsStub = stub
}

func (fake *FakeIGit) CherryPickCommitsArgsForCall(i int) []*models.Commit {
	fake.cherryPickCommitsMutex.RLock()
	defer fake.cherryPickCommitsMutex.RUnlock()
	argsForCall := fake.cherryPickCommitsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) CherryPickCommitsReturns(result1 error) {
	fake.cherryPickCommitsMutex.Lock()
	defer fake.cherryPickCommitsMutex.Unlock()
	fake.CherryPickCommitsStub = nil
	fake.cherryPickCommitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) CherryPickCommitsReturnsOnCall(i int, result1 error) {
	fake.cherryPickCommitsMutex.Lock()
	defer fake.cherryPickCommitsMutex.Unlock()
	fake.CherryPickCommitsStub = nil
	if fake.cherryPickCommitsReturnsOnCall == nil {
		fake.cherryPickCommitsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cherryPickCommitsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) Commits() commands.ICommitsMgr {
	fake.commitsMutex.Lock()
	ret, specificReturn := fake.commitsReturnsOnCall[len(fake.commitsArgsForCall)]
	fake.commitsArgsForCall = append(fake.commitsArgsForCall, struct {
	}{})
	stub := fake.CommitsStub
	fakeReturns := fake.commitsReturns
	fake.recordInvocation("Commits", []interface{}{})
	fake.commitsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) CommitsCallCount() int {
	fake.commitsMutex.RLock()
	defer fake.commitsMutex.RUnlock()
	return len(fake.commitsArgsForCall)
}

func (fake *FakeIGit) CommitsCalls(stub func() commands.ICommitsMgr) {
	fake.commitsMutex.Lock()
	defer fake.commitsMutex.Unlock()
	fake.CommitsStub = stub
}

func (fake *FakeIGit) CommitsReturns(result1 commands.ICommitsMgr) {
	fake.commitsMutex.Lock()
	defer fake.commitsMutex.Unlock()
	fake.CommitsStub = nil
	fake.commitsReturns = struct {
		result1 commands.ICommitsMgr
	}{result1}
}

func (fake *FakeIGit) CommitsReturnsOnCall(i int, result1 commands.ICommitsMgr) {
	fake.commitsMutex.Lock()
	defer fake.commitsMutex.Unlock()
	fake.CommitsStub = nil
	if fake.commitsReturnsOnCall == nil {
		fake.commitsReturnsOnCall = make(map[int]struct {
			result1 commands.ICommitsMgr
		})
	}
	fake.commitsReturnsOnCall[i] = struct {
		result1 commands.ICommitsMgr
	}{result1}
}

func (fake *FakeIGit) ContinueRebase() error {
	fake.continueRebaseMutex.Lock()
	ret, specificReturn := fake.continueRebaseReturnsOnCall[len(fake.continueRebaseArgsForCall)]
	fake.continueRebaseArgsForCall = append(fake.continueRebaseArgsForCall, struct {
	}{})
	stub := fake.ContinueRebaseStub
	fakeReturns := fake.continueRebaseReturns
	fake.recordInvocation("ContinueRebase", []interface{}{})
	fake.continueRebaseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ContinueRebaseCallCount() int {
	fake.continueRebaseMutex.RLock()
	defer fake.continueRebaseMutex.RUnlock()
	return len(fake.continueRebaseArgsForCall)
}

func (fake *FakeIGit) ContinueRebaseCalls(stub func() error) {
	fake.continueRebaseMutex.Lock()
	defer fake.continueRebaseMutex.Unlock()
	fake.ContinueRebaseStub = stub
}

func (fake *FakeIGit) ContinueRebaseReturns(result1 error) {
	fake.continueRebaseMutex.Lock()
	defer fake.continueRebaseMutex.Unlock()
	fake.ContinueRebaseStub = nil
	fake.continueRebaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ContinueRebaseReturnsOnCall(i int, result1 error) {
	fake.continueRebaseMutex.Lock()
	defer fake.continueRebaseMutex.Unlock()
	fake.ContinueRebaseStub = nil
	if fake.continueRebaseReturnsOnCall == nil {
		fake.continueRebaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.continueRebaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) CreateLightweightTag(arg1 string, arg2 string) error {
	fake.createLightweightTagMutex.Lock()
	ret, specificReturn := fake.createLightweightTagReturnsOnCall[len(fake.createLightweightTagArgsForCall)]
	fake.createLightweightTagArgsForCall = append(fake.createLightweightTagArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateLightweightTagStub
	fakeReturns := fake.createLightweightTagReturns
	fake.recordInvocation("CreateLightweightTag", []interface{}{arg1, arg2})
	fake.createLightweightTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) CreateLightweightTagCallCount() int {
	fake.createLightweightTagMutex.RLock()
	defer fake.createLightweightTagMutex.RUnlock()
	return len(fake.createLightweightTagArgsForCall)
}

func (fake *FakeIGit) CreateLightweightTagCalls(stub func(string, string) error) {
	fake.createLightweightTagMutex.Lock()
	defer fake.createLightweightTagMutex.Unlock()
	fake.CreateLightweightTagStub = stub
}

func (fake *FakeIGit) CreateLightweightTagArgsForCall(i int) (string, string) {
	fake.createLightweightTagMutex.RLock()
	defer fake.createLightweightTagMutex.RUnlock()
	argsForCall := fake.createLightweightTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) CreateLightweightTagReturns(result1 error) {
	fake.createLightweightTagMutex.Lock()
	defer fake.createLightweightTagMutex.Unlock()
	fake.CreateLightweightTagStub = nil
	fake.createLightweightTagReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) CreateLightweightTagReturnsOnCall(i int, result1 error) {
	fake.createLightweightTagMutex.Lock()
	defer fake.createLightweightTagMutex.Unlock()
	fake.CreateLightweightTagStub = nil
	if fake.createLightweightTagReturnsOnCall == nil {
		fake.createLightweightTagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createLightweightTagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) CurrentBranchName() (string, string, error) {
	fake.currentBranchNameMutex.Lock()
	ret, specificReturn := fake.currentBranchNameReturnsOnCall[len(fake.currentBranchNameArgsForCall)]
	fake.currentBranchNameArgsForCall = append(fake.currentBranchNameArgsForCall, struct {
	}{})
	stub := fake.CurrentBranchNameStub
	fakeReturns := fake.currentBranchNameReturns
	fake.recordInvocation("CurrentBranchName", []interface{}{})
	fake.currentBranchNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIGit) CurrentBranchNameCallCount() int {
	fake.currentBranchNameMutex.RLock()
	defer fake.currentBranchNameMutex.RUnlock()
	return len(fake.currentBranchNameArgsForCall)
}

func (fake *FakeIGit) CurrentBranchNameCalls(stub func() (string, string, error)) {
	fake.currentBranchNameMutex.Lock()
	defer fake.currentBranchNameMutex.Unlock()
	fake.CurrentBranchNameStub = stub
}

func (fake *FakeIGit) CurrentBranchNameReturns(result1 string, result2 string, result3 error) {
	fake.currentBranchNameMutex.Lock()
	defer fake.currentBranchNameMutex.Unlock()
	fake.CurrentBranchNameStub = nil
	fake.currentBranchNameReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIGit) CurrentBranchNameReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.currentBranchNameMutex.Lock()
	defer fake.currentBranchNameMutex.Unlock()
	fake.CurrentBranchNameStub = nil
	if fake.currentBranchNameReturnsOnCall == nil {
		fake.currentBranchNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.currentBranchNameReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIGit) DeleteBranch(arg1 string, arg2 bool) error {
	fake.deleteBranchMutex.Lock()
	ret, specificReturn := fake.deleteBranchReturnsOnCall[len(fake.deleteBranchArgsForCall)]
	fake.deleteBranchArgsForCall = append(fake.deleteBranchArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	stub := fake.DeleteBranchStub
	fakeReturns := fake.deleteBranchReturns
	fake.recordInvocation("DeleteBranch", []interface{}{arg1, arg2})
	fake.deleteBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DeleteBranchCallCount() int {
	fake.deleteBranchMutex.RLock()
	defer fake.deleteBranchMutex.RUnlock()
	return len(fake.deleteBranchArgsForCall)
}

func (fake *FakeIGit) DeleteBranchCalls(stub func(string, bool) error) {
	fake.deleteBranchMutex.Lock()
	defer fake.deleteBranchMutex.Unlock()
	fake.DeleteBranchStub = stub
}

func (fake *FakeIGit) DeleteBranchArgsForCall(i int) (string, bool) {
	fake.deleteBranchMutex.RLock()
	defer fake.deleteBranchMutex.RUnlock()
	argsForCall := fake.deleteBranchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) DeleteBranchReturns(result1 error) {
	fake.deleteBranchMutex.Lock()
	defer fake.deleteBranchMutex.Unlock()
	fake.DeleteBranchStub = nil
	fake.deleteBranchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DeleteBranchReturnsOnCall(i int, result1 error) {
	fake.deleteBranchMutex.Lock()
	defer fake.deleteBranchMutex.Unlock()
	fake.DeleteBranchStub = nil
	if fake.deleteBranchReturnsOnCall == nil {
		fake.deleteBranchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteBranchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DeletePatchesFromCommit(arg1 []*models.Commit, arg2 int, arg3 *patch.PatchManager) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deletePatchesFromCommitMutex.Lock()
	ret, specificReturn := fake.deletePatchesFromCommitReturnsOnCall[len(fake.deletePatchesFromCommitArgsForCall)]
	fake.deletePatchesFromCommitArgsForCall = append(fake.deletePatchesFromCommitArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
	}{arg1Copy, arg2, arg3})
	stub := fake.DeletePatchesFromCommitStub
	fakeReturns := fake.deletePatchesFromCommitReturns
	fake.recordInvocation("DeletePatchesFromCommit", []interface{}{arg1Copy, arg2, arg3})
	fake.deletePatchesFromCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DeletePatchesFromCommitCallCount() int {
	fake.deletePatchesFromCommitMutex.RLock()
	defer fake.deletePatchesFromCommitMutex.RUnlock()
	return len(fake.deletePatchesFromCommitArgsForCall)
}

func (fake *FakeIGit) DeletePatchesFromCommitCalls(stub func([]*models.Commit, int, *patch.PatchManager) error) {
	fake.deletePatchesFromCommitMutex.Lock()
	defer fake.deletePatchesFromCommitMutex.Unlock()
	fake.DeletePatchesFromCommitStub = stub
}

func (fake *FakeIGit) DeletePatchesFromCommitArgsForCall(i int) ([]*models.Commit, int, *patch.PatchManager) {
	fake.deletePatchesFromCommitMutex.RLock()
	defer fake.deletePatchesFromCommitMutex.RUnlock()
	argsForCall := fake.deletePatchesFromCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) DeletePatchesFromCommitReturns(result1 error) {
	fake.deletePatchesFromCommitMutex.Lock()
	defer fake.deletePatchesFromCommitMutex.Unlock()
	fake.DeletePatchesFromCommitStub = nil
	fake.deletePatchesFromCommitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DeletePatchesFromCommitReturnsOnCall(i int, result1 error) {
	fake.deletePatchesFromCommitMutex.Lock()
	defer fake.deletePatchesFromCommitMutex.Unlock()
	fake.DeletePatchesFromCommitStub = nil
	if fake.deletePatchesFromCommitReturnsOnCall == nil {
		fake.deletePatchesFromCommitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deletePatchesFromCommitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DeleteRemoteBranch(arg1 string, arg2 string) error {
	fake.deleteRemoteBranchMutex.Lock()
	ret, specificReturn := fake.deleteRemoteBranchReturnsOnCall[len(fake.deleteRemoteBranchArgsForCall)]
	fake.deleteRemoteBranchArgsForCall = append(fake.deleteRemoteBranchArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteRemoteBranchStub
	fakeReturns := fake.deleteRemoteBranchReturns
	fake.recordInvocation("DeleteRemoteBranch", []interface{}{arg1, arg2})
	fake.deleteRemoteBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DeleteRemoteBranchCallCount() int {
	fake.deleteRemoteBranchMutex.RLock()
	defer fake.deleteRemoteBranchMutex.RUnlock()
	return len(fake.deleteRemoteBranchArgsForCall)
}

func (fake *FakeIGit) DeleteRemoteBranchCalls(stub func(string, string) error) {
	fake.deleteRemoteBranchMutex.Lock()
	defer fake.deleteRemoteBranchMutex.Unlock()
	fake.DeleteRemoteBranchStub = stub
}

func (fake *FakeIGit) DeleteRemoteBranchArgsForCall(i int) (string, string) {
	fake.deleteRemoteBranchMutex.RLock()
	defer fake.deleteRemoteBranchMutex.RUnlock()
	argsForCall := fake.deleteRemoteBranchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) DeleteRemoteBranchReturns(result1 error) {
	fake.deleteRemoteBranchMutex.Lock()
	defer fake.deleteRemoteBranchMutex.Unlock()
	fake.DeleteRemoteBranchStub = nil
	fake.deleteRemoteBranchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DeleteRemoteBranchReturnsOnCall(i int, result1 error) {
	fake.deleteRemoteBranchMutex.Lock()
	defer fake.deleteRemoteBranchMutex.Unlock()
	fake.DeleteRemoteBranchStub = nil
	if fake.deleteRemoteBranchReturnsOnCall == nil {
		fake.deleteRemoteBranchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRemoteBranchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DeleteTag(arg1 string) error {
	fake.deleteTagMutex.Lock()
	ret, specificReturn := fake.deleteTagReturnsOnCall[len(fake.deleteTagArgsForCall)]
	fake.deleteTagArgsForCall = append(fake.deleteTagArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteTagStub
	fakeReturns := fake.deleteTagReturns
	fake.recordInvocation("DeleteTag", []interface{}{arg1})
	fake.deleteTagMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DeleteTagCallCount() int {
	fake.deleteTagMutex.RLock()
	defer fake.deleteTagMutex.RUnlock()
	return len(fake.deleteTagArgsForCall)
}

func (fake *FakeIGit) DeleteTagCalls(stub func(string) error) {
	fake.deleteTagMutex.Lock()
	defer fake.deleteTagMutex.Unlock()
	fake.DeleteTagStub = stub
}

func (fake *FakeIGit) DeleteTagArgsForCall(i int) string {
	fake.deleteTagMutex.RLock()
	defer fake.deleteTagMutex.RUnlock()
	argsForCall := fake.deleteTagArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) DeleteTagReturns(result1 error) {
	fake.deleteTagMutex.Lock()
	defer fake.deleteTagMutex.Unlock()
	fake.DeleteTagStub = nil
	fake.deleteTagReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DeleteTagReturnsOnCall(i int, result1 error) {
	fake.deleteTagMutex.Lock()
	defer fake.deleteTagMutex.Unlock()
	fake.DeleteTagStub = nil
	if fake.deleteTagReturnsOnCall == nil {
		fake.deleteTagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiffEndArgs(arg1 string, arg2 string, arg3 bool, arg4 string) string {
	fake.diffEndArgsMutex.Lock()
	ret, specificReturn := fake.diffEndArgsReturnsOnCall[len(fake.diffEndArgsArgsForCall)]
	fake.diffEndArgsArgsForCall = append(fake.diffEndArgsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.DiffEndArgsStub
	fakeReturns := fake.diffEndArgsReturns
	fake.recordInvocation("DiffEndArgs", []interface{}{arg1, arg2, arg3, arg4})
	fake.diffEndArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DiffEndArgsCallCount() int {
	fake.diffEndArgsMutex.RLock()
	defer fake.diffEndArgsMutex.RUnlock()
	return len(fake.diffEndArgsArgsForCall)
}

func (fake *FakeIGit) DiffEndArgsCalls(stub func(string, string, bool, string) string) {
	fake.diffEndArgsMutex.Lock()
	defer fake.diffEndArgsMutex.Unlock()
	fake.DiffEndArgsStub = stub
}

func (fake *FakeIGit) DiffEndArgsArgsForCall(i int) (string, string, bool, string) {
	fake.diffEndArgsMutex.RLock()
	defer fake.diffEndArgsMutex.RUnlock()
	argsForCall := fake.diffEndArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIGit) DiffEndArgsReturns(result1 string) {
	fake.diffEndArgsMutex.Lock()
	defer fake.diffEndArgsMutex.Unlock()
	fake.DiffEndArgsStub = nil
	fake.diffEndArgsReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) DiffEndArgsReturnsOnCall(i int, result1 string) {
	fake.diffEndArgsMutex.Lock()
	defer fake.diffEndArgsMutex.Unlock()
	fake.DiffEndArgsStub = nil
	if fake.diffEndArgsReturnsOnCall == nil {
		fake.diffEndArgsReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.diffEndArgsReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) DiscardAllDirChanges(arg1 *filetree.FileNode) error {
	fake.discardAllDirChangesMutex.Lock()
	ret, specificReturn := fake.discardAllDirChangesReturnsOnCall[len(fake.discardAllDirChangesArgsForCall)]
	fake.discardAllDirChangesArgsForCall = append(fake.discardAllDirChangesArgsForCall, struct {
		arg1 *filetree.FileNode
	}{arg1})
	stub := fake.DiscardAllDirChangesStub
	fakeReturns := fake.discardAllDirChangesReturns
	fake.recordInvocation("DiscardAllDirChanges", []interface{}{arg1})
	fake.discardAllDirChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DiscardAllDirChangesCallCount() int {
	fake.discardAllDirChangesMutex.RLock()
	defer fake.discardAllDirChangesMutex.RUnlock()
	return len(fake.discardAllDirChangesArgsForCall)
}

func (fake *FakeIGit) DiscardAllDirChangesCalls(stub func(*filetree.FileNode) error) {
	fake.discardAllDirChangesMutex.Lock()
	defer fake.discardAllDirChangesMutex.Unlock()
	fake.DiscardAllDirChangesStub = stub
}

func (fake *FakeIGit) DiscardAllDirChangesArgsForCall(i int) *filetree.FileNode {
	fake.discardAllDirChangesMutex.RLock()
	defer fake.discardAllDirChangesMutex.RUnlock()
	argsForCall := fake.discardAllDirChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) DiscardAllDirChangesReturns(result1 error) {
	fake.discardAllDirChangesMutex.Lock()
	defer fake.discardAllDirChangesMutex.Unlock()
	fake.DiscardAllDirChangesStub = nil
	fake.discardAllDirChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiscardAllDirChangesReturnsOnCall(i int, result1 error) {
	fake.discardAllDirChangesMutex.Lock()
	defer fake.discardAllDirChangesMutex.Unlock()
	fake.DiscardAllDirChangesStub = nil
	if fake.discardAllDirChangesReturnsOnCall == nil {
		fake.discardAllDirChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardAllDirChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiscardAllFileChanges(arg1 *models.File) error {
	fake.discardAllFileChangesMutex.Lock()
	ret, specificReturn := fake.discardAllFileChangesReturnsOnCall[len(fake.discardAllFileChangesArgsForCall)]
	fake.discardAllFileChangesArgsForCall = append(fake.discardAllFileChangesArgsForCall, struct {
		arg1 *models.File
	}{arg1})
	stub := fake.DiscardAllFileChangesStub
	fakeReturns := fake.discardAllFileChangesReturns
	fake.recordInvocation("DiscardAllFileChanges", []interface{}{arg1})
	fake.discardAllFileChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DiscardAllFileChangesCallCount() int {
	fake.discardAllFileChangesMutex.RLock()
	defer fake.discardAllFileChangesMutex.RUnlock()
	return len(fake.discardAllFileChangesArgsForCall)
}

func (fake *FakeIGit) DiscardAllFileChangesCalls(stub func(*models.File) error) {
	fake.discardAllFileChangesMutex.Lock()
	defer fake.discardAllFileChangesMutex.Unlock()
	fake.DiscardAllFileChangesStub = stub
}

func (fake *FakeIGit) DiscardAllFileChangesArgsForCall(i int) *models.File {
	fake.discardAllFileChangesMutex.RLock()
	defer fake.discardAllFileChangesMutex.RUnlock()
	argsForCall := fake.discardAllFileChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) DiscardAllFileChangesReturns(result1 error) {
	fake.discardAllFileChangesMutex.Lock()
	defer fake.discardAllFileChangesMutex.Unlock()
	fake.DiscardAllFileChangesStub = nil
	fake.discardAllFileChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiscardAllFileChangesReturnsOnCall(i int, result1 error) {
	fake.discardAllFileChangesMutex.Lock()
	defer fake.discardAllFileChangesMutex.Unlock()
	fake.DiscardAllFileChangesStub = nil
	if fake.discardAllFileChangesReturnsOnCall == nil {
		fake.discardAllFileChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardAllFileChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiscardAnyUnstagedFileChanges() error {
	fake.discardAnyUnstagedFileChangesMutex.Lock()
	ret, specificReturn := fake.discardAnyUnstagedFileChangesReturnsOnCall[len(fake.discardAnyUnstagedFileChangesArgsForCall)]
	fake.discardAnyUnstagedFileChangesArgsForCall = append(fake.discardAnyUnstagedFileChangesArgsForCall, struct {
	}{})
	stub := fake.DiscardAnyUnstagedFileChangesStub
	fakeReturns := fake.discardAnyUnstagedFileChangesReturns
	fake.recordInvocation("DiscardAnyUnstagedFileChanges", []interface{}{})
	fake.discardAnyUnstagedFileChangesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DiscardAnyUnstagedFileChangesCallCount() int {
	fake.discardAnyUnstagedFileChangesMutex.RLock()
	defer fake.discardAnyUnstagedFileChangesMutex.RUnlock()
	return len(fake.discardAnyUnstagedFileChangesArgsForCall)
}

func (fake *FakeIGit) DiscardAnyUnstagedFileChangesCalls(stub func() error) {
	fake.discardAnyUnstagedFileChangesMutex.Lock()
	defer fake.discardAnyUnstagedFileChangesMutex.Unlock()
	fake.DiscardAnyUnstagedFileChangesStub = stub
}

func (fake *FakeIGit) DiscardAnyUnstagedFileChangesReturns(result1 error) {
	fake.discardAnyUnstagedFileChangesMutex.Lock()
	defer fake.discardAnyUnstagedFileChangesMutex.Unlock()
	fake.DiscardAnyUnstagedFileChangesStub = nil
	fake.discardAnyUnstagedFileChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiscardAnyUnstagedFileChangesReturnsOnCall(i int, result1 error) {
	fake.discardAnyUnstagedFileChangesMutex.Lock()
	defer fake.discardAnyUnstagedFileChangesMutex.Unlock()
	fake.DiscardAnyUnstagedFileChangesStub = nil
	if fake.discardAnyUnstagedFileChangesReturnsOnCall == nil {
		fake.discardAnyUnstagedFileChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardAnyUnstagedFileChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiscardOldFileChanges(arg1 []*models.Commit, arg2 int, arg3 string) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.discardOldFileChangesMutex.Lock()
	ret, specificReturn := fake.discardOldFileChangesReturnsOnCall[len(fake.discardOldFileChangesArgsForCall)]
	fake.discardOldFileChangesArgsForCall = append(fake.discardOldFileChangesArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}{arg1Copy, arg2, arg3})
	stub := fake.DiscardOldFileChangesStub
	fakeReturns := fake.discardOldFileChangesReturns
	fake.recordInvocation("DiscardOldFileChanges", []interface{}{arg1Copy, arg2, arg3})
	fake.discardOldFileChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DiscardOldFileChangesCallCount() int {
	fake.discardOldFileChangesMutex.RLock()
	defer fake.discardOldFileChangesMutex.RUnlock()
	return len(fake.discardOldFileChangesArgsForCall)
}

func (fake *FakeIGit) DiscardOldFileChangesCalls(stub func([]*models.Commit, int, string) error) {
	fake.discardOldFileChangesMutex.Lock()
	defer fake.discardOldFileChangesMutex.Unlock()
	fake.DiscardOldFileChangesStub = stub
}

func (fake *FakeIGit) DiscardOldFileChangesArgsForCall(i int) ([]*models.Commit, int, string) {
	fake.discardOldFileChangesMutex.RLock()
	defer fake.discardOldFileChangesMutex.RUnlock()
	argsForCall := fake.discardOldFileChangesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) DiscardOldFileChangesReturns(result1 error) {
	fake.discardOldFileChangesMutex.Lock()
	defer fake.discardOldFileChangesMutex.Unlock()
	fake.DiscardOldFileChangesStub = nil
	fake.discardOldFileChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiscardOldFileChangesReturnsOnCall(i int, result1 error) {
	fake.discardOldFileChangesMutex.Lock()
	defer fake.discardOldFileChangesMutex.Unlock()
	fake.DiscardOldFileChangesStub = nil
	if fake.discardOldFileChangesReturnsOnCall == nil {
		fake.discardOldFileChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardOldFileChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiscardUnstagedDirChanges(arg1 *filetree.FileNode) error {
	fake.discardUnstagedDirChangesMutex.Lock()
	ret, specificReturn := fake.discardUnstagedDirChangesReturnsOnCall[len(fake.discardUnstagedDirChangesArgsForCall)]
	fake.discardUnstagedDirChangesArgsForCall = append(fake.discardUnstagedDirChangesArgsForCall, struct {
		arg1 *filetree.FileNode
	}{arg1})
	stub := fake.DiscardUnstagedDirChangesStub
	fakeReturns := fake.discardUnstagedDirChangesReturns
	fake.recordInvocation("DiscardUnstagedDirChanges", []interface{}{arg1})
	fake.discardUnstagedDirChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DiscardUnstagedDirChangesCallCount() int {
	fake.discardUnstagedDirChangesMutex.RLock()
	defer fake.discardUnstagedDirChangesMutex.RUnlock()
	return len(fake.discardUnstagedDirChangesArgsForCall)
}

func (fake *FakeIGit) DiscardUnstagedDirChangesCalls(stub func(*filetree.FileNode) error) {
	fake.discardUnstagedDirChangesMutex.Lock()
	defer fake.discardUnstagedDirChangesMutex.Unlock()
	fake.DiscardUnstagedDirChangesStub = stub
}

func (fake *FakeIGit) DiscardUnstagedDirChangesArgsForCall(i int) *filetree.FileNode {
	fake.discardUnstagedDirChangesMutex.RLock()
	defer fake.discardUnstagedDirChangesMutex.RUnlock()
	argsForCall := fake.discardUnstagedDirChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) DiscardUnstagedDirChangesReturns(result1 error) {
	fake.discardUnstagedDirChangesMutex.Lock()
	defer fake.discardUnstagedDirChangesMutex.Unlock()
	fake.DiscardUnstagedDirChangesStub = nil
	fake.discardUnstagedDirChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiscardUnstagedDirChangesReturnsOnCall(i int, result1 error) {
	fake.discardUnstagedDirChangesMutex.Lock()
	defer fake.discardUnstagedDirChangesMutex.Unlock()
	fake.DiscardUnstagedDirChangesStub = nil
	if fake.discardUnstagedDirChangesReturnsOnCall == nil {
		fake.discardUnstagedDirChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardUnstagedDirChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiscardUnstagedFileChanges(arg1 *models.File) error {
	fake.discardUnstagedFileChangesMutex.Lock()
	ret, specificReturn := fake.discardUnstagedFileChangesReturnsOnCall[len(fake.discardUnstagedFileChangesArgsForCall)]
	fake.discardUnstagedFileChangesArgsForCall = append(fake.discardUnstagedFileChangesArgsForCall, struct {
		arg1 *models.File
	}{arg1})
	stub := fake.DiscardUnstagedFileChangesStub
	fakeReturns := fake.discardUnstagedFileChangesReturns
	fake.recordInvocation("DiscardUnstagedFileChanges", []interface{}{arg1})
	fake.discardUnstagedFileChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DiscardUnstagedFileChangesCallCount() int {
	fake.discardUnstagedFileChangesMutex.RLock()
	defer fake.discardUnstagedFileChangesMutex.RUnlock()
	return len(fake.discardUnstagedFileChangesArgsForCall)
}

func (fake *FakeIGit) DiscardUnstagedFileChangesCalls(stub func(*models.File) error) {
	fake.discardUnstagedFileChangesMutex.Lock()
	defer fake.discardUnstagedFileChangesMutex.Unlock()
	fake.DiscardUnstagedFileChangesStub = stub
}

func (fake *FakeIGit) DiscardUnstagedFileChangesArgsForCall(i int) *models.File {
	fake.discardUnstagedFileChangesMutex.RLock()
	defer fake.discardUnstagedFileChangesMutex.RUnlock()
	argsForCall := fake.discardUnstagedFileChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) DiscardUnstagedFileChangesReturns(result1 error) {
	fake.discardUnstagedFileChangesMutex.Lock()
	defer fake.discardUnstagedFileChangesMutex.Unlock()
	fake.DiscardUnstagedFileChangesStub = nil
	fake.discardUnstagedFileChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) DiscardUnstagedFileChangesReturnsOnCall(i int, result1 error) {
	fake.discardUnstagedFileChangesMutex.Lock()
	defer fake.discardUnstagedFileChangesMutex.Unlock()
	fake.DiscardUnstagedFileChangesStub = nil
	if fake.discardUnstagedFileChangesReturnsOnCall == nil {
		fake.discardUnstagedFileChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardUnstagedFileChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) EditFileCmdObj(arg1 string) (types.ICmdObj, error) {
	fake.editFileCmdObjMutex.Lock()
	ret, specificReturn := fake.editFileCmdObjReturnsOnCall[len(fake.editFileCmdObjArgsForCall)]
	fake.editFileCmdObjArgsForCall = append(fake.editFileCmdObjArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.EditFileCmdObjStub
	fakeReturns := fake.editFileCmdObjReturns
	fake.recordInvocation("EditFileCmdObj", []interface{}{arg1})
	fake.editFileCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) EditFileCmdObjCallCount() int {
	fake.editFileCmdObjMutex.RLock()
	defer fake.editFileCmdObjMutex.RUnlock()
	return len(fake.editFileCmdObjArgsForCall)
}

func (fake *FakeIGit) EditFileCmdObjCalls(stub func(string) (types.ICmdObj, error)) {
	fake.editFileCmdObjMutex.Lock()
	defer fake.editFileCmdObjMutex.Unlock()
	fake.EditFileCmdObjStub = stub
}

func (fake *FakeIGit) EditFileCmdObjArgsForCall(i int) string {
	fake.editFileCmdObjMutex.RLock()
	defer fake.editFileCmdObjMutex.RUnlock()
	argsForCall := fake.editFileCmdObjArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) EditFileCmdObjReturns(result1 types.ICmdObj, result2 error) {
	fake.editFileCmdObjMutex.Lock()
	defer fake.editFileCmdObjMutex.Unlock()
	fake.EditFileCmdObjStub = nil
	fake.editFileCmdObjReturns = struct {
		result1 types.ICmdObj
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) EditFileCmdObjReturnsOnCall(i int, result1 types.ICmdObj, result2 error) {
	fake.editFileCmdObjMutex.Lock()
	defer fake.editFileCmdObjMutex.Unlock()
	fake.EditFileCmdObjStub = nil
	if fake.editFileCmdObjReturnsOnCall == nil {
		fake.editFileCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
			result2 error
		})
	}
	fake.editFileCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) EditRebaseTodo(arg1 int, arg2 string) error {
	fake.editRebaseTodoMutex.Lock()
	ret, specificReturn := fake.editRebaseTodoReturnsOnCall[len(fake.editRebaseTodoArgsForCall)]
	fake.editRebaseTodoArgsForCall = append(fake.editRebaseTodoArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.EditRebaseTodoStub
	fakeReturns := fake.editRebaseTodoReturns
	fake.recordInvocation("EditRebaseTodo", []interface{}{arg1, arg2})
	fake.editRebaseTodoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) EditRebaseTodoCallCount() int {
	fake.editRebaseTodoMutex.RLock()
	defer fake.editRebaseTodoMutex.RUnlock()
	return len(fake.editRebaseTodoArgsForCall)
}

func (fake *FakeIGit) EditRebaseTodoCalls(stub func(int, string) error) {
	fake.editRebaseTodoMutex.Lock()
	defer fake.editRebaseTodoMutex.Unlock()
	fake.EditRebaseTodoStub = stub
}

func (fake *FakeIGit) EditRebaseTodoArgsForCall(i int) (int, string) {
	fake.editRebaseTodoMutex.RLock()
	defer fake.editRebaseTodoMutex.RUnlock()
	argsForCall := fake.editRebaseTodoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) EditRebaseTodoReturns(result1 error) {
	fake.editRebaseTodoMutex.Lock()
	defer fake.editRebaseTodoMutex.Unlock()
	fake.EditRebaseTodoStub = nil
	fake.editRebaseTodoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) EditRebaseTodoReturnsOnCall(i int, result1 error) {
	fake.editRebaseTodoMutex.Lock()
	defer fake.editRebaseTodoMutex.Unlock()
	fake.EditRebaseTodoStub = nil
	if fake.editRebaseTodoReturnsOnCall == nil {
		fake.editRebaseTodoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editRebaseTodoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) FastForward(arg1 string, arg2 string, arg3 string) error {
	fake.fastForwardMutex.Lock()
	ret, specificReturn := fake.fastForwardReturnsOnCall[len(fake.fastForwardArgsForCall)]
	fake.fastForwardArgsForCall = append(fake.fastForwardArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FastForwardStub
	fakeReturns := fake.fastForwardReturns
	fake.recordInvocation("FastForward", []interface{}{arg1, arg2, arg3})
	fake.fastForwardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) FastForwardCallCount() int {
	fake.fastForwardMutex.RLock()
	defer fake.fastForwardMutex.RUnlock()
	return len(fake.fastForwardArgsForCall)
}

func (fake *FakeIGit) FastForwardCalls(stub func(string, string, string) error) {
	fake.fastForwardMutex.Lock()
	defer fake.fastForwardMutex.Unlock()
	fake.FastForwardStub = stub
}

func (fake *FakeIGit) FastForwardArgsForCall(i int) (string, string, string) {
	fake.fastForwardMutex.RLock()
	defer fake.fastForwardMutex.RUnlock()
	argsForCall := fake.fastForwardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) FastForwardReturns(result1 error) {
	fake.fastForwardMutex.Lock()
	defer fake.fastForwardMutex.Unlock()
	fake.FastForwardStub = nil
	fake.fastForwardReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) FastForwardReturnsOnCall(i int, result1 error) {
	fake.fastForwardMutex.Lock()
	defer fake.fastForwardMutex.Unlock()
	fake.FastForwardStub = nil
	if fake.fastForwardReturnsOnCall == nil {
		fake.fastForwardReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fastForwardReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) Fetch(arg1 commands.FetchOptions) error {
	fake.fetchMutex.Lock()
	ret, specificReturn := fake.fetchReturnsOnCall[len(fake.fetchArgsForCall)]
	fake.fetchArgsForCall = append(fake.fetchArgsForCall, struct {
		arg1 commands.FetchOptions
	}{arg1})
	stub := fake.FetchStub
	fakeReturns := fake.fetchReturns
	fake.recordInvocation("Fetch", []interface{}{arg1})
	fake.fetchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) FetchCallCount() int {
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	return len(fake.fetchArgsForCall)
}

func (fake *FakeIGit) FetchCalls(stub func(commands.FetchOptions) error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = stub
}

func (fake *FakeIGit) FetchArgsForCall(i int) commands.FetchOptions {
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	argsForCall := fake.fetchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) FetchReturns(result1 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	fake.fetchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) FetchReturnsOnCall(i int, result1 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	if fake.fetchReturnsOnCall == nil {
		fake.fetchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fetchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) FetchInBackground(arg1 commands.FetchOptions) error {
	fake.fetchInBackgroundMutex.Lock()
	ret, specificReturn := fake.fetchInBackgroundReturnsOnCall[len(fake.fetchInBackgroundArgsForCall)]
	fake.fetchInBackgroundArgsForCall = append(fake.fetchInBackgroundArgsForCall, struct {
		arg1 commands.FetchOptions
	}{arg1})
	stub := fake.FetchInBackgroundStub
	fakeReturns := fake.fetchInBackgroundReturns
	fake.recordInvocation("FetchInBackground", []interface{}{arg1})
	fake.fetchInBackgroundMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) FetchInBackgroundCallCount() int {
	fake.fetchInBackgroundMutex.RLock()
	defer fake.fetchInBackgroundMutex.RUnlock()
	return len(fake.fetchInBackgroundArgsForCall)
}

func (fake *FakeIGit) FetchInBackgroundCalls(stub func(commands.FetchOptions) error) {
	fake.fetchInBackgroundMutex.Lock()
	defer fake.fetchInBackgroundMutex.Unlock()
	fake.FetchInBackgroundStub = stub
}

func (fake *FakeIGit) FetchInBackgroundArgsForCall(i int) commands.FetchOptions {
	fake.fetchInBackgroundMutex.RLock()
	defer fake.fetchInBackgroundMutex.RUnlock()
	argsForCall := fake.fetchInBackgroundArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) FetchInBackgroundReturns(result1 error) {
	fake.fetchInBackgroundMutex.Lock()
	defer fake.fetchInBackgroundMutex.Unlock()
	fake.FetchInBackgroundStub = nil
	fake.fetchInBackgroundReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) FetchInBackgroundReturnsOnCall(i int, result1 error) {
	fake.fetchInBackgroundMutex.Lock()
	defer fake.fetchInBackgroundMutex.Unlock()
	fake.FetchInBackgroundStub = nil
	if fake.fetchInBackgroundReturnsOnCall == nil {
		fake.fetchInBackgroundReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fetchInBackgroundReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) FetchRemote(arg1 string) error {
	fake.fetchRemoteMutex.Lock()
	ret, specificReturn := fake.fetchRemoteReturnsOnCall[len(fake.fetchRemoteArgsForCall)]
	fake.fetchRemoteArgsForCall = append(fake.fetchRemoteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FetchRemoteStub
	fakeReturns := fake.fetchRemoteReturns
	fake.recordInvocation("FetchRemote", []interface{}{arg1})
	fake.fetchRemoteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) FetchRemoteCallCount() int {
	fake.fetchRemoteMutex.RLock()
	defer fake.fetchRemoteMutex.RUnlock()
	return len(fake.fetchRemoteArgsForCall)
}

func (fake *FakeIGit) FetchRemoteCalls(stub func(string) error) {
	fake.fetchRemoteMutex.Lock()
	defer fake.fetchRemoteMutex.Unlock()
	fake.FetchRemoteStub = stub
}

func (fake *FakeIGit) FetchRemoteArgsForCall(i int) string {
	fake.fetchRemoteMutex.RLock()
	defer fake.fetchRemoteMutex.RUnlock()
	argsForCall := fake.fetchRemoteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) FetchRemoteReturns(result1 error) {
	fake.fetchRemoteMutex.Lock()
	defer fake.fetchRemoteMutex.Unlock()
	fake.FetchRemoteStub = nil
	fake.fetchRemoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) FetchRemoteReturnsOnCall(i int, result1 error) {
	fake.fetchRemoteMutex.Lock()
	defer fake.fetchRemoteMutex.Unlock()
	fake.FetchRemoteStub = nil
	if fake.fetchRemoteReturnsOnCall == nil {
		fake.fetchRemoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fetchRemoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) FindRemoteForBranchInConfig(arg1 string) (string, error) {
	fake.findRemoteForBranchInConfigMutex.Lock()
	ret, specificReturn := fake.findRemoteForBranchInConfigReturnsOnCall[len(fake.findRemoteForBranchInConfigArgsForCall)]
	fake.findRemoteForBranchInConfigArgsForCall = append(fake.findRemoteForBranchInConfigArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FindRemoteForBranchInConfigStub
	fakeReturns := fake.findRemoteForBranchInConfigReturns
	fake.recordInvocation("FindRemoteForBranchInConfig", []interface{}{arg1})
	fake.findRemoteForBranchInConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) FindRemoteForBranchInConfigCallCount() int {
	fake.findRemoteForBranchInConfigMutex.RLock()
	defer fake.findRemoteForBranchInConfigMutex.RUnlock()
	return len(fake.findRemoteForBranchInConfigArgsForCall)
}

func (fake *FakeIGit) FindRemoteForBranchInConfigCalls(stub func(string) (string, error)) {
	fake.findRemoteForBranchInConfigMutex.Lock()
	defer fake.findRemoteForBranchInConfigMutex.Unlock()
	fake.FindRemoteForBranchInConfigStub = stub
}

func (fake *FakeIGit) FindRemoteForBranchInConfigArgsForCall(i int) string {
	fake.findRemoteForBranchInConfigMutex.RLock()
	defer fake.findRemoteForBranchInConfigMutex.RUnlock()
	argsForCall := fake.findRemoteForBranchInConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) FindRemoteForBranchInConfigReturns(result1 string, result2 error) {
	fake.findRemoteForBranchInConfigMutex.Lock()
	defer fake.findRemoteForBranchInConfigMutex.Unlock()
	fake.FindRemoteForBranchInConfigStub = nil
	fake.findRemoteForBranchInConfigReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) FindRemoteForBranchInConfigReturnsOnCall(i int, result1 string, result2 error) {
	fake.findRemoteForBranchInConfigMutex.Lock()
	defer fake.findRemoteForBranchInConfigMutex.Unlock()
	fake.FindRemoteForBranchInConfigStub = nil
	if fake.findRemoteForBranchInConfigReturnsOnCall == nil {
		fake.findRemoteForBranchInConfigReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findRemoteForBranchInConfigReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) FlowFinish(arg1 string, arg2 string) types.ICmdObj {
	fake.flowFinishMutex.Lock()
	ret, specificReturn := fake.flowFinishReturnsOnCall[len(fake.flowFinishArgsForCall)]
	fake.flowFinishArgsForCall = append(fake.flowFinishArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.FlowFinishStub
	fakeReturns := fake.flowFinishReturns
	fake.recordInvocation("FlowFinish", []interface{}{arg1, arg2})
	fake.flowFinishMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) FlowFinishCallCount() int {
	fake.flowFinishMutex.RLock()
	defer fake.flowFinishMutex.RUnlock()
	return len(fake.flowFinishArgsForCall)
}

func (fake *FakeIGit) FlowFinishCalls(stub func(string, string) types.ICmdObj) {
	fake.flowFinishMutex.Lock()
	defer fake.flowFinishMutex.Unlock()
	fake.FlowFinishStub = stub
}

func (fake *FakeIGit) FlowFinishArgsForCall(i int) (string, string) {
	fake.flowFinishMutex.RLock()
	defer fake.flowFinishMutex.RUnlock()
	argsForCall := fake.flowFinishArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) FlowFinishReturns(result1 types.ICmdObj) {
	fake.flowFinishMutex.Lock()
	defer fake.flowFinishMutex.Unlock()
	fake.FlowFinishStub = nil
	fake.flowFinishReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) FlowFinishReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.flowFinishMutex.Lock()
	defer fake.flowFinishMutex.Unlock()
	fake.FlowFinishStub = nil
	if fake.flowFinishReturnsOnCall == nil {
		fake.flowFinishReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.flowFinishReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) FlowStart(arg1 string, arg2 string) types.ICmdObj {
	fake.flowStartMutex.Lock()
	ret, specificReturn := fake.flowStartReturnsOnCall[len(fake.flowStartArgsForCall)]
	fake.flowStartArgsForCall = append(fake.flowStartArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.FlowStartStub
	fakeReturns := fake.flowStartReturns
	fake.recordInvocation("FlowStart", []interface{}{arg1, arg2})
	fake.flowStartMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) FlowStartCallCount() int {
	fake.flowStartMutex.RLock()
	defer fake.flowStartMutex.RUnlock()
	return len(fake.flowStartArgsForCall)
}

func (fake *FakeIGit) FlowStartCalls(stub func(string, string) types.ICmdObj) {
	fake.flowStartMutex.Lock()
	defer fake.flowStartMutex.Unlock()
	fake.FlowStartStub = stub
}

func (fake *FakeIGit) FlowStartArgsForCall(i int) (string, string) {
	fake.flowStartMutex.RLock()
	defer fake.flowStartMutex.RUnlock()
	argsForCall := fake.flowStartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) FlowStartReturns(result1 types.ICmdObj) {
	fake.flowStartMutex.Lock()
	defer fake.flowStartMutex.Unlock()
	fake.FlowStartStub = nil
	fake.flowStartReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) FlowStartReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.flowStartMutex.Lock()
	defer fake.flowStartMutex.Unlock()
	fake.FlowStartStub = nil
	if fake.flowStartReturnsOnCall == nil {
		fake.flowStartReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.flowStartReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) GenerateGenericRebaseTodo(arg1 []*models.Commit, arg2 int, arg3 string) (string, string, error) {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.generateGenericRebaseTodoMutex.Lock()
	ret, specificReturn := fake.generateGenericRebaseTodoReturnsOnCall[len(fake.generateGenericRebaseTodoArgsForCall)]
	fake.generateGenericRebaseTodoArgsForCall = append(fake.generateGenericRebaseTodoArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}{arg1Copy, arg2, arg3})
	stub := fake.GenerateGenericRebaseTodoStub
	fakeReturns := fake.generateGenericRebaseTodoReturns
	fake.recordInvocation("GenerateGenericRebaseTodo", []interface{}{arg1Copy, arg2, arg3})
	fake.generateGenericRebaseTodoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIGit) GenerateGenericRebaseTodoCallCount() int {
	fake.generateGenericRebaseTodoMutex.RLock()
	defer fake.generateGenericRebaseTodoMutex.RUnlock()
	return len(fake.generateGenericRebaseTodoArgsForCall)
}

func (fake *FakeIGit) GenerateGenericRebaseTodoCalls(stub func([]*models.Commit, int, string) (string, string, error)) {
	fake.generateGenericRebaseTodoMutex.Lock()
	defer fake.generateGenericRebaseTodoMutex.Unlock()
	fake.GenerateGenericRebaseTodoStub = stub
}

func (fake *FakeIGit) GenerateGenericRebaseTodoArgsForCall(i int) ([]*models.Commit, int, string) {
	fake.generateGenericRebaseTodoMutex.RLock()
	defer fake.generateGenericRebaseTodoMutex.RUnlock()
	argsForCall := fake.generateGenericRebaseTodoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) GenerateGenericRebaseTodoReturns(result1 string, result2 string, result3 error) {
	fake.generateGenericRebaseTodoMutex.Lock()
	defer fake.generateGenericRebaseTodoMutex.Unlock()
	fake.GenerateGenericRebaseTodoStub = nil
	fake.generateGenericRebaseTodoReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIGit) GenerateGenericRebaseTodoReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.generateGenericRebaseTodoMutex.Lock()
	defer fake.generateGenericRebaseTodoMutex.Unlock()
	fake.GenerateGenericRebaseTodoStub = nil
	if fake.generateGenericRebaseTodoReturnsOnCall == nil {
		fake.generateGenericRebaseTodoReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.generateGenericRebaseTodoReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIGit) GenericAbortCmdObj() types.ICmdObj {
	fake.genericAbortCmdObjMutex.Lock()
	ret, specificReturn := fake.genericAbortCmdObjReturnsOnCall[len(fake.genericAbortCmdObjArgsForCall)]
	fake.genericAbortCmdObjArgsForCall = append(fake.genericAbortCmdObjArgsForCall, struct {
	}{})
	stub := fake.GenericAbortCmdObjStub
	fakeReturns := fake.genericAbortCmdObjReturns
	fake.recordInvocation("GenericAbortCmdObj", []interface{}{})
	fake.genericAbortCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GenericAbortCmdObjCallCount() int {
	fake.genericAbortCmdObjMutex.RLock()
	defer fake.genericAbortCmdObjMutex.RUnlock()
	return len(fake.genericAbortCmdObjArgsForCall)
}

func (fake *FakeIGit) GenericAbortCmdObjCalls(stub func() types.ICmdObj) {
	fake.genericAbortCmdObjMutex.Lock()
	defer fake.genericAbortCmdObjMutex.Unlock()
	fake.GenericAbortCmdObjStub = stub
}

func (fake *FakeIGit) GenericAbortCmdObjReturns(result1 types.ICmdObj) {
	fake.genericAbortCmdObjMutex.Lock()
	defer fake.genericAbortCmdObjMutex.Unlock()
	fake.GenericAbortCmdObjStub = nil
	fake.genericAbortCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) GenericAbortCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.genericAbortCmdObjMutex.Lock()
	defer fake.genericAbortCmdObjMutex.Unlock()
	fake.GenericAbortCmdObjStub = nil
	if fake.genericAbortCmdObjReturnsOnCall == nil {
		fake.genericAbortCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.genericAbortCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) GenericContinueCmdObj() types.ICmdObj {
	fake.genericContinueCmdObjMutex.Lock()
	ret, specificReturn := fake.genericContinueCmdObjReturnsOnCall[len(fake.genericContinueCmdObjArgsForCall)]
	fake.genericContinueCmdObjArgsForCall = append(fake.genericContinueCmdObjArgsForCall, struct {
	}{})
	stub := fake.GenericContinueCmdObjStub
	fakeReturns := fake.genericContinueCmdObjReturns
	fake.recordInvocation("GenericContinueCmdObj", []interface{}{})
	fake.genericContinueCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GenericContinueCmdObjCallCount() int {
	fake.genericContinueCmdObjMutex.RLock()
	defer fake.genericContinueCmdObjMutex.RUnlock()
	return len(fake.genericContinueCmdObjArgsForCall)
}

func (fake *FakeIGit) GenericContinueCmdObjCalls(stub func() types.ICmdObj) {
	fake.genericContinueCmdObjMutex.Lock()
	defer fake.genericContinueCmdObjMutex.Unlock()
	fake.GenericContinueCmdObjStub = stub
}

func (fake *FakeIGit) GenericContinueCmdObjReturns(result1 types.ICmdObj) {
	fake.genericContinueCmdObjMutex.Lock()
	defer fake.genericContinueCmdObjMutex.Unlock()
	fake.GenericContinueCmdObjStub = nil
	fake.genericContinueCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) GenericContinueCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.genericContinueCmdObjMutex.Lock()
	defer fake.genericContinueCmdObjMutex.Unlock()
	fake.GenericContinueCmdObjStub = nil
	if fake.genericContinueCmdObjReturnsOnCall == nil {
		fake.genericContinueCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.genericContinueCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) GenericMergeOrRebaseAction(arg1 string, arg2 string) error {
	fake.genericMergeOrRebaseActionMutex.Lock()
	ret, specificReturn := fake.genericMergeOrRebaseActionReturnsOnCall[len(fake.genericMergeOrRebaseActionArgsForCall)]
	fake.genericMergeOrRebaseActionArgsForCall = append(fake.genericMergeOrRebaseActionArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GenericMergeOrRebaseActionStub
	fakeReturns := fake.genericMergeOrRebaseActionReturns
	fake.recordInvocation("GenericMergeOrRebaseAction", []interface{}{arg1, arg2})
	fake.genericMergeOrRebaseActionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GenericMergeOrRebaseActionCallCount() int {
	fake.genericMergeOrRebaseActionMutex.RLock()
	defer fake.genericMergeOrRebaseActionMutex.RUnlock()
	return len(fake.genericMergeOrRebaseActionArgsForCall)
}

func (fake *FakeIGit) GenericMergeOrRebaseActionCalls(stub func(string, string) error) {
	fake.genericMergeOrRebaseActionMutex.Lock()
	defer fake.genericMergeOrRebaseActionMutex.Unlock()
	fake.GenericMergeOrRebaseActionStub = stub
}

func (fake *FakeIGit) GenericMergeOrRebaseActionArgsForCall(i int) (string, string) {
	fake.genericMergeOrRebaseActionMutex.RLock()
	defer fake.genericMergeOrRebaseActionMutex.RUnlock()
	argsForCall := fake.genericMergeOrRebaseActionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) GenericMergeOrRebaseActionReturns(result1 error) {
	fake.genericMergeOrRebaseActionMutex.Lock()
	defer fake.genericMergeOrRebaseActionMutex.Unlock()
	fake.GenericMergeOrRebaseActionStub = nil
	fake.genericMergeOrRebaseActionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) GenericMergeOrRebaseActionReturnsOnCall(i int, result1 error) {
	fake.genericMergeOrRebaseActionMutex.Lock()
	defer fake.genericMergeOrRebaseActionMutex.Unlock()
	fake.GenericMergeOrRebaseActionStub = nil
	if fake.genericMergeOrRebaseActionReturnsOnCall == nil {
		fake.genericMergeOrRebaseActionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.genericMergeOrRebaseActionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) GenericMergeOrRebaseCmdObj(arg1 string) types.ICmdObj {
	fake.genericMergeOrRebaseCmdObjMutex.Lock()
	ret, specificReturn := fake.genericMergeOrRebaseCmdObjReturnsOnCall[len(fake.genericMergeOrRebaseCmdObjArgsForCall)]
	fake.genericMergeOrRebaseCmdObjArgsForCall = append(fake.genericMergeOrRebaseCmdObjArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GenericMergeOrRebaseCmdObjStub
	fakeReturns := fake.genericMergeOrRebaseCmdObjReturns
	fake.recordInvocation("GenericMergeOrRebaseCmdObj", []interface{}{arg1})
	fake.genericMergeOrRebaseCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GenericMergeOrRebaseCmdObjCallCount() int {
	fake.genericMergeOrRebaseCmdObjMutex.RLock()
	defer fake.genericMergeOrRebaseCmdObjMutex.RUnlock()
	return len(fake.genericMergeOrRebaseCmdObjArgsForCall)
}

func (fake *FakeIGit) GenericMergeOrRebaseCmdObjCalls(stub func(string) types.ICmdObj) {
	fake.genericMergeOrRebaseCmdObjMutex.Lock()
	defer fake.genericMergeOrRebaseCmdObjMutex.Unlock()
	fake.GenericMergeOrRebaseCmdObjStub = stub
}

func (fake *FakeIGit) GenericMergeOrRebaseCmdObjArgsForCall(i int) string {
	fake.genericMergeOrRebaseCmdObjMutex.RLock()
	defer fake.genericMergeOrRebaseCmdObjMutex.RUnlock()
	argsForCall := fake.genericMergeOrRebaseCmdObjArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) GenericMergeOrRebaseCmdObjReturns(result1 types.ICmdObj) {
	fake.genericMergeOrRebaseCmdObjMutex.Lock()
	defer fake.genericMergeOrRebaseCmdObjMutex.Unlock()
	fake.GenericMergeOrRebaseCmdObjStub = nil
	fake.genericMergeOrRebaseCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) GenericMergeOrRebaseCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.genericMergeOrRebaseCmdObjMutex.Lock()
	defer fake.genericMergeOrRebaseCmdObjMutex.Unlock()
	fake.GenericMergeOrRebaseCmdObjStub = nil
	if fake.genericMergeOrRebaseCmdObjReturnsOnCall == nil {
		fake.genericMergeOrRebaseCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.genericMergeOrRebaseCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) GetBranchGraph(arg1 string) (string, error) {
	fake.getBranchGraphMutex.Lock()
	ret, specificReturn := fake.getBranchGraphReturnsOnCall[len(fake.getBranchGraphArgsForCall)]
	fake.getBranchGraphArgsForCall = append(fake.getBranchGraphArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetBranchGraphStub
	fakeReturns := fake.getBranchGraphReturns
	fake.recordInvocation("GetBranchGraph", []interface{}{arg1})
	fake.getBranchGraphMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) GetBranchGraphCallCount() int {
	fake.getBranchGraphMutex.RLock()
	defer fake.getBranchGraphMutex.RUnlock()
	return len(fake.getBranchGraphArgsForCall)
}

func (fake *FakeIGit) GetBranchGraphCalls(stub func(string) (string, error)) {
	fake.getBranchGraphMutex.Lock()
	defer fake.getBranchGraphMutex.Unlock()
	fake.GetBranchGraphStub = stub
}

func (fake *FakeIGit) GetBranchGraphArgsForCall(i int) string {
	fake.getBranchGraphMutex.RLock()
	defer fake.getBranchGraphMutex.RUnlock()
	argsForCall := fake.getBranchGraphArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) GetBranchGraphReturns(result1 string, result2 error) {
	fake.getBranchGraphMutex.Lock()
	defer fake.getBranchGraphMutex.Unlock()
	fake.GetBranchGraphStub = nil
	fake.getBranchGraphReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetBranchGraphReturnsOnCall(i int, result1 string, result2 error) {
	fake.getBranchGraphMutex.Lock()
	defer fake.getBranchGraphMutex.Unlock()
	fake.GetBranchGraphStub = nil
	if fake.getBranchGraphReturnsOnCall == nil {
		fake.getBranchGraphReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getBranchGraphReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetBranchGraphCmdObj(arg1 string) types.ICmdObj {
	fake.getBranchGraphCmdObjMutex.Lock()
	ret, specificReturn := fake.getBranchGraphCmdObjReturnsOnCall[len(fake.getBranchGraphCmdObjArgsForCall)]
	fake.getBranchGraphCmdObjArgsForCall = append(fake.getBranchGraphCmdObjArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetBranchGraphCmdObjStub
	fakeReturns := fake.getBranchGraphCmdObjReturns
	fake.recordInvocation("GetBranchGraphCmdObj", []interface{}{arg1})
	fake.getBranchGraphCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetBranchGraphCmdObjCallCount() int {
	fake.getBranchGraphCmdObjMutex.RLock()
	defer fake.getBranchGraphCmdObjMutex.RUnlock()
	return len(fake.getBranchGraphCmdObjArgsForCall)
}

func (fake *FakeIGit) GetBranchGraphCmdObjCalls(stub func(string) types.ICmdObj) {
	fake.getBranchGraphCmdObjMutex.Lock()
	defer fake.getBranchGraphCmdObjMutex.Unlock()
	fake.GetBranchGraphCmdObjStub = stub
}

func (fake *FakeIGit) GetBranchGraphCmdObjArgsForCall(i int) string {
	fake.getBranchGraphCmdObjMutex.RLock()
	defer fake.getBranchGraphCmdObjMutex.RUnlock()
	argsForCall := fake.getBranchGraphCmdObjArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) GetBranchGraphCmdObjReturns(result1 types.ICmdObj) {
	fake.getBranchGraphCmdObjMutex.Lock()
	defer fake.getBranchGraphCmdObjMutex.Unlock()
	fake.GetBranchGraphCmdObjStub = nil
	fake.getBranchGraphCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) GetBranchGraphCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.getBranchGraphCmdObjMutex.Lock()
	defer fake.getBranchGraphCmdObjMutex.Unlock()
	fake.GetBranchGraphCmdObjStub = nil
	if fake.getBranchGraphCmdObjReturnsOnCall == nil {
		fake.getBranchGraphCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.getBranchGraphCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) GetBranchUpstreamDifferenceCount(arg1 string) (string, string) {
	fake.getBranchUpstreamDifferenceCountMutex.Lock()
	ret, specificReturn := fake.getBranchUpstreamDifferenceCountReturnsOnCall[len(fake.getBranchUpstreamDifferenceCountArgsForCall)]
	fake.getBranchUpstreamDifferenceCountArgsForCall = append(fake.getBranchUpstreamDifferenceCountArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetBranchUpstreamDifferenceCountStub
	fakeReturns := fake.getBranchUpstreamDifferenceCountReturns
	fake.recordInvocation("GetBranchUpstreamDifferenceCount", []interface{}{arg1})
	fake.getBranchUpstreamDifferenceCountMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) GetBranchUpstreamDifferenceCountCallCount() int {
	fake.getBranchUpstreamDifferenceCountMutex.RLock()
	defer fake.getBranchUpstreamDifferenceCountMutex.RUnlock()
	return len(fake.getBranchUpstreamDifferenceCountArgsForCall)
}

func (fake *FakeIGit) GetBranchUpstreamDifferenceCountCalls(stub func(string) (string, string)) {
	fake.getBranchUpstreamDifferenceCountMutex.Lock()
	defer fake.getBranchUpstreamDifferenceCountMutex.Unlock()
	fake.GetBranchUpstreamDifferenceCountStub = stub
}

func (fake *FakeIGit) GetBranchUpstreamDifferenceCountArgsForCall(i int) string {
	fake.getBranchUpstreamDifferenceCountMutex.RLock()
	defer fake.getBranchUpstreamDifferenceCountMutex.RUnlock()
	argsForCall := fake.getBranchUpstreamDifferenceCountArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) GetBranchUpstreamDifferenceCountReturns(result1 string, result2 string) {
	fake.getBranchUpstreamDifferenceCountMutex.Lock()
	defer fake.getBranchUpstreamDifferenceCountMutex.Unlock()
	fake.GetBranchUpstreamDifferenceCountStub = nil
	fake.getBranchUpstreamDifferenceCountReturns = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeIGit) GetBranchUpstreamDifferenceCountReturnsOnCall(i int, result1 string, result2 string) {
	fake.getBranchUpstreamDifferenceCountMutex.Lock()
	defer fake.getBranchUpstreamDifferenceCountMutex.Unlock()
	fake.GetBranchUpstreamDifferenceCountStub = nil
	if fake.getBranchUpstreamDifferenceCountReturnsOnCall == nil {
		fake.getBranchUpstreamDifferenceCountReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
		})
	}
	fake.getBranchUpstreamDifferenceCountReturnsOnCall[i] = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeIGit) GetCommitDifferences(arg1 string, arg2 string) (string, string) {
	fake.getCommitDifferencesMutex.Lock()
	ret, specificReturn := fake.getCommitDifferencesReturnsOnCall[len(fake.getCommitDifferencesArgsForCall)]
	fake.getCommitDifferencesArgsForCall = append(fake.getCommitDifferencesArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetCommitDifferencesStub
	fakeReturns := fake.getCommitDifferencesReturns
	fake.recordInvocation("GetCommitDifferences", []interface{}{arg1, arg2})
	fake.getCommitDifferencesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) GetCommitDifferencesCallCount() int {
	fake.getCommitDifferencesMutex.RLock()
	defer fake.getCommitDifferencesMutex.RUnlock()
	return len(fake.getCommitDifferencesArgsForCall)
}

func (fake *FakeIGit) GetCommitDifferencesCalls(stub func(string, string) (string, string)) {
	fake.getCommitDifferencesMutex.Lock()
	defer fake.getCommitDifferencesMutex.Unlock()
	fake.GetCommitDifferencesStub = stub
}

func (fake *FakeIGit) GetCommitDifferencesArgsForCall(i int) (string, string) {
	fake.getCommitDifferencesMutex.RLock()
	defer fake.getCommitDifferencesMutex.RUnlock()
	argsForCall := fake.getCommitDifferencesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) GetCommitDifferencesReturns(result1 string, result2 string) {
	fake.getCommitDifferencesMutex.Lock()
	defer fake.getCommitDifferencesMutex.Unlock()
	fake.GetCommitDifferencesStub = nil
	fake.getCommitDifferencesReturns = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeIGit) GetCommitDifferencesReturnsOnCall(i int, result1 string, result2 string) {
	fake.getCommitDifferencesMutex.Lock()
	defer fake.getCommitDifferencesMutex.Unlock()
	fake.GetCommitDifferencesStub = nil
	if fake.getCommitDifferencesReturnsOnCall == nil {
		fake.getCommitDifferencesReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
		})
	}
	fake.getCommitDifferencesReturnsOnCall[i] = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeIGit) GetConfigValue(arg1 string) string {
	fake.getConfigValueMutex.Lock()
	ret, specificReturn := fake.getConfigValueReturnsOnCall[len(fake.getConfigValueArgsForCall)]
	fake.getConfigValueArgsForCall = append(fake.getConfigValueArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetConfigValueStub
	fakeReturns := fake.getConfigValueReturns
	fake.recordInvocation("GetConfigValue", []interface{}{arg1})
	fake.getConfigValueMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetConfigValueCallCount() int {
	fake.getConfigValueMutex.RLock()
	defer fake.getConfigValueMutex.RUnlock()
	return len(fake.getConfigValueArgsForCall)
}

func (fake *FakeIGit) GetConfigValueCalls(stub func(string) string) {
	fake.getConfigValueMutex.Lock()
	defer fake.getConfigValueMutex.Unlock()
	fake.GetConfigValueStub = stub
}

func (fake *FakeIGit) GetConfigValueArgsForCall(i int) string {
	fake.getConfigValueMutex.RLock()
	defer fake.getConfigValueMutex.RUnlock()
	argsForCall := fake.getConfigValueArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) GetConfigValueReturns(result1 string) {
	fake.getConfigValueMutex.Lock()
	defer fake.getConfigValueMutex.Unlock()
	fake.GetConfigValueStub = nil
	fake.getConfigValueReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetConfigValueReturnsOnCall(i int, result1 string) {
	fake.getConfigValueMutex.Lock()
	defer fake.getConfigValueMutex.Unlock()
	fake.GetConfigValueStub = nil
	if fake.getConfigValueReturnsOnCall == nil {
		fake.getConfigValueReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getConfigValueReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetCurrentBranchUpstreamDifferenceCount() (string, string) {
	fake.getCurrentBranchUpstreamDifferenceCountMutex.Lock()
	ret, specificReturn := fake.getCurrentBranchUpstreamDifferenceCountReturnsOnCall[len(fake.getCurrentBranchUpstreamDifferenceCountArgsForCall)]
	fake.getCurrentBranchUpstreamDifferenceCountArgsForCall = append(fake.getCurrentBranchUpstreamDifferenceCountArgsForCall, struct {
	}{})
	stub := fake.GetCurrentBranchUpstreamDifferenceCountStub
	fakeReturns := fake.getCurrentBranchUpstreamDifferenceCountReturns
	fake.recordInvocation("GetCurrentBranchUpstreamDifferenceCount", []interface{}{})
	fake.getCurrentBranchUpstreamDifferenceCountMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) GetCurrentBranchUpstreamDifferenceCountCallCount() int {
	fake.getCurrentBranchUpstreamDifferenceCountMutex.RLock()
	defer fake.getCurrentBranchUpstreamDifferenceCountMutex.RUnlock()
	return len(fake.getCurrentBranchUpstreamDifferenceCountArgsForCall)
}

func (fake *FakeIGit) GetCurrentBranchUpstreamDifferenceCountCalls(stub func() (string, string)) {
	fake.getCurrentBranchUpstreamDifferenceCountMutex.Lock()
	defer fake.getCurrentBranchUpstreamDifferenceCountMutex.Unlock()
	fake.GetCurrentBranchUpstreamDifferenceCountStub = stub
}

func (fake *FakeIGit) GetCurrentBranchUpstreamDifferenceCountReturns(result1 string, result2 string) {
	fake.getCurrentBranchUpstreamDifferenceCountMutex.Lock()
	defer fake.getCurrentBranchUpstreamDifferenceCountMutex.Unlock()
	fake.GetCurrentBranchUpstreamDifferenceCountStub = nil
	fake.getCurrentBranchUpstreamDifferenceCountReturns = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeIGit) GetCurrentBranchUpstreamDifferenceCountReturnsOnCall(i int, result1 string, result2 string) {
	fake.getCurrentBranchUpstreamDifferenceCountMutex.Lock()
	defer fake.getCurrentBranchUpstreamDifferenceCountMutex.Unlock()
	fake.GetCurrentBranchUpstreamDifferenceCountStub = nil
	if fake.getCurrentBranchUpstreamDifferenceCountReturnsOnCall == nil {
		fake.getCurrentBranchUpstreamDifferenceCountReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
		})
	}
	fake.getCurrentBranchUpstreamDifferenceCountReturnsOnCall[i] = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeIGit) GetFilesInDiff(arg1 string, arg2 string, arg3 bool) ([]*models.CommitFile, error) {
	fake.getFilesInDiffMutex.Lock()
	ret, specificReturn := fake.getFilesInDiffReturnsOnCall[len(fake.getFilesInDiffArgsForCall)]
	fake.getFilesInDiffArgsForCall = append(fake.getFilesInDiffArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.GetFilesInDiffStub
	fakeReturns := fake.getFilesInDiffReturns
	fake.recordInvocation("GetFilesInDiff", []interface{}{arg1, arg2, arg3})
	fake.getFilesInDiffMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) GetFilesInDiffCallCount() int {
	fake.getFilesInDiffMutex.RLock()
	defer fake.getFilesInDiffMutex.RUnlock()
	return len(fake.getFilesInDiffArgsForCall)
}

func (fake *FakeIGit) GetFilesInDiffCalls(stub func(string, string, bool) ([]*models.CommitFile, error)) {
	fake.getFilesInDiffMutex.Lock()
	defer fake.getFilesInDiffMutex.Unlock()
	fake.GetFilesInDiffStub = stub
}

func (fake *FakeIGit) GetFilesInDiffArgsForCall(i int) (string, string, bool) {
	fake.getFilesInDiffMutex.RLock()
	defer fake.getFilesInDiffMutex.RUnlock()
	argsForCall := fake.getFilesInDiffArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) GetFilesInDiffReturns(result1 []*models.CommitFile, result2 error) {
	fake.getFilesInDiffMutex.Lock()
	defer fake.getFilesInDiffMutex.Unlock()
	fake.GetFilesInDiffStub = nil
	fake.getFilesInDiffReturns = struct {
		result1 []*models.CommitFile
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetFilesInDiffReturnsOnCall(i int, result1 []*models.CommitFile, result2 error) {
	fake.getFilesInDiffMutex.Lock()
	defer fake.getFilesInDiffMutex.Unlock()
	fake.GetFilesInDiffStub = nil
	if fake.getFilesInDiffReturnsOnCall == nil {
		fake.getFilesInDiffReturnsOnCall = make(map[int]struct {
			result1 []*models.CommitFile
			result2 error
		})
	}
	fake.getFilesInDiffReturnsOnCall[i] = struct {
		result1 []*models.CommitFile
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetGitFlowRegexpConfig() (string, error) {
	fake.getGitFlowRegexpConfigMutex.Lock()
	ret, specificReturn := fake.getGitFlowRegexpConfigReturnsOnCall[len(fake.getGitFlowRegexpConfigArgsForCall)]
	fake.getGitFlowRegexpConfigArgsForCall = append(fake.getGitFlowRegexpConfigArgsForCall, struct {
	}{})
	stub := fake.GetGitFlowRegexpConfigStub
	fakeReturns := fake.getGitFlowRegexpConfigReturns
	fake.recordInvocation("GetGitFlowRegexpConfig", []interface{}{})
	fake.getGitFlowRegexpConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) GetGitFlowRegexpConfigCallCount() int {
	fake.getGitFlowRegexpConfigMutex.RLock()
	defer fake.getGitFlowRegexpConfigMutex.RUnlock()
	return len(fake.getGitFlowRegexpConfigArgsForCall)
}

func (fake *FakeIGit) GetGitFlowRegexpConfigCalls(stub func() (string, error)) {
	fake.getGitFlowRegexpConfigMutex.Lock()
	defer fake.getGitFlowRegexpConfigMutex.Unlock()
	fake.GetGitFlowRegexpConfigStub = stub
}

func (fake *FakeIGit) GetGitFlowRegexpConfigReturns(result1 string, result2 error) {
	fake.getGitFlowRegexpConfigMutex.Lock()
	defer fake.getGitFlowRegexpConfigMutex.Unlock()
	fake.GetGitFlowRegexpConfigStub = nil
	fake.getGitFlowRegexpConfigReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetGitFlowRegexpConfigReturnsOnCall(i int, result1 string, result2 error) {
	fake.getGitFlowRegexpConfigMutex.Lock()
	defer fake.getGitFlowRegexpConfigMutex.Unlock()
	fake.GetGitFlowRegexpConfigStub = nil
	if fake.getGitFlowRegexpConfigReturnsOnCall == nil {
		fake.getGitFlowRegexpConfigReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getGitFlowRegexpConfigReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetLog() *logrus.Entry {
	fake.getLogMutex.Lock()
	ret, specificReturn := fake.getLogReturnsOnCall[len(fake.getLogArgsForCall)]
	fake.getLogArgsForCall = append(fake.getLogArgsForCall, struct {
	}{})
	stub := fake.GetLogStub
	fakeReturns := fake.getLogReturns
	fake.recordInvocation("GetLog", []interface{}{})
	fake.getLogMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetLogCallCount() int {
	fake.getLogMutex.RLock()
	defer fake.getLogMutex.RUnlock()
	return len(fake.getLogArgsForCall)
}

func (fake *FakeIGit) GetLogCalls(stub func() *logrus.Entry) {
	fake.getLogMutex.Lock()
	defer fake.getLogMutex.Unlock()
	fake.GetLogStub = stub
}

func (fake *FakeIGit) GetLogReturns(result1 *logrus.Entry) {
	fake.getLogMutex.Lock()
	defer fake.getLogMutex.Unlock()
	fake.GetLogStub = nil
	fake.getLogReturns = struct {
		result1 *logrus.Entry
	}{result1}
}

func (fake *FakeIGit) GetLogReturnsOnCall(i int, result1 *logrus.Entry) {
	fake.getLogMutex.Lock()
	defer fake.getLogMutex.Unlock()
	fake.GetLogStub = nil
	if fake.getLogReturnsOnCall == nil {
		fake.getLogReturnsOnCall = make(map[int]struct {
			result1 *logrus.Entry
		})
	}
	fake.getLogReturnsOnCall[i] = struct {
		result1 *logrus.Entry
	}{result1}
}

func (fake *FakeIGit) GetOS() *oscommands.OS {
	fake.getOSMutex.Lock()
	ret, specificReturn := fake.getOSReturnsOnCall[len(fake.getOSArgsForCall)]
	fake.getOSArgsForCall = append(fake.getOSArgsForCall, struct {
	}{})
	stub := fake.GetOSStub
	fakeReturns := fake.getOSReturns
	fake.recordInvocation("GetOS", []interface{}{})
	fake.getOSMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetOSCallCount() int {
	fake.getOSMutex.RLock()
	defer fake.getOSMutex.RUnlock()
	return len(fake.getOSArgsForCall)
}

func (fake *FakeIGit) GetOSCalls(stub func() *oscommands.OS) {
	fake.getOSMutex.Lock()
	defer fake.getOSMutex.Unlock()
	fake.GetOSStub = stub
}

func (fake *FakeIGit) GetOSReturns(result1 *oscommands.OS) {
	fake.getOSMutex.Lock()
	defer fake.getOSMutex.Unlock()
	fake.GetOSStub = nil
	fake.getOSReturns = struct {
		result1 *oscommands.OS
	}{result1}
}

func (fake *FakeIGit) GetOSReturnsOnCall(i int, result1 *oscommands.OS) {
	fake.getOSMutex.Lock()
	defer fake.getOSMutex.Unlock()
	fake.GetOSStub = nil
	if fake.getOSReturnsOnCall == nil {
		fake.getOSReturnsOnCall = make(map[int]struct {
			result1 *oscommands.OS
		})
	}
	fake.getOSReturnsOnCall[i] = struct {
		result1 *oscommands.OS
	}{result1}
}

func (fake *FakeIGit) GetPager(arg1 int) string {
	fake.getPagerMutex.Lock()
	ret, specificReturn := fake.getPagerReturnsOnCall[len(fake.getPagerArgsForCall)]
	fake.getPagerArgsForCall = append(fake.getPagerArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetPagerStub
	fakeReturns := fake.getPagerReturns
	fake.recordInvocation("GetPager", []interface{}{arg1})
	fake.getPagerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetPagerCallCount() int {
	fake.getPagerMutex.RLock()
	defer fake.getPagerMutex.RUnlock()
	return len(fake.getPagerArgsForCall)
}

func (fake *FakeIGit) GetPagerCalls(stub func(int) string) {
	fake.getPagerMutex.Lock()
	defer fake.getPagerMutex.Unlock()
	fake.GetPagerStub = stub
}

func (fake *FakeIGit) GetPagerArgsForCall(i int) int {
	fake.getPagerMutex.RLock()
	defer fake.getPagerMutex.RUnlock()
	argsForCall := fake.getPagerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) GetPagerReturns(result1 string) {
	fake.getPagerMutex.Lock()
	defer fake.getPagerMutex.Unlock()
	fake.GetPagerStub = nil
	fake.getPagerReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetPagerReturnsOnCall(i int, result1 string) {
	fake.getPagerMutex.Lock()
	defer fake.getPagerMutex.Unlock()
	fake.GetPagerStub = nil
	if fake.getPagerReturnsOnCall == nil {
		fake.getPagerReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getPagerReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetPushToCurrent() bool {
	fake.getPushToCurrentMutex.Lock()
	ret, specificReturn := fake.getPushToCurrentReturnsOnCall[len(fake.getPushToCurrentArgsForCall)]
	fake.getPushToCurrentArgsForCall = append(fake.getPushToCurrentArgsForCall, struct {
	}{})
	stub := fake.GetPushToCurrentStub
	fakeReturns := fake.getPushToCurrentReturns
	fake.recordInvocation("GetPushToCurrent", []interface{}{})
	fake.getPushToCurrentMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetPushToCurrentCallCount() int {
	fake.getPushToCurrentMutex.RLock()
	defer fake.getPushToCurrentMutex.RUnlock()
	return len(fake.getPushToCurrentArgsForCall)
}

func (fake *FakeIGit) GetPushToCurrentCalls(stub func() bool) {
	fake.getPushToCurrentMutex.Lock()
	defer fake.getPushToCurrentMutex.Unlock()
	fake.GetPushToCurrentStub = stub
}

func (fake *FakeIGit) GetPushToCurrentReturns(result1 bool) {
	fake.getPushToCurrentMutex.Lock()
	defer fake.getPushToCurrentMutex.Unlock()
	fake.GetPushToCurrentStub = nil
	fake.getPushToCurrentReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) GetPushToCurrentReturnsOnCall(i int, result1 bool) {
	fake.getPushToCurrentMutex.Lock()
	defer fake.getPushToCurrentMutex.Unlock()
	fake.GetPushToCurrentStub = nil
	if fake.getPushToCurrentReturnsOnCall == nil {
		fake.getPushToCurrentReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.getPushToCurrentReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) GetReflogCommits(arg1 *models.Commit, arg2 string) ([]*models.Commit, bool, error) {
	fake.getReflogCommitsMutex.Lock()
	ret, specificReturn := fake.getReflogCommitsReturnsOnCall[len(fake.getReflogCommitsArgsForCall)]
	fake.getReflogCommitsArgsForCall = append(fake.getReflogCommitsArgsForCall, struct {
		arg1 *models.Commit
		arg2 string
	}{arg1, arg2})
	stub := fake.GetReflogCommitsStub
	fakeReturns := fake.getReflogCommitsReturns
	fake.recordInvocation("GetReflogCommits", []interface{}{arg1, arg2})
	fake.getReflogCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIGit) GetReflogCommitsCallCount() int {
	fake.getReflogCommitsMutex.RLock()
	defer fake.getReflogCommitsMutex.RUnlock()
	return len(fake.getReflogCommitsArgsForCall)
}

func (fake *FakeIGit) GetReflogCommitsCalls(stub func(*models.Commit, string) ([]*models.Commit, bool, error)) {
	fake.getReflogCommitsMutex.Lock()
	defer fake.getReflogCommitsMutex.Unlock()
	fake.GetReflogCommitsStub = stub
}

func (fake *FakeIGit) GetReflogCommitsArgsForCall(i int) (*models.Commit, string) {
	fake.getReflogCommitsMutex.RLock()
	defer fake.getReflogCommitsMutex.RUnlock()
	argsForCall := fake.getReflogCommitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) GetReflogCommitsReturns(result1 []*models.Commit, result2 bool, result3 error) {
	fake.getReflogCommitsMutex.Lock()
	defer fake.getReflogCommitsMutex.Unlock()
	fake.GetReflogCommitsStub = nil
	fake.getReflogCommitsReturns = struct {
		result1 []*models.Commit
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIGit) GetReflogCommitsReturnsOnCall(i int, result1 []*models.Commit, result2 bool, result3 error) {
	fake.getReflogCommitsMutex.Lock()
	defer fake.getReflogCommitsMutex.Unlock()
	fake.GetReflogCommitsStub = nil
	if fake.getReflogCommitsReturnsOnCall == nil {
		fake.getReflogCommitsReturnsOnCall = make(map[int]struct {
			result1 []*models.Commit
			result2 bool
			result3 error
		})
	}
	fake.getReflogCommitsReturnsOnCall[i] = struct {
		result1 []*models.Commit
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIGit) GetRemoteURL() string {
	fake.getRemoteURLMutex.Lock()
	ret, specificReturn := fake.getRemoteURLReturnsOnCall[len(fake.getRemoteURLArgsForCall)]
	fake.getRemoteURLArgsForCall = append(fake.getRemoteURLArgsForCall, struct {
	}{})
	stub := fake.GetRemoteURLStub
	fakeReturns := fake.getRemoteURLReturns
	fake.recordInvocation("GetRemoteURL", []interface{}{})
	fake.getRemoteURLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetRemoteURLCallCount() int {
	fake.getRemoteURLMutex.RLock()
	defer fake.getRemoteURLMutex.RUnlock()
	return len(fake.getRemoteURLArgsForCall)
}

func (fake *FakeIGit) GetRemoteURLCalls(stub func() string) {
	fake.getRemoteURLMutex.Lock()
	defer fake.getRemoteURLMutex.Unlock()
	fake.GetRemoteURLStub = stub
}

func (fake *FakeIGit) GetRemoteURLReturns(result1 string) {
	fake.getRemoteURLMutex.Lock()
	defer fake.getRemoteURLMutex.Unlock()
	fake.GetRemoteURLStub = nil
	fake.getRemoteURLReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetRemoteURLReturnsOnCall(i int, result1 string) {
	fake.getRemoteURLMutex.Lock()
	defer fake.getRemoteURLMutex.Unlock()
	fake.GetRemoteURLStub = nil
	if fake.getRemoteURLReturnsOnCall == nil {
		fake.getRemoteURLReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getRemoteURLReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetRemotes() ([]*models.Remote, error) {
	fake.getRemotesMutex.Lock()
	ret, specificReturn := fake.getRemotesReturnsOnCall[len(fake.getRemotesArgsForCall)]
	fake.getRemotesArgsForCall = append(fake.getRemotesArgsForCall, struct {
	}{})
	stub := fake.GetRemotesStub
	fakeReturns := fake.getRemotesReturns
	fake.recordInvocation("GetRemotes", []interface{}{})
	fake.getRemotesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) GetRemotesCallCount() int {
	fake.getRemotesMutex.RLock()
	defer fake.getRemotesMutex.RUnlock()
	return len(fake.getRemotesArgsForCall)
}

func (fake *FakeIGit) GetRemotesCalls(stub func() ([]*models.Remote, error)) {
	fake.getRemotesMutex.Lock()
	defer fake.getRemotesMutex.Unlock()
	fake.GetRemotesStub = stub
}

func (fake *FakeIGit) GetRemotesReturns(result1 []*models.Remote, result2 error) {
	fake.getRemotesMutex.Lock()
	defer fake.getRemotesMutex.Unlock()
	fake.GetRemotesStub = nil
	fake.getRemotesReturns = struct {
		result1 []*models.Remote
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetRemotesReturnsOnCall(i int, result1 []*models.Remote, result2 error) {
	fake.getRemotesMutex.Lock()
	defer fake.getRemotesMutex.Unlock()
	fake.GetRemotesStub = nil
	if fake.getRemotesReturnsOnCall == nil {
		fake.getRemotesReturnsOnCall = make(map[int]struct {
			result1 []*models.Remote
			result2 error
		})
	}
	fake.getRemotesReturnsOnCall[i] = struct {
		result1 []*models.Remote
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetRewordCommitCmdObj(arg1 []*models.Commit, arg2 int) (types.ICmdObj, error) {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getRewordCommitCmdObjMutex.Lock()
	ret, specificReturn := fake.getRewordCommitCmdObjReturnsOnCall[len(fake.getRewordCommitCmdObjArgsForCall)]
	fake.getRewordCommitCmdObjArgsForCall = append(fake.getRewordCommitCmdObjArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
	}{arg1Copy, arg2})
	stub := fake.GetRewordCommitCmdObjStub
	fakeReturns := fake.getRewordCommitCmdObjReturns
	fake.recordInvocation("GetRewordCommitCmdObj", []interface{}{arg1Copy, arg2})
	fake.getRewordCommitCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) GetRewordCommitCmdObjCallCount() int {
	fake.getRewordCommitCmdObjMutex.RLock()
	defer fake.getRewordCommitCmdObjMutex.RUnlock()
	return len(fake.getRewordCommitCmdObjArgsForCall)
}

func (fake *FakeIGit) GetRewordCommitCmdObjCalls(stub func([]*models.Commit, int) (types.ICmdObj, error)) {
	fake.getRewordCommitCmdObjMutex.Lock()
	defer fake.getRewordCommitCmdObjMutex.Unlock()
	fake.GetRewordCommitCmdObjStub = stub
}

func (fake *FakeIGit) GetRewordCommitCmdObjArgsForCall(i int) ([]*models.Commit, int) {
	fake.getRewordCommitCmdObjMutex.RLock()
	defer fake.getRewordCommitCmdObjMutex.RUnlock()
	argsForCall := fake.getRewordCommitCmdObjArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) GetRewordCommitCmdObjReturns(result1 types.ICmdObj, result2 error) {
	fake.getRewordCommitCmdObjMutex.Lock()
	defer fake.getRewordCommitCmdObjMutex.Unlock()
	fake.GetRewordCommitCmdObjStub = nil
	fake.getRewordCommitCmdObjReturns = struct {
		result1 types.ICmdObj
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetRewordCommitCmdObjReturnsOnCall(i int, result1 types.ICmdObj, result2 error) {
	fake.getRewordCommitCmdObjMutex.Lock()
	defer fake.getRewordCommitCmdObjMutex.Unlock()
	fake.GetRewordCommitCmdObjStub = nil
	if fake.getRewordCommitCmdObjReturnsOnCall == nil {
		fake.getRewordCommitCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
			result2 error
		})
	}
	fake.getRewordCommitCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetStashEntries(arg1 string) []*models.StashEntry {
	fake.getStashEntriesMutex.Lock()
	ret, specificReturn := fake.getStashEntriesReturnsOnCall[len(fake.getStashEntriesArgsForCall)]
	fake.getStashEntriesArgsForCall = append(fake.getStashEntriesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStashEntriesStub
	fakeReturns := fake.getStashEntriesReturns
	fake.recordInvocation("GetStashEntries", []interface{}{arg1})
	fake.getStashEntriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetStashEntriesCallCount() int {
	fake.getStashEntriesMutex.RLock()
	defer fake.getStashEntriesMutex.RUnlock()
	return len(fake.getStashEntriesArgsForCall)
}

func (fake *FakeIGit) GetStashEntriesCalls(stub func(string) []*models.StashEntry) {
	fake.getStashEntriesMutex.Lock()
	defer fake.getStashEntriesMutex.Unlock()
	fake.GetStashEntriesStub = stub
}

func (fake *FakeIGit) GetStashEntriesArgsForCall(i int) string {
	fake.getStashEntriesMutex.RLock()
	defer fake.getStashEntriesMutex.RUnlock()
	argsForCall := fake.getStashEntriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) GetStashEntriesReturns(result1 []*models.StashEntry) {
	fake.getStashEntriesMutex.Lock()
	defer fake.getStashEntriesMutex.Unlock()
	fake.GetStashEntriesStub = nil
	fake.getStashEntriesReturns = struct {
		result1 []*models.StashEntry
	}{result1}
}

func (fake *FakeIGit) GetStashEntriesReturnsOnCall(i int, result1 []*models.StashEntry) {
	fake.getStashEntriesMutex.Lock()
	defer fake.getStashEntriesMutex.Unlock()
	fake.GetStashEntriesStub = nil
	if fake.getStashEntriesReturnsOnCall == nil {
		fake.getStashEntriesReturnsOnCall = make(map[int]struct {
			result1 []*models.StashEntry
		})
	}
	fake.getStashEntriesReturnsOnCall[i] = struct {
		result1 []*models.StashEntry
	}{result1}
}

func (fake *FakeIGit) GetStatusFiles(arg1 loaders.LoadStatusFilesOpts) []*models.File {
	fake.getStatusFilesMutex.Lock()
	ret, specificReturn := fake.getStatusFilesReturnsOnCall[len(fake.getStatusFilesArgsForCall)]
	fake.getStatusFilesArgsForCall = append(fake.getStatusFilesArgsForCall, struct {
		arg1 loaders.LoadStatusFilesOpts
	}{arg1})
	stub := fake.GetStatusFilesStub
	fakeReturns := fake.getStatusFilesReturns
	fake.recordInvocation("GetStatusFiles", []interface{}{arg1})
	fake.getStatusFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetStatusFilesCallCount() int {
	fake.getStatusFilesMutex.RLock()
	defer fake.getStatusFilesMutex.RUnlock()
	return len(fake.getStatusFilesArgsForCall)
}

func (fake *FakeIGit) GetStatusFilesCalls(stub func(loaders.LoadStatusFilesOpts) []*models.File) {
	fake.getStatusFilesMutex.Lock()
	defer fake.getStatusFilesMutex.Unlock()
	fake.GetStatusFilesStub = stub
}

func (fake *FakeIGit) GetStatusFilesArgsForCall(i int) loaders.LoadStatusFilesOpts {
	fake.getStatusFilesMutex.RLock()
	defer fake.getStatusFilesMutex.RUnlock()
	argsForCall := fake.getStatusFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) GetStatusFilesReturns(result1 []*models.File) {
	fake.getStatusFilesMutex.Lock()
	defer fake.getStatusFilesMutex.Unlock()
	fake.GetStatusFilesStub = nil
	fake.getStatusFilesReturns = struct {
		result1 []*models.File
	}{result1}
}

func (fake *FakeIGit) GetStatusFilesReturnsOnCall(i int, result1 []*models.File) {
	fake.getStatusFilesMutex.Lock()
	defer fake.getStatusFilesMutex.Unlock()
	fake.GetStatusFilesStub = nil
	if fake.getStatusFilesReturnsOnCall == nil {
		fake.getStatusFilesReturnsOnCall = make(map[int]struct {
			result1 []*models.File
		})
	}
	fake.getStatusFilesReturnsOnCall[i] = struct {
		result1 []*models.File
	}{result1}
}

func (fake *FakeIGit) GetSubmoduleConfigs() ([]*models.SubmoduleConfig, error) {
	fake.getSubmoduleConfigsMutex.Lock()
	ret, specificReturn := fake.getSubmoduleConfigsReturnsOnCall[len(fake.getSubmoduleConfigsArgsForCall)]
	fake.getSubmoduleConfigsArgsForCall = append(fake.getSubmoduleConfigsArgsForCall, struct {
	}{})
	stub := fake.GetSubmoduleConfigsStub
	fakeReturns := fake.getSubmoduleConfigsReturns
	fake.recordInvocation("GetSubmoduleConfigs", []interface{}{})
	fake.getSubmoduleConfigsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) GetSubmoduleConfigsCallCount() int {
	fake.getSubmoduleConfigsMutex.RLock()
	defer fake.getSubmoduleConfigsMutex.RUnlock()
	return len(fake.getSubmoduleConfigsArgsForCall)
}

func (fake *FakeIGit) GetSubmoduleConfigsCalls(stub func() ([]*models.SubmoduleConfig, error)) {
	fake.getSubmoduleConfigsMutex.Lock()
	defer fake.getSubmoduleConfigsMutex.Unlock()
	fake.GetSubmoduleConfigsStub = stub
}

func (fake *FakeIGit) GetSubmoduleConfigsReturns(result1 []*models.SubmoduleConfig, result2 error) {
	fake.getSubmoduleConfigsMutex.Lock()
	defer fake.getSubmoduleConfigsMutex.Unlock()
	fake.GetSubmoduleConfigsStub = nil
	fake.getSubmoduleConfigsReturns = struct {
		result1 []*models.SubmoduleConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetSubmoduleConfigsReturnsOnCall(i int, result1 []*models.SubmoduleConfig, result2 error) {
	fake.getSubmoduleConfigsMutex.Lock()
	defer fake.getSubmoduleConfigsMutex.Unlock()
	fake.GetSubmoduleConfigsStub = nil
	if fake.getSubmoduleConfigsReturnsOnCall == nil {
		fake.getSubmoduleConfigsReturnsOnCall = make(map[int]struct {
			result1 []*models.SubmoduleConfig
			result2 error
		})
	}
	fake.getSubmoduleConfigsReturnsOnCall[i] = struct {
		result1 []*models.SubmoduleConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetTags() ([]*models.Tag, error) {
	fake.getTagsMutex.Lock()
	ret, specificReturn := fake.getTagsReturnsOnCall[len(fake.getTagsArgsForCall)]
	fake.getTagsArgsForCall = append(fake.getTagsArgsForCall, struct {
	}{})
	stub := fake.GetTagsStub
	fakeReturns := fake.getTagsReturns
	fake.recordInvocation("GetTags", []interface{}{})
	fake.getTagsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) GetTagsCallCount() int {
	fake.getTagsMutex.RLock()
	defer fake.getTagsMutex.RUnlock()
	return len(fake.getTagsArgsForCall)
}

func (fake *FakeIGit) GetTagsCalls(stub func() ([]*models.Tag, error)) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = stub
}

func (fake *FakeIGit) GetTagsReturns(result1 []*models.Tag, result2 error) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = nil
	fake.getTagsReturns = struct {
		result1 []*models.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetTagsReturnsOnCall(i int, result1 []*models.Tag, result2 error) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = nil
	if fake.getTagsReturnsOnCall == nil {
		fake.getTagsReturnsOnCall = make(map[int]struct {
			result1 []*models.Tag
			result2 error
		})
	}
	fake.getTagsReturnsOnCall[i] = struct {
		result1 []*models.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetUpstreamForBranch(arg1 string) (string, error) {
	fake.getUpstreamForBranchMutex.Lock()
	ret, specificReturn := fake.getUpstreamForBranchReturnsOnCall[len(fake.getUpstreamForBranchArgsForCall)]
	fake.getUpstreamForBranchArgsForCall = append(fake.getUpstreamForBranchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetUpstreamForBranchStub
	fakeReturns := fake.getUpstreamForBranchReturns
	fake.recordInvocation("GetUpstreamForBranch", []interface{}{arg1})
	fake.getUpstreamForBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) GetUpstreamForBranchCallCount() int {
	fake.getUpstreamForBranchMutex.RLock()
	defer fake.getUpstreamForBranchMutex.RUnlock()
	return len(fake.getUpstreamForBranchArgsForCall)
}

func (fake *FakeIGit) GetUpstreamForBranchCalls(stub func(string) (string, error)) {
	fake.getUpstreamForBranchMutex.Lock()
	defer fake.getUpstreamForBranchMutex.Unlock()
	fake.GetUpstreamForBranchStub = stub
}

func (fake *FakeIGit) GetUpstreamForBranchArgsForCall(i int) string {
	fake.getUpstreamForBranchMutex.RLock()
	defer fake.getUpstreamForBranchMutex.RUnlock()
	argsForCall := fake.getUpstreamForBranchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) GetUpstreamForBranchReturns(result1 string, result2 error) {
	fake.getUpstreamForBranchMutex.Lock()
	defer fake.getUpstreamForBranchMutex.Unlock()
	fake.GetUpstreamForBranchStub = nil
	fake.getUpstreamForBranchReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) GetUpstreamForBranchReturnsOnCall(i int, result1 string, result2 error) {
	fake.getUpstreamForBranchMutex.Lock()
	defer fake.getUpstreamForBranchMutex.Unlock()
	fake.GetUpstreamForBranchStub = nil
	if fake.getUpstreamForBranchReturnsOnCall == nil {
		fake.getUpstreamForBranchReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getUpstreamForBranchReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) Ignore(arg1 string) error {
	fake.ignoreMutex.Lock()
	ret, specificReturn := fake.ignoreReturnsOnCall[len(fake.ignoreArgsForCall)]
	fake.ignoreArgsForCall = append(fake.ignoreArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IgnoreStub
	fakeReturns := fake.ignoreReturns
	fake.recordInvocation("Ignore", []interface{}{arg1})
	fake.ignoreMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) IgnoreCallCount() int {
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	return len(fake.ignoreArgsForCall)
}

func (fake *FakeIGit) IgnoreCalls(stub func(string) error) {
	fake.ignoreMutex.Lock()
	defer fake.ignoreMutex.Unlock()
	fake.IgnoreStub = stub
}

func (fake *FakeIGit) IgnoreArgsForCall(i int) string {
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	argsForCall := fake.ignoreArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) IgnoreReturns(result1 error) {
	fake.ignoreMutex.Lock()
	defer fake.ignoreMutex.Unlock()
	fake.IgnoreStub = nil
	fake.ignoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) IgnoreReturnsOnCall(i int, result1 error) {
	fake.ignoreMutex.Lock()
	defer fake.ignoreMutex.Unlock()
	fake.IgnoreStub = nil
	if fake.ignoreReturnsOnCall == nil {
		fake.ignoreReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ignoreReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) InteractiveRebase(arg1 []*models.Commit, arg2 int, arg3 string) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.interactiveRebaseMutex.Lock()
	ret, specificReturn := fake.interactiveRebaseReturnsOnCall[len(fake.interactiveRebaseArgsForCall)]
	fake.interactiveRebaseArgsForCall = append(fake.interactiveRebaseArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}{arg1Copy, arg2, arg3})
	stub := fake.InteractiveRebaseStub
	fakeReturns := fake.interactiveRebaseReturns
	fake.recordInvocation("InteractiveRebase", []interface{}{arg1Copy, arg2, arg3})
	fake.interactiveRebaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) InteractiveRebaseCallCount() int {
	fake.interactiveRebaseMutex.RLock()
	defer fake.interactiveRebaseMutex.RUnlock()
	return len(fake.interactiveRebaseArgsForCall)
}

func (fake *FakeIGit) InteractiveRebaseCalls(stub func([]*models.Commit, int, string) error) {
	fake.interactiveRebaseMutex.Lock()
	defer fake.interactiveRebaseMutex.Unlock()
	fake.InteractiveRebaseStub = stub
}

func (fake *FakeIGit) InteractiveRebaseArgsForCall(i int) ([]*models.Commit, int, string) {
	fake.interactiveRebaseMutex.RLock()
	defer fake.interactiveRebaseMutex.RUnlock()
	argsForCall := fake.interactiveRebaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) InteractiveRebaseReturns(result1 error) {
	fake.interactiveRebaseMutex.Lock()
	defer fake.interactiveRebaseMutex.Unlock()
	fake.InteractiveRebaseStub = nil
	fake.interactiveRebaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) InteractiveRebaseReturnsOnCall(i int, result1 error) {
	fake.interactiveRebaseMutex.Lock()
	defer fake.interactiveRebaseMutex.Unlock()
	fake.InteractiveRebaseStub = nil
	if fake.interactiveRebaseReturnsOnCall == nil {
		fake.interactiveRebaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.interactiveRebaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) InteractiveRebaseCmdObj(arg1 string, arg2 string, arg3 bool) types.ICmdObj {
	fake.interactiveRebaseCmdObjMutex.Lock()
	ret, specificReturn := fake.interactiveRebaseCmdObjReturnsOnCall[len(fake.interactiveRebaseCmdObjArgsForCall)]
	fake.interactiveRebaseCmdObjArgsForCall = append(fake.interactiveRebaseCmdObjArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.InteractiveRebaseCmdObjStub
	fakeReturns := fake.interactiveRebaseCmdObjReturns
	fake.recordInvocation("InteractiveRebaseCmdObj", []interface{}{arg1, arg2, arg3})
	fake.interactiveRebaseCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) InteractiveRebaseCmdObjCallCount() int {
	fake.interactiveRebaseCmdObjMutex.RLock()
	defer fake.interactiveRebaseCmdObjMutex.RUnlock()
	return len(fake.interactiveRebaseCmdObjArgsForCall)
}

func (fake *FakeIGit) InteractiveRebaseCmdObjCalls(stub func(string, string, bool) types.ICmdObj) {
	fake.interactiveRebaseCmdObjMutex.Lock()
	defer fake.interactiveRebaseCmdObjMutex.Unlock()
	fake.InteractiveRebaseCmdObjStub = stub
}

func (fake *FakeIGit) InteractiveRebaseCmdObjArgsForCall(i int) (string, string, bool) {
	fake.interactiveRebaseCmdObjMutex.RLock()
	defer fake.interactiveRebaseCmdObjMutex.RUnlock()
	argsForCall := fake.interactiveRebaseCmdObjArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) InteractiveRebaseCmdObjReturns(result1 types.ICmdObj) {
	fake.interactiveRebaseCmdObjMutex.Lock()
	defer fake.interactiveRebaseCmdObjMutex.Unlock()
	fake.InteractiveRebaseCmdObjStub = nil
	fake.interactiveRebaseCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) InteractiveRebaseCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.interactiveRebaseCmdObjMutex.Lock()
	defer fake.interactiveRebaseCmdObjMutex.Unlock()
	fake.InteractiveRebaseCmdObjStub = nil
	if fake.interactiveRebaseCmdObjReturnsOnCall == nil {
		fake.interactiveRebaseCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.interactiveRebaseCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) IsBareRepo() bool {
	fake.isBareRepoMutex.Lock()
	ret, specificReturn := fake.isBareRepoReturnsOnCall[len(fake.isBareRepoArgsForCall)]
	fake.isBareRepoArgsForCall = append(fake.isBareRepoArgsForCall, struct {
	}{})
	stub := fake.IsBareRepoStub
	fakeReturns := fake.isBareRepoReturns
	fake.recordInvocation("IsBareRepo", []interface{}{})
	fake.isBareRepoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) IsBareRepoCallCount() int {
	fake.isBareRepoMutex.RLock()
	defer fake.isBareRepoMutex.RUnlock()
	return len(fake.isBareRepoArgsForCall)
}

func (fake *FakeIGit) IsBareRepoCalls(stub func() bool) {
	fake.isBareRepoMutex.Lock()
	defer fake.isBareRepoMutex.Unlock()
	fake.IsBareRepoStub = stub
}

func (fake *FakeIGit) IsBareRepoReturns(result1 bool) {
	fake.isBareRepoMutex.Lock()
	defer fake.isBareRepoMutex.Unlock()
	fake.IsBareRepoStub = nil
	fake.isBareRepoReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) IsBareRepoReturnsOnCall(i int, result1 bool) {
	fake.isBareRepoMutex.Lock()
	defer fake.isBareRepoMutex.Unlock()
	fake.IsBareRepoStub = nil
	if fake.isBareRepoReturnsOnCall == nil {
		fake.isBareRepoReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isBareRepoReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) IsHeadDetached() bool {
	fake.isHeadDetachedMutex.Lock()
	ret, specificReturn := fake.isHeadDetachedReturnsOnCall[len(fake.isHeadDetachedArgsForCall)]
	fake.isHeadDetachedArgsForCall = append(fake.isHeadDetachedArgsForCall, struct {
	}{})
	stub := fake.IsHeadDetachedStub
	fakeReturns := fake.isHeadDetachedReturns
	fake.recordInvocation("IsHeadDetached", []interface{}{})
	fake.isHeadDetachedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) IsHeadDetachedCallCount() int {
	fake.isHeadDetachedMutex.RLock()
	defer fake.isHeadDetachedMutex.RUnlock()
	return len(fake.isHeadDetachedArgsForCall)
}

func (fake *FakeIGit) IsHeadDetachedCalls(stub func() bool) {
	fake.isHeadDetachedMutex.Lock()
	defer fake.isHeadDetachedMutex.Unlock()
	fake.IsHeadDetachedStub = stub
}

func (fake *FakeIGit) IsHeadDetachedReturns(result1 bool) {
	fake.isHeadDetachedMutex.Lock()
	defer fake.isHeadDetachedMutex.Unlock()
	fake.IsHeadDetachedStub = nil
	fake.isHeadDetachedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) IsHeadDetachedReturnsOnCall(i int, result1 bool) {
	fake.isHeadDetachedMutex.Lock()
	defer fake.isHeadDetachedMutex.Unlock()
	fake.IsHeadDetachedStub = nil
	if fake.isHeadDetachedReturnsOnCall == nil {
		fake.isHeadDetachedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isHeadDetachedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) IsInMergeState() (bool, error) {
	fake.isInMergeStateMutex.Lock()
	ret, specificReturn := fake.isInMergeStateReturnsOnCall[len(fake.isInMergeStateArgsForCall)]
	fake.isInMergeStateArgsForCall = append(fake.isInMergeStateArgsForCall, struct {
	}{})
	stub := fake.IsInMergeStateStub
	fakeReturns := fake.isInMergeStateReturns
	fake.recordInvocation("IsInMergeState", []interface{}{})
	fake.isInMergeStateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) IsInMergeStateCallCount() int {
	fake.isInMergeStateMutex.RLock()
	defer fake.isInMergeStateMutex.RUnlock()
	return len(fake.isInMergeStateArgsForCall)
}

func (fake *FakeIGit) IsInMergeStateCalls(stub func() (bool, error)) {
	fake.isInMergeStateMutex.Lock()
	defer fake.isInMergeStateMutex.Unlock()
	fake.IsInMergeStateStub = stub
}

func (fake *FakeIGit) IsInMergeStateReturns(result1 bool, result2 error) {
	fake.isInMergeStateMutex.Lock()
	defer fake.isInMergeStateMutex.Unlock()
	fake.IsInMergeStateStub = nil
	fake.isInMergeStateReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) IsInMergeStateReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isInMergeStateMutex.Lock()
	defer fake.isInMergeStateMutex.Unlock()
	fake.IsInMergeStateStub = nil
	if fake.isInMergeStateReturnsOnCall == nil {
		fake.isInMergeStateReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isInMergeStateReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) Merge(arg1 string, arg2 commands.MergeOpts) error {
	fake.mergeMutex.Lock()
	ret, specificReturn := fake.mergeReturnsOnCall[len(fake.mergeArgsForCall)]
	fake.mergeArgsForCall = append(fake.mergeArgsForCall, struct {
		arg1 string
		arg2 commands.MergeOpts
	}{arg1, arg2})
	stub := fake.MergeStub
	fakeReturns := fake.mergeReturns
	fake.recordInvocation("Merge", []interface{}{arg1, arg2})
	fake.mergeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) MergeCallCount() int {
	fake.mergeMutex.RLock()
	defer fake.mergeMutex.RUnlock()
	return len(fake.mergeArgsForCall)
}

func (fake *FakeIGit) MergeCalls(stub func(string, commands.MergeOpts) error) {
	fake.mergeMutex.Lock()
	defer fake.mergeMutex.Unlock()
	fake.MergeStub = stub
}

func (fake *FakeIGit) MergeArgsForCall(i int) (string, commands.MergeOpts) {
	fake.mergeMutex.RLock()
	defer fake.mergeMutex.RUnlock()
	argsForCall := fake.mergeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) MergeReturns(result1 error) {
	fake.mergeMutex.Lock()
	defer fake.mergeMutex.Unlock()
	fake.MergeStub = nil
	fake.mergeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) MergeReturnsOnCall(i int, result1 error) {
	fake.mergeMutex.Lock()
	defer fake.mergeMutex.Unlock()
	fake.MergeStub = nil
	if fake.mergeReturnsOnCall == nil {
		fake.mergeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mergeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) MergeOrRebase() string {
	fake.mergeOrRebaseMutex.Lock()
	ret, specificReturn := fake.mergeOrRebaseReturnsOnCall[len(fake.mergeOrRebaseArgsForCall)]
	fake.mergeOrRebaseArgsForCall = append(fake.mergeOrRebaseArgsForCall, struct {
	}{})
	stub := fake.MergeOrRebaseStub
	fakeReturns := fake.mergeOrRebaseReturns
	fake.recordInvocation("MergeOrRebase", []interface{}{})
	fake.mergeOrRebaseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) MergeOrRebaseCallCount() int {
	fake.mergeOrRebaseMutex.RLock()
	defer fake.mergeOrRebaseMutex.RUnlock()
	return len(fake.mergeOrRebaseArgsForCall)
}

func (fake *FakeIGit) MergeOrRebaseCalls(stub func() string) {
	fake.mergeOrRebaseMutex.Lock()
	defer fake.mergeOrRebaseMutex.Unlock()
	fake.MergeOrRebaseStub = stub
}

func (fake *FakeIGit) MergeOrRebaseReturns(result1 string) {
	fake.mergeOrRebaseMutex.Lock()
	defer fake.mergeOrRebaseMutex.Unlock()
	fake.MergeOrRebaseStub = nil
	fake.mergeOrRebaseReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) MergeOrRebaseReturnsOnCall(i int, result1 string) {
	fake.mergeOrRebaseMutex.Lock()
	defer fake.mergeOrRebaseMutex.Unlock()
	fake.MergeOrRebaseStub = nil
	if fake.mergeOrRebaseReturnsOnCall == nil {
		fake.mergeOrRebaseReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.mergeOrRebaseReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) MoveCommitDown(arg1 []*models.Commit, arg2 int) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.moveCommitDownMutex.Lock()
	ret, specificReturn := fake.moveCommitDownReturnsOnCall[len(fake.moveCommitDownArgsForCall)]
	fake.moveCommitDownArgsForCall = append(fake.moveCommitDownArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
	}{arg1Copy, arg2})
	stub := fake.MoveCommitDownStub
	fakeReturns := fake.moveCommitDownReturns
	fake.recordInvocation("MoveCommitDown", []interface{}{arg1Copy, arg2})
	fake.moveCommitDownMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) MoveCommitDownCallCount() int {
	fake.moveCommitDownMutex.RLock()
	defer fake.moveCommitDownMutex.RUnlock()
	return len(fake.moveCommitDownArgsForCall)
}

func (fake *FakeIGit) MoveCommitDownCalls(stub func([]*models.Commit, int) error) {
	fake.moveCommitDownMutex.Lock()
	defer fake.moveCommitDownMutex.Unlock()
	fake.MoveCommitDownStub = stub
}

func (fake *FakeIGit) MoveCommitDownArgsForCall(i int) ([]*models.Commit, int) {
	fake.moveCommitDownMutex.RLock()
	defer fake.moveCommitDownMutex.RUnlock()
	argsForCall := fake.moveCommitDownArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) MoveCommitDownReturns(result1 error) {
	fake.moveCommitDownMutex.Lock()
	defer fake.moveCommitDownMutex.Unlock()
	fake.MoveCommitDownStub = nil
	fake.moveCommitDownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) MoveCommitDownReturnsOnCall(i int, result1 error) {
	fake.moveCommitDownMutex.Lock()
	defer fake.moveCommitDownMutex.Unlock()
	fake.MoveCommitDownStub = nil
	if fake.moveCommitDownReturnsOnCall == nil {
		fake.moveCommitDownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.moveCommitDownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) MovePatchIntoIndex(arg1 []*models.Commit, arg2 int, arg3 *patch.PatchManager, arg4 bool) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.movePatchIntoIndexMutex.Lock()
	ret, specificReturn := fake.movePatchIntoIndexReturnsOnCall[len(fake.movePatchIntoIndexArgsForCall)]
	fake.movePatchIntoIndexArgsForCall = append(fake.movePatchIntoIndexArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
		arg4 bool
	}{arg1Copy, arg2, arg3, arg4})
	stub := fake.MovePatchIntoIndexStub
	fakeReturns := fake.movePatchIntoIndexReturns
	fake.recordInvocation("MovePatchIntoIndex", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.movePatchIntoIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) MovePatchIntoIndexCallCount() int {
	fake.movePatchIntoIndexMutex.RLock()
	defer fake.movePatchIntoIndexMutex.RUnlock()
	return len(fake.movePatchIntoIndexArgsForCall)
}

func (fake *FakeIGit) MovePatchIntoIndexCalls(stub func([]*models.Commit, int, *patch.PatchManager, bool) error) {
	fake.movePatchIntoIndexMutex.Lock()
	defer fake.movePatchIntoIndexMutex.Unlock()
	fake.MovePatchIntoIndexStub = stub
}

func (fake *FakeIGit) MovePatchIntoIndexArgsForCall(i int) ([]*models.Commit, int, *patch.PatchManager, bool) {
	fake.movePatchIntoIndexMutex.RLock()
	defer fake.movePatchIntoIndexMutex.RUnlock()
	argsForCall := fake.movePatchIntoIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIGit) MovePatchIntoIndexReturns(result1 error) {
	fake.movePatchIntoIndexMutex.Lock()
	defer fake.movePatchIntoIndexMutex.Unlock()
	fake.MovePatchIntoIndexStub = nil
	fake.movePatchIntoIndexReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) MovePatchIntoIndexReturnsOnCall(i int, result1 error) {
	fake.movePatchIntoIndexMutex.Lock()
	defer fake.movePatchIntoIndexMutex.Unlock()
	fake.MovePatchIntoIndexStub = nil
	if fake.movePatchIntoIndexReturnsOnCall == nil {
		fake.movePatchIntoIndexReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.movePatchIntoIndexReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) MovePatchToSelectedCommit(arg1 []*models.Commit, arg2 int, arg3 int, arg4 *patch.PatchManager) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.movePatchToSelectedCommitMutex.Lock()
	ret, specificReturn := fake.movePatchToSelectedCommitReturnsOnCall[len(fake.movePatchToSelectedCommitArgsForCall)]
	fake.movePatchToSelectedCommitArgsForCall = append(fake.movePatchToSelectedCommitArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 int
		arg4 *patch.PatchManager
	}{arg1Copy, arg2, arg3, arg4})
	stub := fake.MovePatchToSelectedCommitStub
	fakeReturns := fake.movePatchToSelectedCommitReturns
	fake.recordInvocation("MovePatchToSelectedCommit", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.movePatchToSelectedCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) MovePatchToSelectedCommitCallCount() int {
	fake.movePatchToSelectedCommitMutex.RLock()
	defer fake.movePatchToSelectedCommitMutex.RUnlock()
	return len(fake.movePatchToSelectedCommitArgsForCall)
}

func (fake *FakeIGit) MovePatchToSelectedCommitCalls(stub func([]*models.Commit, int, int, *patch.PatchManager) error) {
	fake.movePatchToSelectedCommitMutex.Lock()
	defer fake.movePatchToSelectedCommitMutex.Unlock()
	fake.MovePatchToSelectedCommitStub = stub
}

func (fake *FakeIGit) MovePatchToSelectedCommitArgsForCall(i int) ([]*models.Commit, int, int, *patch.PatchManager) {
	fake.movePatchToSelectedCommitMutex.RLock()
	defer fake.movePatchToSelectedCommitMutex.RUnlock()
	argsForCall := fake.movePatchToSelectedCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIGit) MovePatchToSelectedCommitReturns(result1 error) {
	fake.movePatchToSelectedCommitMutex.Lock()
	defer fake.movePatchToSelectedCommitMutex.Unlock()
	fake.MovePatchToSelectedCommitStub = nil
	fake.movePatchToSelectedCommitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) MovePatchToSelectedCommitReturnsOnCall(i int, result1 error) {
	fake.movePatchToSelectedCommitMutex.Lock()
	defer fake.movePatchToSelectedCommitMutex.Unlock()
	fake.MovePatchToSelectedCommitStub = nil
	if fake.movePatchToSelectedCommitReturnsOnCall == nil {
		fake.movePatchToSelectedCommitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.movePatchToSelectedCommitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) MoveTodoDown(arg1 int) error {
	fake.moveTodoDownMutex.Lock()
	ret, specificReturn := fake.moveTodoDownReturnsOnCall[len(fake.moveTodoDownArgsForCall)]
	fake.moveTodoDownArgsForCall = append(fake.moveTodoDownArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.MoveTodoDownStub
	fakeReturns := fake.moveTodoDownReturns
	fake.recordInvocation("MoveTodoDown", []interface{}{arg1})
	fake.moveTodoDownMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) MoveTodoDownCallCount() int {
	fake.moveTodoDownMutex.RLock()
	defer fake.moveTodoDownMutex.RUnlock()
	return len(fake.moveTodoDownArgsForCall)
}

func (fake *FakeIGit) MoveTodoDownCalls(stub func(int) error) {
	fake.moveTodoDownMutex.Lock()
	defer fake.moveTodoDownMutex.Unlock()
	fake.MoveTodoDownStub = stub
}

func (fake *FakeIGit) MoveTodoDownArgsForCall(i int) int {
	fake.moveTodoDownMutex.RLock()
	defer fake.moveTodoDownMutex.RUnlock()
	argsForCall := fake.moveTodoDownArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) MoveTodoDownReturns(result1 error) {
	fake.moveTodoDownMutex.Lock()
	defer fake.moveTodoDownMutex.Unlock()
	fake.MoveTodoDownStub = nil
	fake.moveTodoDownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) MoveTodoDownReturnsOnCall(i int, result1 error) {
	fake.moveTodoDownMutex.Lock()
	defer fake.moveTodoDownMutex.Unlock()
	fake.MoveTodoDownStub = nil
	if fake.moveTodoDownReturnsOnCall == nil {
		fake.moveTodoDownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.moveTodoDownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) NewPatchManager() *patch.PatchManager {
	fake.newPatchManagerMutex.Lock()
	ret, specificReturn := fake.newPatchManagerReturnsOnCall[len(fake.newPatchManagerArgsForCall)]
	fake.newPatchManagerArgsForCall = append(fake.newPatchManagerArgsForCall, struct {
	}{})
	stub := fake.NewPatchManagerStub
	fakeReturns := fake.newPatchManagerReturns
	fake.recordInvocation("NewPatchManager", []interface{}{})
	fake.newPatchManagerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) NewPatchManagerCallCount() int {
	fake.newPatchManagerMutex.RLock()
	defer fake.newPatchManagerMutex.RUnlock()
	return len(fake.newPatchManagerArgsForCall)
}

func (fake *FakeIGit) NewPatchManagerCalls(stub func() *patch.PatchManager) {
	fake.newPatchManagerMutex.Lock()
	defer fake.newPatchManagerMutex.Unlock()
	fake.NewPatchManagerStub = stub
}

func (fake *FakeIGit) NewPatchManagerReturns(result1 *patch.PatchManager) {
	fake.newPatchManagerMutex.Lock()
	defer fake.newPatchManagerMutex.Unlock()
	fake.NewPatchManagerStub = nil
	fake.newPatchManagerReturns = struct {
		result1 *patch.PatchManager
	}{result1}
}

func (fake *FakeIGit) NewPatchManagerReturnsOnCall(i int, result1 *patch.PatchManager) {
	fake.newPatchManagerMutex.Lock()
	defer fake.newPatchManagerMutex.Unlock()
	fake.NewPatchManagerStub = nil
	if fake.newPatchManagerReturnsOnCall == nil {
		fake.newPatchManagerReturnsOnCall = make(map[int]struct {
			result1 *patch.PatchManager
		})
	}
	fake.newPatchManagerReturnsOnCall[i] = struct {
		result1 *patch.PatchManager
	}{result1}
}

func (fake *FakeIGit) OpenMergeToolCmdObj() types.ICmdObj {
	fake.openMergeToolCmdObjMutex.Lock()
	ret, specificReturn := fake.openMergeToolCmdObjReturnsOnCall[len(fake.openMergeToolCmdObjArgsForCall)]
	fake.openMergeToolCmdObjArgsForCall = append(fake.openMergeToolCmdObjArgsForCall, struct {
	}{})
	stub := fake.OpenMergeToolCmdObjStub
	fakeReturns := fake.openMergeToolCmdObjReturns
	fake.recordInvocation("OpenMergeToolCmdObj", []interface{}{})
	fake.openMergeToolCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) OpenMergeToolCmdObjCallCount() int {
	fake.openMergeToolCmdObjMutex.RLock()
	defer fake.openMergeToolCmdObjMutex.RUnlock()
	return len(fake.openMergeToolCmdObjArgsForCall)
}

func (fake *FakeIGit) OpenMergeToolCmdObjCalls(stub func() types.ICmdObj) {
	fake.openMergeToolCmdObjMutex.Lock()
	defer fake.openMergeToolCmdObjMutex.Unlock()
	fake.OpenMergeToolCmdObjStub = stub
}

func (fake *FakeIGit) OpenMergeToolCmdObjReturns(result1 types.ICmdObj) {
	fake.openMergeToolCmdObjMutex.Lock()
	defer fake.openMergeToolCmdObjMutex.Unlock()
	fake.OpenMergeToolCmdObjStub = nil
	fake.openMergeToolCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) OpenMergeToolCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.openMergeToolCmdObjMutex.Lock()
	defer fake.openMergeToolCmdObjMutex.Unlock()
	fake.OpenMergeToolCmdObjStub = nil
	if fake.openMergeToolCmdObjReturnsOnCall == nil {
		fake.openMergeToolCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.openMergeToolCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) PullPatchIntoNewCommit(arg1 []*models.Commit, arg2 int, arg3 *patch.PatchManager) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.pullPatchIntoNewCommitMutex.Lock()
	ret, specificReturn := fake.pullPatchIntoNewCommitReturnsOnCall[len(fake.pullPatchIntoNewCommitArgsForCall)]
	fake.pullPatchIntoNewCommitArgsForCall = append(fake.pullPatchIntoNewCommitArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
	}{arg1Copy, arg2, arg3})
	stub := fake.PullPatchIntoNewCommitStub
	fakeReturns := fake.pullPatchIntoNewCommitReturns
	fake.recordInvocation("PullPatchIntoNewCommit", []interface{}{arg1Copy, arg2, arg3})
	fake.pullPatchIntoNewCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) PullPatchIntoNewCommitCallCount() int {
	fake.pullPatchIntoNewCommitMutex.RLock()
	defer fake.pullPatchIntoNewCommitMutex.RUnlock()
	return len(fake.pullPatchIntoNewCommitArgsForCall)
}

func (fake *FakeIGit) PullPatchIntoNewCommitCalls(stub func([]*models.Commit, int, *patch.PatchManager) error) {
	fake.pullPatchIntoNewCommitMutex.Lock()
	defer fake.pullPatchIntoNewCommitMutex.Unlock()
	fake.PullPatchIntoNewCommitStub = stub
}

func (fake *FakeIGit) PullPatchIntoNewCommitArgsForCall(i int) ([]*models.Commit, int, *patch.PatchManager) {
	fake.pullPatchIntoNewCommitMutex.RLock()
	defer fake.pullPatchIntoNewCommitMutex.RUnlock()
	argsForCall := fake.pullPatchIntoNewCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) PullPatchIntoNewCommitReturns(result1 error) {
	fake.pullPatchIntoNewCommitMutex.Lock()
	defer fake.pullPatchIntoNewCommitMutex.Unlock()
	fake.PullPatchIntoNewCommitStub = nil
	fake.pullPatchIntoNewCommitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) PullPatchIntoNewCommitReturnsOnCall(i int, result1 error) {
	fake.pullPatchIntoNewCommitMutex.Lock()
	defer fake.pullPatchIntoNewCommitMutex.Unlock()
	fake.PullPatchIntoNewCommitStub = nil
	if fake.pullPatchIntoNewCommitReturnsOnCall == nil {
		fake.pullPatchIntoNewCommitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pullPatchIntoNewCommitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) Push(arg1 commands.PushOpts) (bool, error) {
	fake.pushMutex.Lock()
	ret, specificReturn := fake.pushReturnsOnCall[len(fake.pushArgsForCall)]
	fake.pushArgsForCall = append(fake.pushArgsForCall, struct {
		arg1 commands.PushOpts
	}{arg1})
	stub := fake.PushStub
	fakeReturns := fake.pushReturns
	fake.recordInvocation("Push", []interface{}{arg1})
	fake.pushMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) PushCallCount() int {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	return len(fake.pushArgsForCall)
}

func (fake *FakeIGit) PushCalls(stub func(commands.PushOpts) (bool, error)) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = stub
}

func (fake *FakeIGit) PushArgsForCall(i int) commands.PushOpts {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	argsForCall := fake.pushArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) PushReturns(result1 bool, result2 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	fake.pushReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) PushReturnsOnCall(i int, result1 bool, result2 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	if fake.pushReturnsOnCall == nil {
		fake.pushReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.pushReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) PushTag(arg1 string, arg2 string) error {
	fake.pushTagMutex.Lock()
	ret, specificReturn := fake.pushTagReturnsOnCall[len(fake.pushTagArgsForCall)]
	fake.pushTagArgsForCall = append(fake.pushTagArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.PushTagStub
	fakeReturns := fake.pushTagReturns
	fake.recordInvocation("PushTag", []interface{}{arg1, arg2})
	fake.pushTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) PushTagCallCount() int {
	fake.pushTagMutex.RLock()
	defer fake.pushTagMutex.RUnlock()
	return len(fake.pushTagArgsForCall)
}

func (fake *FakeIGit) PushTagCalls(stub func(string, string) error) {
	fake.pushTagMutex.Lock()
	defer fake.pushTagMutex.Unlock()
	fake.PushTagStub = stub
}

func (fake *FakeIGit) PushTagArgsForCall(i int) (string, string) {
	fake.pushTagMutex.RLock()
	defer fake.pushTagMutex.RUnlock()
	argsForCall := fake.pushTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) PushTagReturns(result1 error) {
	fake.pushTagMutex.Lock()
	defer fake.pushTagMutex.Unlock()
	fake.PushTagStub = nil
	fake.pushTagReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) PushTagReturnsOnCall(i int, result1 error) {
	fake.pushTagMutex.Lock()
	defer fake.pushTagMutex.Unlock()
	fake.PushTagStub = nil
	if fake.pushTagReturnsOnCall == nil {
		fake.pushTagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pushTagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) Quote(arg1 string) string {
	fake.quoteMutex.Lock()
	ret, specificReturn := fake.quoteReturnsOnCall[len(fake.quoteArgsForCall)]
	fake.quoteArgsForCall = append(fake.quoteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.QuoteStub
	fakeReturns := fake.quoteReturns
	fake.recordInvocation("Quote", []interface{}{arg1})
	fake.quoteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) QuoteCallCount() int {
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	return len(fake.quoteArgsForCall)
}

func (fake *FakeIGit) QuoteCalls(stub func(string) string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = stub
}

func (fake *FakeIGit) QuoteArgsForCall(i int) string {
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	argsForCall := fake.quoteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) QuoteReturns(result1 string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = nil
	fake.quoteReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) QuoteReturnsOnCall(i int, result1 string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = nil
	if fake.quoteReturnsOnCall == nil {
		fake.quoteReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.quoteReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) RebaseBranch(arg1 string) error {
	fake.rebaseBranchMutex.Lock()
	ret, specificReturn := fake.rebaseBranchReturnsOnCall[len(fake.rebaseBranchArgsForCall)]
	fake.rebaseBranchArgsForCall = append(fake.rebaseBranchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RebaseBranchStub
	fakeReturns := fake.rebaseBranchReturns
	fake.recordInvocation("RebaseBranch", []interface{}{arg1})
	fake.rebaseBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RebaseBranchCallCount() int {
	fake.rebaseBranchMutex.RLock()
	defer fake.rebaseBranchMutex.RUnlock()
	return len(fake.rebaseBranchArgsForCall)
}

func (fake *FakeIGit) RebaseBranchCalls(stub func(string) error) {
	fake.rebaseBranchMutex.Lock()
	defer fake.rebaseBranchMutex.Unlock()
	fake.RebaseBranchStub = stub
}

func (fake *FakeIGit) RebaseBranchArgsForCall(i int) string {
	fake.rebaseBranchMutex.RLock()
	defer fake.rebaseBranchMutex.RUnlock()
	argsForCall := fake.rebaseBranchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) RebaseBranchReturns(result1 error) {
	fake.rebaseBranchMutex.Lock()
	defer fake.rebaseBranchMutex.Unlock()
	fake.RebaseBranchStub = nil
	fake.rebaseBranchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RebaseBranchReturnsOnCall(i int, result1 error) {
	fake.rebaseBranchMutex.Lock()
	defer fake.rebaseBranchMutex.Unlock()
	fake.RebaseBranchStub = nil
	if fake.rebaseBranchReturnsOnCall == nil {
		fake.rebaseBranchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebaseBranchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RebaseMode() (commands.WorkingTreeState, error) {
	fake.rebaseModeMutex.Lock()
	ret, specificReturn := fake.rebaseModeReturnsOnCall[len(fake.rebaseModeArgsForCall)]
	fake.rebaseModeArgsForCall = append(fake.rebaseModeArgsForCall, struct {
	}{})
	stub := fake.RebaseModeStub
	fakeReturns := fake.rebaseModeReturns
	fake.recordInvocation("RebaseMode", []interface{}{})
	fake.rebaseModeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) RebaseModeCallCount() int {
	fake.rebaseModeMutex.RLock()
	defer fake.rebaseModeMutex.RUnlock()
	return len(fake.rebaseModeArgsForCall)
}

func (fake *FakeIGit) RebaseModeCalls(stub func() (commands.WorkingTreeState, error)) {
	fake.rebaseModeMutex.Lock()
	defer fake.rebaseModeMutex.Unlock()
	fake.RebaseModeStub = stub
}

func (fake *FakeIGit) RebaseModeReturns(result1 commands.WorkingTreeState, result2 error) {
	fake.rebaseModeMutex.Lock()
	defer fake.rebaseModeMutex.Unlock()
	fake.RebaseModeStub = nil
	fake.rebaseModeReturns = struct {
		result1 commands.WorkingTreeState
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) RebaseModeReturnsOnCall(i int, result1 commands.WorkingTreeState, result2 error) {
	fake.rebaseModeMutex.Lock()
	defer fake.rebaseModeMutex.Unlock()
	fake.RebaseModeStub = nil
	if fake.rebaseModeReturnsOnCall == nil {
		fake.rebaseModeReturnsOnCall = make(map[int]struct {
			result1 commands.WorkingTreeState
			result2 error
		})
	}
	fake.rebaseModeReturnsOnCall[i] = struct {
		result1 commands.WorkingTreeState
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) RemoveRemote(arg1 string) error {
	fake.removeRemoteMutex.Lock()
	ret, specificReturn := fake.removeRemoteReturnsOnCall[len(fake.removeRemoteArgsForCall)]
	fake.removeRemoteArgsForCall = append(fake.removeRemoteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveRemoteStub
	fakeReturns := fake.removeRemoteReturns
	fake.recordInvocation("RemoveRemote", []interface{}{arg1})
	fake.removeRemoteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RemoveRemoteCallCount() int {
	fake.removeRemoteMutex.RLock()
	defer fake.removeRemoteMutex.RUnlock()
	return len(fake.removeRemoteArgsForCall)
}

func (fake *FakeIGit) RemoveRemoteCalls(stub func(string) error) {
	fake.removeRemoteMutex.Lock()
	defer fake.removeRemoteMutex.Unlock()
	fake.RemoveRemoteStub = stub
}

func (fake *FakeIGit) RemoveRemoteArgsForCall(i int) string {
	fake.removeRemoteMutex.RLock()
	defer fake.removeRemoteMutex.RUnlock()
	argsForCall := fake.removeRemoteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) RemoveRemoteReturns(result1 error) {
	fake.removeRemoteMutex.Lock()
	defer fake.removeRemoteMutex.Unlock()
	fake.RemoveRemoteStub = nil
	fake.removeRemoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RemoveRemoteReturnsOnCall(i int, result1 error) {
	fake.removeRemoteMutex.Lock()
	defer fake.removeRemoteMutex.Unlock()
	fake.RemoveRemoteStub = nil
	if fake.removeRemoteReturnsOnCall == nil {
		fake.removeRemoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeRemoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RemoveTrackedFiles(arg1 string) error {
	fake.removeTrackedFilesMutex.Lock()
	ret, specificReturn := fake.removeTrackedFilesReturnsOnCall[len(fake.removeTrackedFilesArgsForCall)]
	fake.removeTrackedFilesArgsForCall = append(fake.removeTrackedFilesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveTrackedFilesStub
	fakeReturns := fake.removeTrackedFilesReturns
	fake.recordInvocation("RemoveTrackedFiles", []interface{}{arg1})
	fake.removeTrackedFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RemoveTrackedFilesCallCount() int {
	fake.removeTrackedFilesMutex.RLock()
	defer fake.removeTrackedFilesMutex.RUnlock()
	return len(fake.removeTrackedFilesArgsForCall)
}

func (fake *FakeIGit) RemoveTrackedFilesCalls(stub func(string) error) {
	fake.removeTrackedFilesMutex.Lock()
	defer fake.removeTrackedFilesMutex.Unlock()
	fake.RemoveTrackedFilesStub = stub
}

func (fake *FakeIGit) RemoveTrackedFilesArgsForCall(i int) string {
	fake.removeTrackedFilesMutex.RLock()
	defer fake.removeTrackedFilesMutex.RUnlock()
	argsForCall := fake.removeTrackedFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) RemoveTrackedFilesReturns(result1 error) {
	fake.removeTrackedFilesMutex.Lock()
	defer fake.removeTrackedFilesMutex.Unlock()
	fake.RemoveTrackedFilesStub = nil
	fake.removeTrackedFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RemoveTrackedFilesReturnsOnCall(i int, result1 error) {
	fake.removeTrackedFilesMutex.Lock()
	defer fake.removeTrackedFilesMutex.Unlock()
	fake.RemoveTrackedFilesStub = nil
	if fake.removeTrackedFilesReturnsOnCall == nil {
		fake.removeTrackedFilesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeTrackedFilesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RemoveUntrackedDirFiles(arg1 *filetree.FileNode) error {
	fake.removeUntrackedDirFilesMutex.Lock()
	ret, specificReturn := fake.removeUntrackedDirFilesReturnsOnCall[len(fake.removeUntrackedDirFilesArgsForCall)]
	fake.removeUntrackedDirFilesArgsForCall = append(fake.removeUntrackedDirFilesArgsForCall, struct {
		arg1 *filetree.FileNode
	}{arg1})
	stub := fake.RemoveUntrackedDirFilesStub
	fakeReturns := fake.removeUntrackedDirFilesReturns
	fake.recordInvocation("RemoveUntrackedDirFiles", []interface{}{arg1})
	fake.removeUntrackedDirFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RemoveUntrackedDirFilesCallCount() int {
	fake.removeUntrackedDirFilesMutex.RLock()
	defer fake.removeUntrackedDirFilesMutex.RUnlock()
	return len(fake.removeUntrackedDirFilesArgsForCall)
}

func (fake *FakeIGit) RemoveUntrackedDirFilesCalls(stub func(*filetree.FileNode) error) {
	fake.removeUntrackedDirFilesMutex.Lock()
	defer fake.removeUntrackedDirFilesMutex.Unlock()
	fake.RemoveUntrackedDirFilesStub = stub
}

func (fake *FakeIGit) RemoveUntrackedDirFilesArgsForCall(i int) *filetree.FileNode {
	fake.removeUntrackedDirFilesMutex.RLock()
	defer fake.removeUntrackedDirFilesMutex.RUnlock()
	argsForCall := fake.removeUntrackedDirFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) RemoveUntrackedDirFilesReturns(result1 error) {
	fake.removeUntrackedDirFilesMutex.Lock()
	defer fake.removeUntrackedDirFilesMutex.Unlock()
	fake.RemoveUntrackedDirFilesStub = nil
	fake.removeUntrackedDirFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RemoveUntrackedDirFilesReturnsOnCall(i int, result1 error) {
	fake.removeUntrackedDirFilesMutex.Lock()
	defer fake.removeUntrackedDirFilesMutex.Unlock()
	fake.RemoveUntrackedDirFilesStub = nil
	if fake.removeUntrackedDirFilesReturnsOnCall == nil {
		fake.removeUntrackedDirFilesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeUntrackedDirFilesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RemoveUntrackedFiles() error {
	fake.removeUntrackedFilesMutex.Lock()
	ret, specificReturn := fake.removeUntrackedFilesReturnsOnCall[len(fake.removeUntrackedFilesArgsForCall)]
	fake.removeUntrackedFilesArgsForCall = append(fake.removeUntrackedFilesArgsForCall, struct {
	}{})
	stub := fake.RemoveUntrackedFilesStub
	fakeReturns := fake.removeUntrackedFilesReturns
	fake.recordInvocation("RemoveUntrackedFiles", []interface{}{})
	fake.removeUntrackedFilesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RemoveUntrackedFilesCallCount() int {
	fake.removeUntrackedFilesMutex.RLock()
	defer fake.removeUntrackedFilesMutex.RUnlock()
	return len(fake.removeUntrackedFilesArgsForCall)
}

func (fake *FakeIGit) RemoveUntrackedFilesCalls(stub func() error) {
	fake.removeUntrackedFilesMutex.Lock()
	defer fake.removeUntrackedFilesMutex.Unlock()
	fake.RemoveUntrackedFilesStub = stub
}

func (fake *FakeIGit) RemoveUntrackedFilesReturns(result1 error) {
	fake.removeUntrackedFilesMutex.Lock()
	defer fake.removeUntrackedFilesMutex.Unlock()
	fake.RemoveUntrackedFilesStub = nil
	fake.removeUntrackedFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RemoveUntrackedFilesReturnsOnCall(i int, result1 error) {
	fake.removeUntrackedFilesMutex.Lock()
	defer fake.removeUntrackedFilesMutex.Unlock()
	fake.RemoveUntrackedFilesStub = nil
	if fake.removeUntrackedFilesReturnsOnCall == nil {
		fake.removeUntrackedFilesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeUntrackedFilesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RenameBranch(arg1 string, arg2 string) error {
	fake.renameBranchMutex.Lock()
	ret, specificReturn := fake.renameBranchReturnsOnCall[len(fake.renameBranchArgsForCall)]
	fake.renameBranchArgsForCall = append(fake.renameBranchArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RenameBranchStub
	fakeReturns := fake.renameBranchReturns
	fake.recordInvocation("RenameBranch", []interface{}{arg1, arg2})
	fake.renameBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RenameBranchCallCount() int {
	fake.renameBranchMutex.RLock()
	defer fake.renameBranchMutex.RUnlock()
	return len(fake.renameBranchArgsForCall)
}

func (fake *FakeIGit) RenameBranchCalls(stub func(string, string) error) {
	fake.renameBranchMutex.Lock()
	defer fake.renameBranchMutex.Unlock()
	fake.RenameBranchStub = stub
}

func (fake *FakeIGit) RenameBranchArgsForCall(i int) (string, string) {
	fake.renameBranchMutex.RLock()
	defer fake.renameBranchMutex.RUnlock()
	argsForCall := fake.renameBranchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) RenameBranchReturns(result1 error) {
	fake.renameBranchMutex.Lock()
	defer fake.renameBranchMutex.Unlock()
	fake.RenameBranchStub = nil
	fake.renameBranchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RenameBranchReturnsOnCall(i int, result1 error) {
	fake.renameBranchMutex.Lock()
	defer fake.renameBranchMutex.Unlock()
	fake.RenameBranchStub = nil
	if fake.renameBranchReturnsOnCall == nil {
		fake.renameBranchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameBranchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RenameRemote(arg1 string, arg2 string) error {
	fake.renameRemoteMutex.Lock()
	ret, specificReturn := fake.renameRemoteReturnsOnCall[len(fake.renameRemoteArgsForCall)]
	fake.renameRemoteArgsForCall = append(fake.renameRemoteArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RenameRemoteStub
	fakeReturns := fake.renameRemoteReturns
	fake.recordInvocation("RenameRemote", []interface{}{arg1, arg2})
	fake.renameRemoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RenameRemoteCallCount() int {
	fake.renameRemoteMutex.RLock()
	defer fake.renameRemoteMutex.RUnlock()
	return len(fake.renameRemoteArgsForCall)
}

func (fake *FakeIGit) RenameRemoteCalls(stub func(string, string) error) {
	fake.renameRemoteMutex.Lock()
	defer fake.renameRemoteMutex.Unlock()
	fake.RenameRemoteStub = stub
}

func (fake *FakeIGit) RenameRemoteArgsForCall(i int) (string, string) {
	fake.renameRemoteMutex.RLock()
	defer fake.renameRemoteMutex.RUnlock()
	argsForCall := fake.renameRemoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) RenameRemoteReturns(result1 error) {
	fake.renameRemoteMutex.Lock()
	defer fake.renameRemoteMutex.Unlock()
	fake.RenameRemoteStub = nil
	fake.renameRemoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RenameRemoteReturnsOnCall(i int, result1 error) {
	fake.renameRemoteMutex.Lock()
	defer fake.renameRemoteMutex.Unlock()
	fake.RenameRemoteStub = nil
	if fake.renameRemoteReturnsOnCall == nil {
		fake.renameRemoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameRemoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetAndClean() error {
	fake.resetAndCleanMutex.Lock()
	ret, specificReturn := fake.resetAndCleanReturnsOnCall[len(fake.resetAndCleanArgsForCall)]
	fake.resetAndCleanArgsForCall = append(fake.resetAndCleanArgsForCall, struct {
	}{})
	stub := fake.ResetAndCleanStub
	fakeReturns := fake.resetAndCleanReturns
	fake.recordInvocation("ResetAndClean", []interface{}{})
	fake.resetAndCleanMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ResetAndCleanCallCount() int {
	fake.resetAndCleanMutex.RLock()
	defer fake.resetAndCleanMutex.RUnlock()
	return len(fake.resetAndCleanArgsForCall)
}

func (fake *FakeIGit) ResetAndCleanCalls(stub func() error) {
	fake.resetAndCleanMutex.Lock()
	defer fake.resetAndCleanMutex.Unlock()
	fake.ResetAndCleanStub = stub
}

func (fake *FakeIGit) ResetAndCleanReturns(result1 error) {
	fake.resetAndCleanMutex.Lock()
	defer fake.resetAndCleanMutex.Unlock()
	fake.ResetAndCleanStub = nil
	fake.resetAndCleanReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetAndCleanReturnsOnCall(i int, result1 error) {
	fake.resetAndCleanMutex.Lock()
	defer fake.resetAndCleanMutex.Unlock()
	fake.ResetAndCleanStub = nil
	if fake.resetAndCleanReturnsOnCall == nil {
		fake.resetAndCleanReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetAndCleanReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetHard(arg1 string) error {
	fake.resetHardMutex.Lock()
	ret, specificReturn := fake.resetHardReturnsOnCall[len(fake.resetHardArgsForCall)]
	fake.resetHardArgsForCall = append(fake.resetHardArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResetHardStub
	fakeReturns := fake.resetHardReturns
	fake.recordInvocation("ResetHard", []interface{}{arg1})
	fake.resetHardMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ResetHardCallCount() int {
	fake.resetHardMutex.RLock()
	defer fake.resetHardMutex.RUnlock()
	return len(fake.resetHardArgsForCall)
}

func (fake *FakeIGit) ResetHardCalls(stub func(string) error) {
	fake.resetHardMutex.Lock()
	defer fake.resetHardMutex.Unlock()
	fake.ResetHardStub = stub
}

func (fake *FakeIGit) ResetHardArgsForCall(i int) string {
	fake.resetHardMutex.RLock()
	defer fake.resetHardMutex.RUnlock()
	argsForCall := fake.resetHardArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) ResetHardReturns(result1 error) {
	fake.resetHardMutex.Lock()
	defer fake.resetHardMutex.Unlock()
	fake.ResetHardStub = nil
	fake.resetHardReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetHardReturnsOnCall(i int, result1 error) {
	fake.resetHardMutex.Lock()
	defer fake.resetHardMutex.Unlock()
	fake.ResetHardStub = nil
	if fake.resetHardReturnsOnCall == nil {
		fake.resetHardReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetHardReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetMixed(arg1 string) error {
	fake.resetMixedMutex.Lock()
	ret, specificReturn := fake.resetMixedReturnsOnCall[len(fake.resetMixedArgsForCall)]
	fake.resetMixedArgsForCall = append(fake.resetMixedArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResetMixedStub
	fakeReturns := fake.resetMixedReturns
	fake.recordInvocation("ResetMixed", []interface{}{arg1})
	fake.resetMixedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ResetMixedCallCount() int {
	fake.resetMixedMutex.RLock()
	defer fake.resetMixedMutex.RUnlock()
	return len(fake.resetMixedArgsForCall)
}

func (fake *FakeIGit) ResetMixedCalls(stub func(string) error) {
	fake.resetMixedMutex.Lock()
	defer fake.resetMixedMutex.Unlock()
	fake.ResetMixedStub = stub
}

func (fake *FakeIGit) ResetMixedArgsForCall(i int) string {
	fake.resetMixedMutex.RLock()
	defer fake.resetMixedMutex.RUnlock()
	argsForCall := fake.resetMixedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) ResetMixedReturns(result1 error) {
	fake.resetMixedMutex.Lock()
	defer fake.resetMixedMutex.Unlock()
	fake.ResetMixedStub = nil
	fake.resetMixedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetMixedReturnsOnCall(i int, result1 error) {
	fake.resetMixedMutex.Lock()
	defer fake.resetMixedMutex.Unlock()
	fake.ResetMixedStub = nil
	if fake.resetMixedReturnsOnCall == nil {
		fake.resetMixedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetMixedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetSoft(arg1 string) error {
	fake.resetSoftMutex.Lock()
	ret, specificReturn := fake.resetSoftReturnsOnCall[len(fake.resetSoftArgsForCall)]
	fake.resetSoftArgsForCall = append(fake.resetSoftArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResetSoftStub
	fakeReturns := fake.resetSoftReturns
	fake.recordInvocation("ResetSoft", []interface{}{arg1})
	fake.resetSoftMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ResetSoftCallCount() int {
	fake.resetSoftMutex.RLock()
	defer fake.resetSoftMutex.RUnlock()
	return len(fake.resetSoftArgsForCall)
}

func (fake *FakeIGit) ResetSoftCalls(stub func(string) error) {
	fake.resetSoftMutex.Lock()
	defer fake.resetSoftMutex.Unlock()
	fake.ResetSoftStub = stub
}

func (fake *FakeIGit) ResetSoftArgsForCall(i int) string {
	fake.resetSoftMutex.RLock()
	defer fake.resetSoftMutex.RUnlock()
	argsForCall := fake.resetSoftArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) ResetSoftReturns(result1 error) {
	fake.resetSoftMutex.Lock()
	defer fake.resetSoftMutex.Unlock()
	fake.ResetSoftStub = nil
	fake.resetSoftReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetSoftReturnsOnCall(i int, result1 error) {
	fake.resetSoftMutex.Lock()
	defer fake.resetSoftMutex.Unlock()
	fake.ResetSoftStub = nil
	if fake.resetSoftReturnsOnCall == nil {
		fake.resetSoftReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetSoftReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetSubmodules(arg1 []*models.SubmoduleConfig) error {
	var arg1Copy []*models.SubmoduleConfig
	if arg1 != nil {
		arg1Copy = make([]*models.SubmoduleConfig, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.resetSubmodulesMutex.Lock()
	ret, specificReturn := fake.resetSubmodulesReturnsOnCall[len(fake.resetSubmodulesArgsForCall)]
	fake.resetSubmodulesArgsForCall = append(fake.resetSubmodulesArgsForCall, struct {
		arg1 []*models.SubmoduleConfig
	}{arg1Copy})
	stub := fake.ResetSubmodulesStub
	fakeReturns := fake.resetSubmodulesReturns
	fake.recordInvocation("ResetSubmodules", []interface{}{arg1Copy})
	fake.resetSubmodulesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ResetSubmodulesCallCount() int {
	fake.resetSubmodulesMutex.RLock()
	defer fake.resetSubmodulesMutex.RUnlock()
	return len(fake.resetSubmodulesArgsForCall)
}

func (fake *FakeIGit) ResetSubmodulesCalls(stub func([]*models.SubmoduleConfig) error) {
	fake.resetSubmodulesMutex.Lock()
	defer fake.resetSubmodulesMutex.Unlock()
	fake.ResetSubmodulesStub = stub
}

func (fake *FakeIGit) ResetSubmodulesArgsForCall(i int) []*models.SubmoduleConfig {
	fake.resetSubmodulesMutex.RLock()
	defer fake.resetSubmodulesMutex.RUnlock()
	argsForCall := fake.resetSubmodulesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) ResetSubmodulesReturns(result1 error) {
	fake.resetSubmodulesMutex.Lock()
	defer fake.resetSubmodulesMutex.Unlock()
	fake.ResetSubmodulesStub = nil
	fake.resetSubmodulesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetSubmodulesReturnsOnCall(i int, result1 error) {
	fake.resetSubmodulesMutex.Lock()
	defer fake.resetSubmodulesMutex.Unlock()
	fake.ResetSubmodulesStub = nil
	if fake.resetSubmodulesReturnsOnCall == nil {
		fake.resetSubmodulesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetSubmodulesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetToRef(arg1 string, arg2 string, arg3 commands.ResetToCommitOptions) error {
	fake.resetToRefMutex.Lock()
	ret, specificReturn := fake.resetToRefReturnsOnCall[len(fake.resetToRefArgsForCall)]
	fake.resetToRefArgsForCall = append(fake.resetToRefArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 commands.ResetToCommitOptions
	}{arg1, arg2, arg3})
	stub := fake.ResetToRefStub
	fakeReturns := fake.resetToRefReturns
	fake.recordInvocation("ResetToRef", []interface{}{arg1, arg2, arg3})
	fake.resetToRefMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ResetToRefCallCount() int {
	fake.resetToRefMutex.RLock()
	defer fake.resetToRefMutex.RUnlock()
	return len(fake.resetToRefArgsForCall)
}

func (fake *FakeIGit) ResetToRefCalls(stub func(string, string, commands.ResetToCommitOptions) error) {
	fake.resetToRefMutex.Lock()
	defer fake.resetToRefMutex.Unlock()
	fake.ResetToRefStub = stub
}

func (fake *FakeIGit) ResetToRefArgsForCall(i int) (string, string, commands.ResetToCommitOptions) {
	fake.resetToRefMutex.RLock()
	defer fake.resetToRefMutex.RUnlock()
	argsForCall := fake.resetToRefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) ResetToRefReturns(result1 error) {
	fake.resetToRefMutex.Lock()
	defer fake.resetToRefMutex.Unlock()
	fake.ResetToRefStub = nil
	fake.resetToRefReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ResetToRefReturnsOnCall(i int, result1 error) {
	fake.resetToRefMutex.Lock()
	defer fake.resetToRefMutex.Unlock()
	fake.ResetToRefStub = nil
	if fake.resetToRefReturnsOnCall == nil {
		fake.resetToRefReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetToRefReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) Run(arg1 types.ICmdObj) error {
	fake.runMutex.Lock()
	ret, specificReturn := fake.runReturnsOnCall[len(fake.runArgsForCall)]
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		arg1 types.ICmdObj
	}{arg1})
	stub := fake.RunStub
	fakeReturns := fake.runReturns
	fake.recordInvocation("Run", []interface{}{arg1})
	fake.runMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeIGit) RunCalls(stub func(types.ICmdObj) error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = stub
}

func (fake *FakeIGit) RunArgsForCall(i int) types.ICmdObj {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	argsForCall := fake.runArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) RunReturns(result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RunReturnsOnCall(i int, result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	if fake.runReturnsOnCall == nil {
		fake.runReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RunGitCmdFromStr(arg1 string) error {
	fake.runGitCmdFromStrMutex.Lock()
	ret, specificReturn := fake.runGitCmdFromStrReturnsOnCall[len(fake.runGitCmdFromStrArgsForCall)]
	fake.runGitCmdFromStrArgsForCall = append(fake.runGitCmdFromStrArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RunGitCmdFromStrStub
	fakeReturns := fake.runGitCmdFromStrReturns
	fake.recordInvocation("RunGitCmdFromStr", []interface{}{arg1})
	fake.runGitCmdFromStrMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RunGitCmdFromStrCallCount() int {
	fake.runGitCmdFromStrMutex.RLock()
	defer fake.runGitCmdFromStrMutex.RUnlock()
	return len(fake.runGitCmdFromStrArgsForCall)
}

func (fake *FakeIGit) RunGitCmdFromStrCalls(stub func(string) error) {
	fake.runGitCmdFromStrMutex.Lock()
	defer fake.runGitCmdFromStrMutex.Unlock()
	fake.RunGitCmdFromStrStub = stub
}

func (fake *FakeIGit) RunGitCmdFromStrArgsForCall(i int) string {
	fake.runGitCmdFromStrMutex.RLock()
	defer fake.runGitCmdFromStrMutex.RUnlock()
	argsForCall := fake.runGitCmdFromStrArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) RunGitCmdFromStrReturns(result1 error) {
	fake.runGitCmdFromStrMutex.Lock()
	defer fake.runGitCmdFromStrMutex.Unlock()
	fake.RunGitCmdFromStrStub = nil
	fake.runGitCmdFromStrReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RunGitCmdFromStrReturnsOnCall(i int, result1 error) {
	fake.runGitCmdFromStrMutex.Lock()
	defer fake.runGitCmdFromStrMutex.Unlock()
	fake.RunGitCmdFromStrStub = nil
	if fake.runGitCmdFromStrReturnsOnCall == nil {
		fake.runGitCmdFromStrReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runGitCmdFromStrReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RunWithOutput(arg1 types.ICmdObj) (string, error) {
	fake.runWithOutputMutex.Lock()
	ret, specificReturn := fake.runWithOutputReturnsOnCall[len(fake.runWithOutputArgsForCall)]
	fake.runWithOutputArgsForCall = append(fake.runWithOutputArgsForCall, struct {
		arg1 types.ICmdObj
	}{arg1})
	stub := fake.RunWithOutputStub
	fakeReturns := fake.runWithOutputReturns
	fake.recordInvocation("RunWithOutput", []interface{}{arg1})
	fake.runWithOutputMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) RunWithOutputCallCount() int {
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	return len(fake.runWithOutputArgsForCall)
}

func (fake *FakeIGit) RunWithOutputCalls(stub func(types.ICmdObj) (string, error)) {
	fake.runWithOutputMutex.Lock()
	defer fake.runWithOutputMutex.Unlock()
	fake.RunWithOutputStub = stub
}

func (fake *FakeIGit) RunWithOutputArgsForCall(i int) types.ICmdObj {
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	argsForCall := fake.runWithOutputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) RunWithOutputReturns(result1 string, result2 error) {
	fake.runWithOutputMutex.Lock()
	defer fake.runWithOutputMutex.Unlock()
	fake.RunWithOutputStub = nil
	fake.runWithOutputReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) RunWithOutputReturnsOnCall(i int, result1 string, result2 error) {
	fake.runWithOutputMutex.Lock()
	defer fake.runWithOutputMutex.Unlock()
	fake.RunWithOutputStub = nil
	if fake.runWithOutputReturnsOnCall == nil {
		fake.runWithOutputReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.runWithOutputReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) SetBranchUpstream(arg1 string, arg2 string, arg3 string) error {
	fake.setBranchUpstreamMutex.Lock()
	ret, specificReturn := fake.setBranchUpstreamReturnsOnCall[len(fake.setBranchUpstreamArgsForCall)]
	fake.setBranchUpstreamArgsForCall = append(fake.setBranchUpstreamArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.SetBranchUpstreamStub
	fakeReturns := fake.setBranchUpstreamReturns
	fake.recordInvocation("SetBranchUpstream", []interface{}{arg1, arg2, arg3})
	fake.setBranchUpstreamMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SetBranchUpstreamCallCount() int {
	fake.setBranchUpstreamMutex.RLock()
	defer fake.setBranchUpstreamMutex.RUnlock()
	return len(fake.setBranchUpstreamArgsForCall)
}

func (fake *FakeIGit) SetBranchUpstreamCalls(stub func(string, string, string) error) {
	fake.setBranchUpstreamMutex.Lock()
	defer fake.setBranchUpstreamMutex.Unlock()
	fake.SetBranchUpstreamStub = stub
}

func (fake *FakeIGit) SetBranchUpstreamArgsForCall(i int) (string, string, string) {
	fake.setBranchUpstreamMutex.RLock()
	defer fake.setBranchUpstreamMutex.RUnlock()
	argsForCall := fake.setBranchUpstreamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) SetBranchUpstreamReturns(result1 error) {
	fake.setBranchUpstreamMutex.Lock()
	defer fake.setBranchUpstreamMutex.Unlock()
	fake.SetBranchUpstreamStub = nil
	fake.setBranchUpstreamReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SetBranchUpstreamReturnsOnCall(i int, result1 error) {
	fake.setBranchUpstreamMutex.Lock()
	defer fake.setBranchUpstreamMutex.Unlock()
	fake.SetBranchUpstreamStub = nil
	if fake.setBranchUpstreamReturnsOnCall == nil {
		fake.setBranchUpstreamReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setBranchUpstreamReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SetCredentialHandlers(arg1 func(types.CredentialKind) string, arg2 func(error)) {
	fake.setCredentialHandlersMutex.Lock()
	fake.setCredentialHandlersArgsForCall = append(fake.setCredentialHandlersArgsForCall, struct {
		arg1 func(types.CredentialKind) string
		arg2 func(error)
	}{arg1, arg2})
	stub := fake.SetCredentialHandlersStub
	fake.recordInvocation("SetCredentialHandlers", []interface{}{arg1, arg2})
	fake.setCredentialHandlersMutex.Unlock()
	if stub != nil {
		fake.SetCredentialHandlersStub(arg1, arg2)
	}
}

func (fake *FakeIGit) SetCredentialHandlersCallCount() int {
	fake.setCredentialHandlersMutex.RLock()
	defer fake.setCredentialHandlersMutex.RUnlock()
	return len(fake.setCredentialHandlersArgsForCall)
}

func (fake *FakeIGit) SetCredentialHandlersCalls(stub func(func(types.CredentialKind) string, func(error))) {
	fake.setCredentialHandlersMutex.Lock()
	defer fake.setCredentialHandlersMutex.Unlock()
	fake.SetCredentialHandlersStub = stub
}

func (fake *FakeIGit) SetCredentialHandlersArgsForCall(i int) (func(types.CredentialKind) string, func(error)) {
	fake.setCredentialHandlersMutex.RLock()
	defer fake.setCredentialHandlersMutex.RUnlock()
	argsForCall := fake.setCredentialHandlersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) SetUpstreamBranch(arg1 string) error {
	fake.setUpstreamBranchMutex.Lock()
	ret, specificReturn := fake.setUpstreamBranchReturnsOnCall[len(fake.setUpstreamBranchArgsForCall)]
	fake.setUpstreamBranchArgsForCall = append(fake.setUpstreamBranchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetUpstreamBranchStub
	fakeReturns := fake.setUpstreamBranchReturns
	fake.recordInvocation("SetUpstreamBranch", []interface{}{arg1})
	fake.setUpstreamBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SetUpstreamBranchCallCount() int {
	fake.setUpstreamBranchMutex.RLock()
	defer fake.setUpstreamBranchMutex.RUnlock()
	return len(fake.setUpstreamBranchArgsForCall)
}

func (fake *FakeIGit) SetUpstreamBranchCalls(stub func(string) error) {
	fake.setUpstreamBranchMutex.Lock()
	defer fake.setUpstreamBranchMutex.Unlock()
	fake.SetUpstreamBranchStub = stub
}

func (fake *FakeIGit) SetUpstreamBranchArgsForCall(i int) string {
	fake.setUpstreamBranchMutex.RLock()
	defer fake.setUpstreamBranchMutex.RUnlock()
	argsForCall := fake.setUpstreamBranchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) SetUpstreamBranchReturns(result1 error) {
	fake.setUpstreamBranchMutex.Lock()
	defer fake.setUpstreamBranchMutex.Unlock()
	fake.SetUpstreamBranchStub = nil
	fake.setUpstreamBranchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SetUpstreamBranchReturnsOnCall(i int, result1 error) {
	fake.setUpstreamBranchMutex.Lock()
	defer fake.setUpstreamBranchMutex.Unlock()
	fake.SetUpstreamBranchStub = nil
	if fake.setUpstreamBranchReturnsOnCall == nil {
		fake.setUpstreamBranchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setUpstreamBranchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) ShowFileDiff(arg1 string, arg2 string, arg3 bool, arg4 string, arg5 bool) (string, error) {
	fake.showFileDiffMutex.Lock()
	ret, specificReturn := fake.showFileDiffReturnsOnCall[len(fake.showFileDiffArgsForCall)]
	fake.showFileDiffArgsForCall = append(fake.showFileDiffArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 string
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ShowFileDiffStub
	fakeReturns := fake.showFileDiffReturns
	fake.recordInvocation("ShowFileDiff", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.showFileDiffMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) ShowFileDiffCallCount() int {
	fake.showFileDiffMutex.RLock()
	defer fake.showFileDiffMutex.RUnlock()
	return len(fake.showFileDiffArgsForCall)
}

func (fake *FakeIGit) ShowFileDiffCalls(stub func(string, string, bool, string, bool) (string, error)) {
	fake.showFileDiffMutex.Lock()
	defer fake.showFileDiffMutex.Unlock()
	fake.ShowFileDiffStub = stub
}

func (fake *FakeIGit) ShowFileDiffArgsForCall(i int) (string, string, bool, string, bool) {
	fake.showFileDiffMutex.RLock()
	defer fake.showFileDiffMutex.RUnlock()
	argsForCall := fake.showFileDiffArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeIGit) ShowFileDiffReturns(result1 string, result2 error) {
	fake.showFileDiffMutex.Lock()
	defer fake.showFileDiffMutex.Unlock()
	fake.ShowFileDiffStub = nil
	fake.showFileDiffReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) ShowFileDiffReturnsOnCall(i int, result1 string, result2 error) {
	fake.showFileDiffMutex.Lock()
	defer fake.showFileDiffMutex.Unlock()
	fake.ShowFileDiffStub = nil
	if fake.showFileDiffReturnsOnCall == nil {
		fake.showFileDiffReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.showFileDiffReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) ShowFileDiffCmdObj(arg1 string, arg2 string, arg3 bool, arg4 string, arg5 bool, arg6 bool) types.ICmdObj {
	fake.showFileDiffCmdObjMutex.Lock()
	ret, specificReturn := fake.showFileDiffCmdObjReturnsOnCall[len(fake.showFileDiffCmdObjArgsForCall)]
	fake.showFileDiffCmdObjArgsForCall = append(fake.showFileDiffCmdObjArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 string
		arg5 bool
		arg6 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.ShowFileDiffCmdObjStub
	fakeReturns := fake.showFileDiffCmdObjReturns
	fake.recordInvocation("ShowFileDiffCmdObj", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.showFileDiffCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ShowFileDiffCmdObjCallCount() int {
	fake.showFileDiffCmdObjMutex.RLock()
	defer fake.showFileDiffCmdObjMutex.RUnlock()
	return len(fake.showFileDiffCmdObjArgsForCall)
}

func (fake *FakeIGit) ShowFileDiffCmdObjCalls(stub func(string, string, bool, string, bool, bool) types.ICmdObj) {
	fake.showFileDiffCmdObjMutex.Lock()
	defer fake.showFileDiffCmdObjMutex.Unlock()
	fake.ShowFileDiffCmdObjStub = stub
}

func (fake *FakeIGit) ShowFileDiffCmdObjArgsForCall(i int) (string, string, bool, string, bool, bool) {
	fake.showFileDiffCmdObjMutex.RLock()
	defer fake.showFileDiffCmdObjMutex.RUnlock()
	argsForCall := fake.showFileDiffCmdObjArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeIGit) ShowFileDiffCmdObjReturns(result1 types.ICmdObj) {
	fake.showFileDiffCmdObjMutex.Lock()
	defer fake.showFileDiffCmdObjMutex.Unlock()
	fake.ShowFileDiffCmdObjStub = nil
	fake.showFileDiffCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) ShowFileDiffCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.showFileDiffCmdObjMutex.Lock()
	defer fake.showFileDiffCmdObjMutex.Unlock()
	fake.ShowFileDiffCmdObjStub = nil
	if fake.showFileDiffCmdObjReturnsOnCall == nil {
		fake.showFileDiffCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.showFileDiffCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) ShowStashEntryCmdObj(arg1 int) types.ICmdObj {
	fake.showStashEntryCmdObjMutex.Lock()
	ret, specificReturn := fake.showStashEntryCmdObjReturnsOnCall[len(fake.showStashEntryCmdObjArgsForCall)]
	fake.showStashEntryCmdObjArgsForCall = append(fake.showStashEntryCmdObjArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.ShowStashEntryCmdObjStub
	fakeReturns := fake.showStashEntryCmdObjReturns
	fake.recordInvocation("ShowStashEntryCmdObj", []interface{}{arg1})
	fake.showStashEntryCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ShowStashEntryCmdObjCallCount() int {
	fake.showStashEntryCmdObjMutex.RLock()
	defer fake.showStashEntryCmdObjMutex.RUnlock()
	return len(fake.showStashEntryCmdObjArgsForCall)
}

func (fake *FakeIGit) ShowStashEntryCmdObjCalls(stub func(int) types.ICmdObj) {
	fake.showStashEntryCmdObjMutex.Lock()
	defer fake.showStashEntryCmdObjMutex.Unlock()
	fake.ShowStashEntryCmdObjStub = stub
}

func (fake *FakeIGit) ShowStashEntryCmdObjArgsForCall(i int) int {
	fake.showStashEntryCmdObjMutex.RLock()
	defer fake.showStashEntryCmdObjMutex.RUnlock()
	argsForCall := fake.showStashEntryCmdObjArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) ShowStashEntryCmdObjReturns(result1 types.ICmdObj) {
	fake.showStashEntryCmdObjMutex.Lock()
	defer fake.showStashEntryCmdObjMutex.Unlock()
	fake.ShowStashEntryCmdObjStub = nil
	fake.showStashEntryCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) ShowStashEntryCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.showStashEntryCmdObjMutex.Lock()
	defer fake.showStashEntryCmdObjMutex.Unlock()
	fake.ShowStashEntryCmdObjStub = nil
	if fake.showStashEntryCmdObjReturnsOnCall == nil {
		fake.showStashEntryCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.showStashEntryCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) SkipEditor(arg1 types.ICmdObj) {
	fake.skipEditorMutex.Lock()
	fake.skipEditorArgsForCall = append(fake.skipEditorArgsForCall, struct {
		arg1 types.ICmdObj
	}{arg1})
	stub := fake.SkipEditorStub
	fake.recordInvocation("SkipEditor", []interface{}{arg1})
	fake.skipEditorMutex.Unlock()
	if stub != nil {
		fake.SkipEditorStub(arg1)
	}
}

func (fake *FakeIGit) SkipEditorCallCount() int {
	fake.skipEditorMutex.RLock()
	defer fake.skipEditorMutex.RUnlock()
	return len(fake.skipEditorArgsForCall)
}

func (fake *FakeIGit) SkipEditorCalls(stub func(types.ICmdObj)) {
	fake.skipEditorMutex.Lock()
	defer fake.skipEditorMutex.Unlock()
	fake.SkipEditorStub = stub
}

func (fake *FakeIGit) SkipEditorArgsForCall(i int) types.ICmdObj {
	fake.skipEditorMutex.RLock()
	defer fake.skipEditorMutex.RUnlock()
	argsForCall := fake.skipEditorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) SquashAllAboveFixupCommits(arg1 string) error {
	fake.squashAllAboveFixupCommitsMutex.Lock()
	ret, specificReturn := fake.squashAllAboveFixupCommitsReturnsOnCall[len(fake.squashAllAboveFixupCommitsArgsForCall)]
	fake.squashAllAboveFixupCommitsArgsForCall = append(fake.squashAllAboveFixupCommitsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SquashAllAboveFixupCommitsStub
	fakeReturns := fake.squashAllAboveFixupCommitsReturns
	fake.recordInvocation("SquashAllAboveFixupCommits", []interface{}{arg1})
	fake.squashAllAboveFixupCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SquashAllAboveFixupCommitsCallCount() int {
	fake.squashAllAboveFixupCommitsMutex.RLock()
	defer fake.squashAllAboveFixupCommitsMutex.RUnlock()
	return len(fake.squashAllAboveFixupCommitsArgsForCall)
}

func (fake *FakeIGit) SquashAllAboveFixupCommitsCalls(stub func(string) error) {
	fake.squashAllAboveFixupCommitsMutex.Lock()
	defer fake.squashAllAboveFixupCommitsMutex.Unlock()
	fake.SquashAllAboveFixupCommitsStub = stub
}

func (fake *FakeIGit) SquashAllAboveFixupCommitsArgsForCall(i int) string {
	fake.squashAllAboveFixupCommitsMutex.RLock()
	defer fake.squashAllAboveFixupCommitsMutex.RUnlock()
	argsForCall := fake.squashAllAboveFixupCommitsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) SquashAllAboveFixupCommitsReturns(result1 error) {
	fake.squashAllAboveFixupCommitsMutex.Lock()
	defer fake.squashAllAboveFixupCommitsMutex.Unlock()
	fake.SquashAllAboveFixupCommitsStub = nil
	fake.squashAllAboveFixupCommitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SquashAllAboveFixupCommitsReturnsOnCall(i int, result1 error) {
	fake.squashAllAboveFixupCommitsMutex.Lock()
	defer fake.squashAllAboveFixupCommitsMutex.Unlock()
	fake.SquashAllAboveFixupCommitsStub = nil
	if fake.squashAllAboveFixupCommitsReturnsOnCall == nil {
		fake.squashAllAboveFixupCommitsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.squashAllAboveFixupCommitsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) StageAll() error {
	fake.stageAllMutex.Lock()
	ret, specificReturn := fake.stageAllReturnsOnCall[len(fake.stageAllArgsForCall)]
	fake.stageAllArgsForCall = append(fake.stageAllArgsForCall, struct {
	}{})
	stub := fake.StageAllStub
	fakeReturns := fake.stageAllReturns
	fake.recordInvocation("StageAll", []interface{}{})
	fake.stageAllMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) StageAllCallCount() int {
	fake.stageAllMutex.RLock()
	defer fake.stageAllMutex.RUnlock()
	return len(fake.stageAllArgsForCall)
}

func (fake *FakeIGit) StageAllCalls(stub func() error) {
	fake.stageAllMutex.Lock()
	defer fake.stageAllMutex.Unlock()
	fake.StageAllStub = stub
}

func (fake *FakeIGit) StageAllReturns(result1 error) {
	fake.stageAllMutex.Lock()
	defer fake.stageAllMutex.Unlock()
	fake.StageAllStub = nil
	fake.stageAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) StageAllReturnsOnCall(i int, result1 error) {
	fake.stageAllMutex.Lock()
	defer fake.stageAllMutex.Unlock()
	fake.StageAllStub = nil
	if fake.stageAllReturnsOnCall == nil {
		fake.stageAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stageAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) StageFile(arg1 string) error {
	fake.stageFileMutex.Lock()
	ret, specificReturn := fake.stageFileReturnsOnCall[len(fake.stageFileArgsForCall)]
	fake.stageFileArgsForCall = append(fake.stageFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StageFileStub
	fakeReturns := fake.stageFileReturns
	fake.recordInvocation("StageFile", []interface{}{arg1})
	fake.stageFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) StageFileCallCount() int {
	fake.stageFileMutex.RLock()
	defer fake.stageFileMutex.RUnlock()
	return len(fake.stageFileArgsForCall)
}

func (fake *FakeIGit) StageFileCalls(stub func(string) error) {
	fake.stageFileMutex.Lock()
	defer fake.stageFileMutex.Unlock()
	fake.StageFileStub = stub
}

func (fake *FakeIGit) StageFileArgsForCall(i int) string {
	fake.stageFileMutex.RLock()
	defer fake.stageFileMutex.RUnlock()
	argsForCall := fake.stageFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) StageFileReturns(result1 error) {
	fake.stageFileMutex.Lock()
	defer fake.stageFileMutex.Unlock()
	fake.StageFileStub = nil
	fake.stageFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) StageFileReturnsOnCall(i int, result1 error) {
	fake.stageFileMutex.Lock()
	defer fake.stageFileMutex.Unlock()
	fake.StageFileStub = nil
	if fake.stageFileReturnsOnCall == nil {
		fake.stageFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stageFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) StashDo(arg1 int, arg2 string) error {
	fake.stashDoMutex.Lock()
	ret, specificReturn := fake.stashDoReturnsOnCall[len(fake.stashDoArgsForCall)]
	fake.stashDoArgsForCall = append(fake.stashDoArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.StashDoStub
	fakeReturns := fake.stashDoReturns
	fake.recordInvocation("StashDo", []interface{}{arg1, arg2})
	fake.stashDoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) StashDoCallCount() int {
	fake.stashDoMutex.RLock()
	defer fake.stashDoMutex.RUnlock()
	return len(fake.stashDoArgsForCall)
}

func (fake *FakeIGit) StashDoCalls(stub func(int, string) error) {
	fake.stashDoMutex.Lock()
	defer fake.stashDoMutex.Unlock()
	fake.StashDoStub = stub
}

func (fake *FakeIGit) StashDoArgsForCall(i int) (int, string) {
	fake.stashDoMutex.RLock()
	defer fake.stashDoMutex.RUnlock()
	argsForCall := fake.stashDoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) StashDoReturns(result1 error) {
	fake.stashDoMutex.Lock()
	defer fake.stashDoMutex.Unlock()
	fake.StashDoStub = nil
	fake.stashDoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) StashDoReturnsOnCall(i int, result1 error) {
	fake.stashDoMutex.Lock()
	defer fake.stashDoMutex.Unlock()
	fake.StashDoStub = nil
	if fake.stashDoReturnsOnCall == nil {
		fake.stashDoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stashDoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) StashSave(arg1 string) error {
	fake.stashSaveMutex.Lock()
	ret, specificReturn := fake.stashSaveReturnsOnCall[len(fake.stashSaveArgsForCall)]
	fake.stashSaveArgsForCall = append(fake.stashSaveArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StashSaveStub
	fakeReturns := fake.stashSaveReturns
	fake.recordInvocation("StashSave", []interface{}{arg1})
	fake.stashSaveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) StashSaveCallCount() int {
	fake.stashSaveMutex.RLock()
	defer fake.stashSaveMutex.RUnlock()
	return len(fake.stashSaveArgsForCall)
}

func (fake *FakeIGit) StashSaveCalls(stub func(string) error) {
	fake.stashSaveMutex.Lock()
	defer fake.stashSaveMutex.Unlock()
	fake.StashSaveStub = stub
}

func (fake *FakeIGit) StashSaveArgsForCall(i int) string {
	fake.stashSaveMutex.RLock()
	defer fake.stashSaveMutex.RUnlock()
	argsForCall := fake.stashSaveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) StashSaveReturns(result1 error) {
	fake.stashSaveMutex.Lock()
	defer fake.stashSaveMutex.Unlock()
	fake.StashSaveStub = nil
	fake.stashSaveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) StashSaveReturnsOnCall(i int, result1 error) {
	fake.stashSaveMutex.Lock()
	defer fake.stashSaveMutex.Unlock()
	fake.StashSaveStub = nil
	if fake.stashSaveReturnsOnCall == nil {
		fake.stashSaveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stashSaveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) StashSaveStagedChanges(arg1 string) error {
	fake.stashSaveStagedChangesMutex.Lock()
	ret, specificReturn := fake.stashSaveStagedChangesReturnsOnCall[len(fake.stashSaveStagedChangesArgsForCall)]
	fake.stashSaveStagedChangesArgsForCall = append(fake.stashSaveStagedChangesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StashSaveStagedChangesStub
	fakeReturns := fake.stashSaveStagedChangesReturns
	fake.recordInvocation("StashSaveStagedChanges", []interface{}{arg1})
	fake.stashSaveStagedChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) StashSaveStagedChangesCallCount() int {
	fake.stashSaveStagedChangesMutex.RLock()
	defer fake.stashSaveStagedChangesMutex.RUnlock()
	return len(fake.stashSaveStagedChangesArgsForCall)
}

func (fake *FakeIGit) StashSaveStagedChangesCalls(stub func(string) error) {
	fake.stashSaveStagedChangesMutex.Lock()
	defer fake.stashSaveStagedChangesMutex.Unlock()
	fake.StashSaveStagedChangesStub = stub
}

func (fake *FakeIGit) StashSaveStagedChangesArgsForCall(i int) string {
	fake.stashSaveStagedChangesMutex.RLock()
	defer fake.stashSaveStagedChangesMutex.RUnlock()
	argsForCall := fake.stashSaveStagedChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) StashSaveStagedChangesReturns(result1 error) {
	fake.stashSaveStagedChangesMutex.Lock()
	defer fake.stashSaveStagedChangesMutex.Unlock()
	fake.StashSaveStagedChangesStub = nil
	fake.stashSaveStagedChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) StashSaveStagedChangesReturnsOnCall(i int, result1 error) {
	fake.stashSaveStagedChangesMutex.Lock()
	defer fake.stashSaveStagedChangesMutex.Unlock()
	fake.StashSaveStagedChangesStub = nil
	if fake.stashSaveStagedChangesReturnsOnCall == nil {
		fake.stashSaveStagedChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stashSaveStagedChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleAdd(arg1 string, arg2 string, arg3 string) error {
	fake.submoduleAddMutex.Lock()
	ret, specificReturn := fake.submoduleAddReturnsOnCall[len(fake.submoduleAddArgsForCall)]
	fake.submoduleAddArgsForCall = append(fake.submoduleAddArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.SubmoduleAddStub
	fakeReturns := fake.submoduleAddReturns
	fake.recordInvocation("SubmoduleAdd", []interface{}{arg1, arg2, arg3})
	fake.submoduleAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmoduleAddCallCount() int {
	fake.submoduleAddMutex.RLock()
	defer fake.submoduleAddMutex.RUnlock()
	return len(fake.submoduleAddArgsForCall)
}

func (fake *FakeIGit) SubmoduleAddCalls(stub func(string, string, string) error) {
	fake.submoduleAddMutex.Lock()
	defer fake.submoduleAddMutex.Unlock()
	fake.SubmoduleAddStub = stub
}

func (fake *FakeIGit) SubmoduleAddArgsForCall(i int) (string, string, string) {
	fake.submoduleAddMutex.RLock()
	defer fake.submoduleAddMutex.RUnlock()
	argsForCall := fake.submoduleAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) SubmoduleAddReturns(result1 error) {
	fake.submoduleAddMutex.Lock()
	defer fake.submoduleAddMutex.Unlock()
	fake.SubmoduleAddStub = nil
	fake.submoduleAddReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleAddReturnsOnCall(i int, result1 error) {
	fake.submoduleAddMutex.Lock()
	defer fake.submoduleAddMutex.Unlock()
	fake.SubmoduleAddStub = nil
	if fake.submoduleAddReturnsOnCall == nil {
		fake.submoduleAddReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.submoduleAddReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleBulkDeinitCmdObj() types.ICmdObj {
	fake.submoduleBulkDeinitCmdObjMutex.Lock()
	ret, specificReturn := fake.submoduleBulkDeinitCmdObjReturnsOnCall[len(fake.submoduleBulkDeinitCmdObjArgsForCall)]
	fake.submoduleBulkDeinitCmdObjArgsForCall = append(fake.submoduleBulkDeinitCmdObjArgsForCall, struct {
	}{})
	stub := fake.SubmoduleBulkDeinitCmdObjStub
	fakeReturns := fake.submoduleBulkDeinitCmdObjReturns
	fake.recordInvocation("SubmoduleBulkDeinitCmdObj", []interface{}{})
	fake.submoduleBulkDeinitCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmoduleBulkDeinitCmdObjCallCount() int {
	fake.submoduleBulkDeinitCmdObjMutex.RLock()
	defer fake.submoduleBulkDeinitCmdObjMutex.RUnlock()
	return len(fake.submoduleBulkDeinitCmdObjArgsForCall)
}

func (fake *FakeIGit) SubmoduleBulkDeinitCmdObjCalls(stub func() types.ICmdObj) {
	fake.submoduleBulkDeinitCmdObjMutex.Lock()
	defer fake.submoduleBulkDeinitCmdObjMutex.Unlock()
	fake.SubmoduleBulkDeinitCmdObjStub = stub
}

func (fake *FakeIGit) SubmoduleBulkDeinitCmdObjReturns(result1 types.ICmdObj) {
	fake.submoduleBulkDeinitCmdObjMutex.Lock()
	defer fake.submoduleBulkDeinitCmdObjMutex.Unlock()
	fake.SubmoduleBulkDeinitCmdObjStub = nil
	fake.submoduleBulkDeinitCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) SubmoduleBulkDeinitCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.submoduleBulkDeinitCmdObjMutex.Lock()
	defer fake.submoduleBulkDeinitCmdObjMutex.Unlock()
	fake.SubmoduleBulkDeinitCmdObjStub = nil
	if fake.submoduleBulkDeinitCmdObjReturnsOnCall == nil {
		fake.submoduleBulkDeinitCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.submoduleBulkDeinitCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) SubmoduleBulkInitCmdObj() types.ICmdObj {
	fake.submoduleBulkInitCmdObjMutex.Lock()
	ret, specificReturn := fake.submoduleBulkInitCmdObjReturnsOnCall[len(fake.submoduleBulkInitCmdObjArgsForCall)]
	fake.submoduleBulkInitCmdObjArgsForCall = append(fake.submoduleBulkInitCmdObjArgsForCall, struct {
	}{})
	stub := fake.SubmoduleBulkInitCmdObjStub
	fakeReturns := fake.submoduleBulkInitCmdObjReturns
	fake.recordInvocation("SubmoduleBulkInitCmdObj", []interface{}{})
	fake.submoduleBulkInitCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmoduleBulkInitCmdObjCallCount() int {
	fake.submoduleBulkInitCmdObjMutex.RLock()
	defer fake.submoduleBulkInitCmdObjMutex.RUnlock()
	return len(fake.submoduleBulkInitCmdObjArgsForCall)
}

func (fake *FakeIGit) SubmoduleBulkInitCmdObjCalls(stub func() types.ICmdObj) {
	fake.submoduleBulkInitCmdObjMutex.Lock()
	defer fake.submoduleBulkInitCmdObjMutex.Unlock()
	fake.SubmoduleBulkInitCmdObjStub = stub
}

func (fake *FakeIGit) SubmoduleBulkInitCmdObjReturns(result1 types.ICmdObj) {
	fake.submoduleBulkInitCmdObjMutex.Lock()
	defer fake.submoduleBulkInitCmdObjMutex.Unlock()
	fake.SubmoduleBulkInitCmdObjStub = nil
	fake.submoduleBulkInitCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) SubmoduleBulkInitCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.submoduleBulkInitCmdObjMutex.Lock()
	defer fake.submoduleBulkInitCmdObjMutex.Unlock()
	fake.SubmoduleBulkInitCmdObjStub = nil
	if fake.submoduleBulkInitCmdObjReturnsOnCall == nil {
		fake.submoduleBulkInitCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.submoduleBulkInitCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) SubmoduleBulkUpdateCmdObj() types.ICmdObj {
	fake.submoduleBulkUpdateCmdObjMutex.Lock()
	ret, specificReturn := fake.submoduleBulkUpdateCmdObjReturnsOnCall[len(fake.submoduleBulkUpdateCmdObjArgsForCall)]
	fake.submoduleBulkUpdateCmdObjArgsForCall = append(fake.submoduleBulkUpdateCmdObjArgsForCall, struct {
	}{})
	stub := fake.SubmoduleBulkUpdateCmdObjStub
	fakeReturns := fake.submoduleBulkUpdateCmdObjReturns
	fake.recordInvocation("SubmoduleBulkUpdateCmdObj", []interface{}{})
	fake.submoduleBulkUpdateCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmoduleBulkUpdateCmdObjCallCount() int {
	fake.submoduleBulkUpdateCmdObjMutex.RLock()
	defer fake.submoduleBulkUpdateCmdObjMutex.RUnlock()
	return len(fake.submoduleBulkUpdateCmdObjArgsForCall)
}

func (fake *FakeIGit) SubmoduleBulkUpdateCmdObjCalls(stub func() types.ICmdObj) {
	fake.submoduleBulkUpdateCmdObjMutex.Lock()
	defer fake.submoduleBulkUpdateCmdObjMutex.Unlock()
	fake.SubmoduleBulkUpdateCmdObjStub = stub
}

func (fake *FakeIGit) SubmoduleBulkUpdateCmdObjReturns(result1 types.ICmdObj) {
	fake.submoduleBulkUpdateCmdObjMutex.Lock()
	defer fake.submoduleBulkUpdateCmdObjMutex.Unlock()
	fake.SubmoduleBulkUpdateCmdObjStub = nil
	fake.submoduleBulkUpdateCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) SubmoduleBulkUpdateCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.submoduleBulkUpdateCmdObjMutex.Lock()
	defer fake.submoduleBulkUpdateCmdObjMutex.Unlock()
	fake.SubmoduleBulkUpdateCmdObjStub = nil
	if fake.submoduleBulkUpdateCmdObjReturnsOnCall == nil {
		fake.submoduleBulkUpdateCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.submoduleBulkUpdateCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) SubmoduleDelete(arg1 *models.SubmoduleConfig) error {
	fake.submoduleDeleteMutex.Lock()
	ret, specificReturn := fake.submoduleDeleteReturnsOnCall[len(fake.submoduleDeleteArgsForCall)]
	fake.submoduleDeleteArgsForCall = append(fake.submoduleDeleteArgsForCall, struct {
		arg1 *models.SubmoduleConfig
	}{arg1})
	stub := fake.SubmoduleDeleteStub
	fakeReturns := fake.submoduleDeleteReturns
	fake.recordInvocation("SubmoduleDelete", []interface{}{arg1})
	fake.submoduleDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmoduleDeleteCallCount() int {
	fake.submoduleDeleteMutex.RLock()
	defer fake.submoduleDeleteMutex.RUnlock()
	return len(fake.submoduleDeleteArgsForCall)
}

func (fake *FakeIGit) SubmoduleDeleteCalls(stub func(*models.SubmoduleConfig) error) {
	fake.submoduleDeleteMutex.Lock()
	defer fake.submoduleDeleteMutex.Unlock()
	fake.SubmoduleDeleteStub = stub
}

func (fake *FakeIGit) SubmoduleDeleteArgsForCall(i int) *models.SubmoduleConfig {
	fake.submoduleDeleteMutex.RLock()
	defer fake.submoduleDeleteMutex.RUnlock()
	argsForCall := fake.submoduleDeleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) SubmoduleDeleteReturns(result1 error) {
	fake.submoduleDeleteMutex.Lock()
	defer fake.submoduleDeleteMutex.Unlock()
	fake.SubmoduleDeleteStub = nil
	fake.submoduleDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleDeleteReturnsOnCall(i int, result1 error) {
	fake.submoduleDeleteMutex.Lock()
	defer fake.submoduleDeleteMutex.Unlock()
	fake.SubmoduleDeleteStub = nil
	if fake.submoduleDeleteReturnsOnCall == nil {
		fake.submoduleDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.submoduleDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleForceBulkUpdateCmdObj() types.ICmdObj {
	fake.submoduleForceBulkUpdateCmdObjMutex.Lock()
	ret, specificReturn := fake.submoduleForceBulkUpdateCmdObjReturnsOnCall[len(fake.submoduleForceBulkUpdateCmdObjArgsForCall)]
	fake.submoduleForceBulkUpdateCmdObjArgsForCall = append(fake.submoduleForceBulkUpdateCmdObjArgsForCall, struct {
	}{})
	stub := fake.SubmoduleForceBulkUpdateCmdObjStub
	fakeReturns := fake.submoduleForceBulkUpdateCmdObjReturns
	fake.recordInvocation("SubmoduleForceBulkUpdateCmdObj", []interface{}{})
	fake.submoduleForceBulkUpdateCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmoduleForceBulkUpdateCmdObjCallCount() int {
	fake.submoduleForceBulkUpdateCmdObjMutex.RLock()
	defer fake.submoduleForceBulkUpdateCmdObjMutex.RUnlock()
	return len(fake.submoduleForceBulkUpdateCmdObjArgsForCall)
}

func (fake *FakeIGit) SubmoduleForceBulkUpdateCmdObjCalls(stub func() types.ICmdObj) {
	fake.submoduleForceBulkUpdateCmdObjMutex.Lock()
	defer fake.submoduleForceBulkUpdateCmdObjMutex.Unlock()
	fake.SubmoduleForceBulkUpdateCmdObjStub = stub
}

func (fake *FakeIGit) SubmoduleForceBulkUpdateCmdObjReturns(result1 types.ICmdObj) {
	fake.submoduleForceBulkUpdateCmdObjMutex.Lock()
	defer fake.submoduleForceBulkUpdateCmdObjMutex.Unlock()
	fake.SubmoduleForceBulkUpdateCmdObjStub = nil
	fake.submoduleForceBulkUpdateCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) SubmoduleForceBulkUpdateCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.submoduleForceBulkUpdateCmdObjMutex.Lock()
	defer fake.submoduleForceBulkUpdateCmdObjMutex.Unlock()
	fake.SubmoduleForceBulkUpdateCmdObjStub = nil
	if fake.submoduleForceBulkUpdateCmdObjReturnsOnCall == nil {
		fake.submoduleForceBulkUpdateCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.submoduleForceBulkUpdateCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) SubmoduleInit(arg1 string) error {
	fake.submoduleInitMutex.Lock()
	ret, specificReturn := fake.submoduleInitReturnsOnCall[len(fake.submoduleInitArgsForCall)]
	fake.submoduleInitArgsForCall = append(fake.submoduleInitArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SubmoduleInitStub
	fakeReturns := fake.submoduleInitReturns
	fake.recordInvocation("SubmoduleInit", []interface{}{arg1})
	fake.submoduleInitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmoduleInitCallCount() int {
	fake.submoduleInitMutex.RLock()
	defer fake.submoduleInitMutex.RUnlock()
	return len(fake.submoduleInitArgsForCall)
}

func (fake *FakeIGit) SubmoduleInitCalls(stub func(string) error) {
	fake.submoduleInitMutex.Lock()
	defer fake.submoduleInitMutex.Unlock()
	fake.SubmoduleInitStub = stub
}

func (fake *FakeIGit) SubmoduleInitArgsForCall(i int) string {
	fake.submoduleInitMutex.RLock()
	defer fake.submoduleInitMutex.RUnlock()
	argsForCall := fake.submoduleInitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) SubmoduleInitReturns(result1 error) {
	fake.submoduleInitMutex.Lock()
	defer fake.submoduleInitMutex.Unlock()
	fake.SubmoduleInitStub = nil
	fake.submoduleInitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleInitReturnsOnCall(i int, result1 error) {
	fake.submoduleInitMutex.Lock()
	defer fake.submoduleInitMutex.Unlock()
	fake.SubmoduleInitStub = nil
	if fake.submoduleInitReturnsOnCall == nil {
		fake.submoduleInitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.submoduleInitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleReset(arg1 *models.SubmoduleConfig) error {
	fake.submoduleResetMutex.Lock()
	ret, specificReturn := fake.submoduleResetReturnsOnCall[len(fake.submoduleResetArgsForCall)]
	fake.submoduleResetArgsForCall = append(fake.submoduleResetArgsForCall, struct {
		arg1 *models.SubmoduleConfig
	}{arg1})
	stub := fake.SubmoduleResetStub
	fakeReturns := fake.submoduleResetReturns
	fake.recordInvocation("SubmoduleReset", []interface{}{arg1})
	fake.submoduleResetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmoduleResetCallCount() int {
	fake.submoduleResetMutex.RLock()
	defer fake.submoduleResetMutex.RUnlock()
	return len(fake.submoduleResetArgsForCall)
}

func (fake *FakeIGit) SubmoduleResetCalls(stub func(*models.SubmoduleConfig) error) {
	fake.submoduleResetMutex.Lock()
	defer fake.submoduleResetMutex.Unlock()
	fake.SubmoduleResetStub = stub
}

func (fake *FakeIGit) SubmoduleResetArgsForCall(i int) *models.SubmoduleConfig {
	fake.submoduleResetMutex.RLock()
	defer fake.submoduleResetMutex.RUnlock()
	argsForCall := fake.submoduleResetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) SubmoduleResetReturns(result1 error) {
	fake.submoduleResetMutex.Lock()
	defer fake.submoduleResetMutex.Unlock()
	fake.SubmoduleResetStub = nil
	fake.submoduleResetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleResetReturnsOnCall(i int, result1 error) {
	fake.submoduleResetMutex.Lock()
	defer fake.submoduleResetMutex.Unlock()
	fake.SubmoduleResetStub = nil
	if fake.submoduleResetReturnsOnCall == nil {
		fake.submoduleResetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.submoduleResetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleStash(arg1 *models.SubmoduleConfig) error {
	fake.submoduleStashMutex.Lock()
	ret, specificReturn := fake.submoduleStashReturnsOnCall[len(fake.submoduleStashArgsForCall)]
	fake.submoduleStashArgsForCall = append(fake.submoduleStashArgsForCall, struct {
		arg1 *models.SubmoduleConfig
	}{arg1})
	stub := fake.SubmoduleStashStub
	fakeReturns := fake.submoduleStashReturns
	fake.recordInvocation("SubmoduleStash", []interface{}{arg1})
	fake.submoduleStashMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmoduleStashCallCount() int {
	fake.submoduleStashMutex.RLock()
	defer fake.submoduleStashMutex.RUnlock()
	return len(fake.submoduleStashArgsForCall)
}

func (fake *FakeIGit) SubmoduleStashCalls(stub func(*models.SubmoduleConfig) error) {
	fake.submoduleStashMutex.Lock()
	defer fake.submoduleStashMutex.Unlock()
	fake.SubmoduleStashStub = stub
}

func (fake *FakeIGit) SubmoduleStashArgsForCall(i int) *models.SubmoduleConfig {
	fake.submoduleStashMutex.RLock()
	defer fake.submoduleStashMutex.RUnlock()
	argsForCall := fake.submoduleStashArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) SubmoduleStashReturns(result1 error) {
	fake.submoduleStashMutex.Lock()
	defer fake.submoduleStashMutex.Unlock()
	fake.SubmoduleStashStub = nil
	fake.submoduleStashReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleStashReturnsOnCall(i int, result1 error) {
	fake.submoduleStashMutex.Lock()
	defer fake.submoduleStashMutex.Unlock()
	fake.SubmoduleStashStub = nil
	if fake.submoduleStashReturnsOnCall == nil {
		fake.submoduleStashReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.submoduleStashReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleUpdate(arg1 string) error {
	fake.submoduleUpdateMutex.Lock()
	ret, specificReturn := fake.submoduleUpdateReturnsOnCall[len(fake.submoduleUpdateArgsForCall)]
	fake.submoduleUpdateArgsForCall = append(fake.submoduleUpdateArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SubmoduleUpdateStub
	fakeReturns := fake.submoduleUpdateReturns
	fake.recordInvocation("SubmoduleUpdate", []interface{}{arg1})
	fake.submoduleUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmoduleUpdateCallCount() int {
	fake.submoduleUpdateMutex.RLock()
	defer fake.submoduleUpdateMutex.RUnlock()
	return len(fake.submoduleUpdateArgsForCall)
}

func (fake *FakeIGit) SubmoduleUpdateCalls(stub func(string) error) {
	fake.submoduleUpdateMutex.Lock()
	defer fake.submoduleUpdateMutex.Unlock()
	fake.SubmoduleUpdateStub = stub
}

func (fake *FakeIGit) SubmoduleUpdateArgsForCall(i int) string {
	fake.submoduleUpdateMutex.RLock()
	defer fake.submoduleUpdateMutex.RUnlock()
	argsForCall := fake.submoduleUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) SubmoduleUpdateReturns(result1 error) {
	fake.submoduleUpdateMutex.Lock()
	defer fake.submoduleUpdateMutex.Unlock()
	fake.SubmoduleUpdateStub = nil
	fake.submoduleUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleUpdateReturnsOnCall(i int, result1 error) {
	fake.submoduleUpdateMutex.Lock()
	defer fake.submoduleUpdateMutex.Unlock()
	fake.SubmoduleUpdateStub = nil
	if fake.submoduleUpdateReturnsOnCall == nil {
		fake.submoduleUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.submoduleUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleUpdateUrl(arg1 string, arg2 string, arg3 string) error {
	fake.submoduleUpdateUrlMutex.Lock()
	ret, specificReturn := fake.submoduleUpdateUrlReturnsOnCall[len(fake.submoduleUpdateUrlArgsForCall)]
	fake.submoduleUpdateUrlArgsForCall = append(fake.submoduleUpdateUrlArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.SubmoduleUpdateUrlStub
	fakeReturns := fake.submoduleUpdateUrlReturns
	fake.recordInvocation("SubmoduleUpdateUrl", []interface{}{arg1, arg2, arg3})
	fake.submoduleUpdateUrlMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmoduleUpdateUrlCallCount() int {
	fake.submoduleUpdateUrlMutex.RLock()
	defer fake.submoduleUpdateUrlMutex.RUnlock()
	return len(fake.submoduleUpdateUrlArgsForCall)
}

func (fake *FakeIGit) SubmoduleUpdateUrlCalls(stub func(string, string, string) error) {
	fake.submoduleUpdateUrlMutex.Lock()
	defer fake.submoduleUpdateUrlMutex.Unlock()
	fake.SubmoduleUpdateUrlStub = stub
}

func (fake *FakeIGit) SubmoduleUpdateUrlArgsForCall(i int) (string, string, string) {
	fake.submoduleUpdateUrlMutex.RLock()
	defer fake.submoduleUpdateUrlMutex.RUnlock()
	argsForCall := fake.submoduleUpdateUrlArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) SubmoduleUpdateUrlReturns(result1 error) {
	fake.submoduleUpdateUrlMutex.Lock()
	defer fake.submoduleUpdateUrlMutex.Unlock()
	fake.SubmoduleUpdateUrlStub = nil
	fake.submoduleUpdateUrlReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) SubmoduleUpdateUrlReturnsOnCall(i int, result1 error) {
	fake.submoduleUpdateUrlMutex.Lock()
	defer fake.submoduleUpdateUrlMutex.Unlock()
	fake.SubmoduleUpdateUrlStub = nil
	if fake.submoduleUpdateUrlReturnsOnCall == nil {
		fake.submoduleUpdateUrlReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.submoduleUpdateUrlReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) UnStageFile(arg1 []string, arg2 bool) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.unStageFileMutex.Lock()
	ret, specificReturn := fake.unStageFileReturnsOnCall[len(fake.unStageFileArgsForCall)]
	fake.unStageFileArgsForCall = append(fake.unStageFileArgsForCall, struct {
		arg1 []string
		arg2 bool
	}{arg1Copy, arg2})
	stub := fake.UnStageFileStub
	fakeReturns := fake.unStageFileReturns
	fake.recordInvocation("UnStageFile", []interface{}{arg1Copy, arg2})
	fake.unStageFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) UnStageFileCallCount() int {
	fake.unStageFileMutex.RLock()
	defer fake.unStageFileMutex.RUnlock()
	return len(fake.unStageFileArgsForCall)
}

func (fake *FakeIGit) UnStageFileCalls(stub func([]string, bool) error) {
	fake.unStageFileMutex.Lock()
	defer fake.unStageFileMutex.Unlock()
	fake.UnStageFileStub = stub
}

func (fake *FakeIGit) UnStageFileArgsForCall(i int) ([]string, bool) {
	fake.unStageFileMutex.RLock()
	defer fake.unStageFileMutex.RUnlock()
	argsForCall := fake.unStageFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) UnStageFileReturns(result1 error) {
	fake.unStageFileMutex.Lock()
	defer fake.unStageFileMutex.Unlock()
	fake.UnStageFileStub = nil
	fake.unStageFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) UnStageFileReturnsOnCall(i int, result1 error) {
	fake.unStageFileMutex.Lock()
	defer fake.unStageFileMutex.Unlock()
	fake.UnStageFileStub = nil
	if fake.unStageFileReturnsOnCall == nil {
		fake.unStageFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unStageFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) UnstageAll() error {
	fake.unstageAllMutex.Lock()
	ret, specificReturn := fake.unstageAllReturnsOnCall[len(fake.unstageAllArgsForCall)]
	fake.unstageAllArgsForCall = append(fake.unstageAllArgsForCall, struct {
	}{})
	stub := fake.UnstageAllStub
	fakeReturns := fake.unstageAllReturns
	fake.recordInvocation("UnstageAll", []interface{}{})
	fake.unstageAllMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) UnstageAllCallCount() int {
	fake.unstageAllMutex.RLock()
	defer fake.unstageAllMutex.RUnlock()
	return len(fake.unstageAllArgsForCall)
}

func (fake *FakeIGit) UnstageAllCalls(stub func() error) {
	fake.unstageAllMutex.Lock()
	defer fake.unstageAllMutex.Unlock()
	fake.UnstageAllStub = stub
}

func (fake *FakeIGit) UnstageAllReturns(result1 error) {
	fake.unstageAllMutex.Lock()
	defer fake.unstageAllMutex.Unlock()
	fake.UnstageAllStub = nil
	fake.unstageAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) UnstageAllReturnsOnCall(i int, result1 error) {
	fake.unstageAllMutex.Lock()
	defer fake.unstageAllMutex.Unlock()
	fake.UnstageAllStub = nil
	if fake.unstageAllReturnsOnCall == nil {
		fake.unstageAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unstageAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) UpdateRemoteUrl(arg1 string, arg2 string) error {
	fake.updateRemoteUrlMutex.Lock()
	ret, specificReturn := fake.updateRemoteUrlReturnsOnCall[len(fake.updateRemoteUrlArgsForCall)]
	fake.updateRemoteUrlArgsForCall = append(fake.updateRemoteUrlArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.UpdateRemoteUrlStub
	fakeReturns := fake.updateRemoteUrlReturns
	fake.recordInvocation("UpdateRemoteUrl", []interface{}{arg1, arg2})
	fake.updateRemoteUrlMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) UpdateRemoteUrlCallCount() int {
	fake.updateRemoteUrlMutex.RLock()
	defer fake.updateRemoteUrlMutex.RUnlock()
	return len(fake.updateRemoteUrlArgsForCall)
}

func (fake *FakeIGit) UpdateRemoteUrlCalls(stub func(string, string) error) {
	fake.updateRemoteUrlMutex.Lock()
	defer fake.updateRemoteUrlMutex.Unlock()
	fake.UpdateRemoteUrlStub = stub
}

func (fake *FakeIGit) UpdateRemoteUrlArgsForCall(i int) (string, string) {
	fake.updateRemoteUrlMutex.RLock()
	defer fake.updateRemoteUrlMutex.RUnlock()
	argsForCall := fake.updateRemoteUrlArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGit) UpdateRemoteUrlReturns(result1 error) {
	fake.updateRemoteUrlMutex.Lock()
	defer fake.updateRemoteUrlMutex.Unlock()
	fake.UpdateRemoteUrlStub = nil
	fake.updateRemoteUrlReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) UpdateRemoteUrlReturnsOnCall(i int, result1 error) {
	fake.updateRemoteUrlMutex.Lock()
	defer fake.updateRemoteUrlMutex.Unlock()
	fake.UpdateRemoteUrlStub = nil
	if fake.updateRemoteUrlReturnsOnCall == nil {
		fake.updateRemoteUrlReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateRemoteUrlReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) UsingGpg() bool {
	fake.usingGpgMutex.Lock()
	ret, specificReturn := fake.usingGpgReturnsOnCall[len(fake.usingGpgArgsForCall)]
	fake.usingGpgArgsForCall = append(fake.usingGpgArgsForCall, struct {
	}{})
	stub := fake.UsingGpgStub
	fakeReturns := fake.usingGpgReturns
	fake.recordInvocation("UsingGpg", []interface{}{})
	fake.usingGpgMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) UsingGpgCallCount() int {
	fake.usingGpgMutex.RLock()
	defer fake.usingGpgMutex.RUnlock()
	return len(fake.usingGpgArgsForCall)
}

func (fake *FakeIGit) UsingGpgCalls(stub func() bool) {
	fake.usingGpgMutex.Lock()
	defer fake.usingGpgMutex.Unlock()
	fake.UsingGpgStub = stub
}

func (fake *FakeIGit) UsingGpgReturns(result1 bool) {
	fake.usingGpgMutex.Lock()
	defer fake.usingGpgMutex.Unlock()
	fake.UsingGpgStub = nil
	fake.usingGpgReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) UsingGpgReturnsOnCall(i int, result1 bool) {
	fake.usingGpgMutex.Lock()
	defer fake.usingGpgMutex.Unlock()
	fake.UsingGpgStub = nil
	if fake.usingGpgReturnsOnCall == nil {
		fake.usingGpgReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.usingGpgReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) WithSpan(arg1 string) commands.IGit {
	fake.withSpanMutex.Lock()
	ret, specificReturn := fake.withSpanReturnsOnCall[len(fake.withSpanArgsForCall)]
	fake.withSpanArgsForCall = append(fake.withSpanArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WithSpanStub
	fakeReturns := fake.withSpanReturns
	fake.recordInvocation("WithSpan", []interface{}{arg1})
	fake.withSpanMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) WithSpanCallCount() int {
	fake.withSpanMutex.RLock()
	defer fake.withSpanMutex.RUnlock()
	return len(fake.withSpanArgsForCall)
}

func (fake *FakeIGit) WithSpanCalls(stub func(string) commands.IGit) {
	fake.withSpanMutex.Lock()
	defer fake.withSpanMutex.Unlock()
	fake.WithSpanStub = stub
}

func (fake *FakeIGit) WithSpanArgsForCall(i int) string {
	fake.withSpanMutex.RLock()
	defer fake.withSpanMutex.RUnlock()
	argsForCall := fake.withSpanArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) WithSpanReturns(result1 commands.IGit) {
	fake.withSpanMutex.Lock()
	defer fake.withSpanMutex.Unlock()
	fake.WithSpanStub = nil
	fake.withSpanReturns = struct {
		result1 commands.IGit
	}{result1}
}

func (fake *FakeIGit) WithSpanReturnsOnCall(i int, result1 commands.IGit) {
	fake.withSpanMutex.Lock()
	defer fake.withSpanMutex.Unlock()
	fake.WithSpanStub = nil
	if fake.withSpanReturnsOnCall == nil {
		fake.withSpanReturnsOnCall = make(map[int]struct {
			result1 commands.IGit
		})
	}
	fake.withSpanReturnsOnCall[i] = struct {
		result1 commands.IGit
	}{result1}
}

func (fake *FakeIGit) WorkingTreeState() commands.WorkingTreeState {
	fake.workingTreeStateMutex.Lock()
	ret, specificReturn := fake.workingTreeStateReturnsOnCall[len(fake.workingTreeStateArgsForCall)]
	fake.workingTreeStateArgsForCall = append(fake.workingTreeStateArgsForCall, struct {
	}{})
	stub := fake.WorkingTreeStateStub
	fakeReturns := fake.workingTreeStateReturns
	fake.recordInvocation("WorkingTreeState", []interface{}{})
	fake.workingTreeStateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) WorkingTreeStateCallCount() int {
	fake.workingTreeStateMutex.RLock()
	defer fake.workingTreeStateMutex.RUnlock()
	return len(fake.workingTreeStateArgsForCall)
}

func (fake *FakeIGit) WorkingTreeStateCalls(stub func() commands.WorkingTreeState) {
	fake.workingTreeStateMutex.Lock()
	defer fake.workingTreeStateMutex.Unlock()
	fake.WorkingTreeStateStub = stub
}

func (fake *FakeIGit) WorkingTreeStateReturns(result1 commands.WorkingTreeState) {
	fake.workingTreeStateMutex.Lock()
	defer fake.workingTreeStateMutex.Unlock()
	fake.WorkingTreeStateStub = nil
	fake.workingTreeStateReturns = struct {
		result1 commands.WorkingTreeState
	}{result1}
}

func (fake *FakeIGit) WorkingTreeStateReturnsOnCall(i int, result1 commands.WorkingTreeState) {
	fake.workingTreeStateMutex.Lock()
	defer fake.workingTreeStateMutex.Unlock()
	fake.WorkingTreeStateStub = nil
	if fake.workingTreeStateReturnsOnCall == nil {
		fake.workingTreeStateReturnsOnCall = make(map[int]struct {
			result1 commands.WorkingTreeState
		})
	}
	fake.workingTreeStateReturnsOnCall[i] = struct {
		result1 commands.WorkingTreeState
	}{result1}
}

func (fake *FakeIGit) WorktreeFileDiff(arg1 *models.File, arg2 bool, arg3 bool) string {
	fake.worktreeFileDiffMutex.Lock()
	ret, specificReturn := fake.worktreeFileDiffReturnsOnCall[len(fake.worktreeFileDiffArgsForCall)]
	fake.worktreeFileDiffArgsForCall = append(fake.worktreeFileDiffArgsForCall, struct {
		arg1 *models.File
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.WorktreeFileDiffStub
	fakeReturns := fake.worktreeFileDiffReturns
	fake.recordInvocation("WorktreeFileDiff", []interface{}{arg1, arg2, arg3})
	fake.worktreeFileDiffMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) WorktreeFileDiffCallCount() int {
	fake.worktreeFileDiffMutex.RLock()
	defer fake.worktreeFileDiffMutex.RUnlock()
	return len(fake.worktreeFileDiffArgsForCall)
}

func (fake *FakeIGit) WorktreeFileDiffCalls(stub func(*models.File, bool, bool) string) {
	fake.worktreeFileDiffMutex.Lock()
	defer fake.worktreeFileDiffMutex.Unlock()
	fake.WorktreeFileDiffStub = stub
}

func (fake *FakeIGit) WorktreeFileDiffArgsForCall(i int) (*models.File, bool, bool) {
	fake.worktreeFileDiffMutex.RLock()
	defer fake.worktreeFileDiffMutex.RUnlock()
	argsForCall := fake.worktreeFileDiffArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) WorktreeFileDiffReturns(result1 string) {
	fake.worktreeFileDiffMutex.Lock()
	defer fake.worktreeFileDiffMutex.Unlock()
	fake.WorktreeFileDiffStub = nil
	fake.worktreeFileDiffReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) WorktreeFileDiffReturnsOnCall(i int, result1 string) {
	fake.worktreeFileDiffMutex.Lock()
	defer fake.worktreeFileDiffMutex.Unlock()
	fake.WorktreeFileDiffStub = nil
	if fake.worktreeFileDiffReturnsOnCall == nil {
		fake.worktreeFileDiffReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.worktreeFileDiffReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) WorktreeFileDiffCmdObj(arg1 models.IFile, arg2 bool, arg3 bool) types.ICmdObj {
	fake.worktreeFileDiffCmdObjMutex.Lock()
	ret, specificReturn := fake.worktreeFileDiffCmdObjReturnsOnCall[len(fake.worktreeFileDiffCmdObjArgsForCall)]
	fake.worktreeFileDiffCmdObjArgsForCall = append(fake.worktreeFileDiffCmdObjArgsForCall, struct {
		arg1 models.IFile
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.WorktreeFileDiffCmdObjStub
	fakeReturns := fake.worktreeFileDiffCmdObjReturns
	fake.recordInvocation("WorktreeFileDiffCmdObj", []interface{}{arg1, arg2, arg3})
	fake.worktreeFileDiffCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) WorktreeFileDiffCmdObjCallCount() int {
	fake.worktreeFileDiffCmdObjMutex.RLock()
	defer fake.worktreeFileDiffCmdObjMutex.RUnlock()
	return len(fake.worktreeFileDiffCmdObjArgsForCall)
}

func (fake *FakeIGit) WorktreeFileDiffCmdObjCalls(stub func(models.IFile, bool, bool) types.ICmdObj) {
	fake.worktreeFileDiffCmdObjMutex.Lock()
	defer fake.worktreeFileDiffCmdObjMutex.Unlock()
	fake.WorktreeFileDiffCmdObjStub = stub
}

func (fake *FakeIGit) WorktreeFileDiffCmdObjArgsForCall(i int) (models.IFile, bool, bool) {
	fake.worktreeFileDiffCmdObjMutex.RLock()
	defer fake.worktreeFileDiffCmdObjMutex.RUnlock()
	argsForCall := fake.worktreeFileDiffCmdObjArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGit) WorktreeFileDiffCmdObjReturns(result1 types.ICmdObj) {
	fake.worktreeFileDiffCmdObjMutex.Lock()
	defer fake.worktreeFileDiffCmdObjMutex.Unlock()
	fake.WorktreeFileDiffCmdObjStub = nil
	fake.worktreeFileDiffCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) WorktreeFileDiffCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.worktreeFileDiffCmdObjMutex.Lock()
	defer fake.worktreeFileDiffCmdObjMutex.Unlock()
	fake.WorktreeFileDiffCmdObjStub = nil
	if fake.worktreeFileDiffCmdObjReturnsOnCall == nil {
		fake.worktreeFileDiffCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.worktreeFileDiffCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.abortMergeMutex.RLock()
	defer fake.abortMergeMutex.RUnlock()
	fake.abortRebaseMutex.RLock()
	defer fake.abortRebaseMutex.RUnlock()
	fake.addRemoteMutex.RLock()
	defer fake.addRemoteMutex.RUnlock()
	fake.allBranchesCmdObjMutex.RLock()
	defer fake.allBranchesCmdObjMutex.RUnlock()
	fake.amendToMutex.RLock()
	defer fake.amendToMutex.RUnlock()
	fake.applyPatchMutex.RLock()
	defer fake.applyPatchMutex.RUnlock()
	fake.beforeAndAfterFileForRenameMutex.RLock()
	defer fake.beforeAndAfterFileForRenameMutex.RUnlock()
	fake.beginInteractiveRebaseForCommitMutex.RLock()
	defer fake.beginInteractiveRebaseForCommitMutex.RUnlock()
	fake.branchesMutex.RLock()
	defer fake.branchesMutex.RUnlock()
	fake.buildGitCmdObjFromStrMutex.RLock()
	defer fake.buildGitCmdObjFromStrMutex.RUnlock()
	fake.buildShellCmdObjMutex.RLock()
	defer fake.buildShellCmdObjMutex.RUnlock()
	fake.catFileMutex.RLock()
	defer fake.catFileMutex.RUnlock()
	fake.checkRemoteBranchExistsMutex.RLock()
	defer fake.checkRemoteBranchExistsMutex.RUnlock()
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	fake.checkoutFileMutex.RLock()
	defer fake.checkoutFileMutex.RUnlock()
	fake.cherryPickCommitsMutex.RLock()
	defer fake.cherryPickCommitsMutex.RUnlock()
	fake.commitsMutex.RLock()
	defer fake.commitsMutex.RUnlock()
	fake.continueRebaseMutex.RLock()
	defer fake.continueRebaseMutex.RUnlock()
	fake.createLightweightTagMutex.RLock()
	defer fake.createLightweightTagMutex.RUnlock()
	fake.currentBranchNameMutex.RLock()
	defer fake.currentBranchNameMutex.RUnlock()
	fake.deleteBranchMutex.RLock()
	defer fake.deleteBranchMutex.RUnlock()
	fake.deletePatchesFromCommitMutex.RLock()
	defer fake.deletePatchesFromCommitMutex.RUnlock()
	fake.deleteRemoteBranchMutex.RLock()
	defer fake.deleteRemoteBranchMutex.RUnlock()
	fake.deleteTagMutex.RLock()
	defer fake.deleteTagMutex.RUnlock()
	fake.diffEndArgsMutex.RLock()
	defer fake.diffEndArgsMutex.RUnlock()
	fake.discardAllDirChangesMutex.RLock()
	defer fake.discardAllDirChangesMutex.RUnlock()
	fake.discardAllFileChangesMutex.RLock()
	defer fake.discardAllFileChangesMutex.RUnlock()
	fake.discardAnyUnstagedFileChangesMutex.RLock()
	defer fake.discardAnyUnstagedFileChangesMutex.RUnlock()
	fake.discardOldFileChangesMutex.RLock()
	defer fake.discardOldFileChangesMutex.RUnlock()
	fake.discardUnstagedDirChangesMutex.RLock()
	defer fake.discardUnstagedDirChangesMutex.RUnlock()
	fake.discardUnstagedFileChangesMutex.RLock()
	defer fake.discardUnstagedFileChangesMutex.RUnlock()
	fake.editFileCmdObjMutex.RLock()
	defer fake.editFileCmdObjMutex.RUnlock()
	fake.editRebaseTodoMutex.RLock()
	defer fake.editRebaseTodoMutex.RUnlock()
	fake.fastForwardMutex.RLock()
	defer fake.fastForwardMutex.RUnlock()
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	fake.fetchInBackgroundMutex.RLock()
	defer fake.fetchInBackgroundMutex.RUnlock()
	fake.fetchRemoteMutex.RLock()
	defer fake.fetchRemoteMutex.RUnlock()
	fake.findRemoteForBranchInConfigMutex.RLock()
	defer fake.findRemoteForBranchInConfigMutex.RUnlock()
	fake.flowFinishMutex.RLock()
	defer fake.flowFinishMutex.RUnlock()
	fake.flowStartMutex.RLock()
	defer fake.flowStartMutex.RUnlock()
	fake.generateGenericRebaseTodoMutex.RLock()
	defer fake.generateGenericRebaseTodoMutex.RUnlock()
	fake.genericAbortCmdObjMutex.RLock()
	defer fake.genericAbortCmdObjMutex.RUnlock()
	fake.genericContinueCmdObjMutex.RLock()
	defer fake.genericContinueCmdObjMutex.RUnlock()
	fake.genericMergeOrRebaseActionMutex.RLock()
	defer fake.genericMergeOrRebaseActionMutex.RUnlock()
	fake.genericMergeOrRebaseCmdObjMutex.RLock()
	defer fake.genericMergeOrRebaseCmdObjMutex.RUnlock()
	fake.getBranchGraphMutex.RLock()
	defer fake.getBranchGraphMutex.RUnlock()
	fake.getBranchGraphCmdObjMutex.RLock()
	defer fake.getBranchGraphCmdObjMutex.RUnlock()
	fake.getBranchUpstreamDifferenceCountMutex.RLock()
	defer fake.getBranchUpstreamDifferenceCountMutex.RUnlock()
	fake.getCommitDifferencesMutex.RLock()
	defer fake.getCommitDifferencesMutex.RUnlock()
	fake.getConfigValueMutex.RLock()
	defer fake.getConfigValueMutex.RUnlock()
	fake.getCurrentBranchUpstreamDifferenceCountMutex.RLock()
	defer fake.getCurrentBranchUpstreamDifferenceCountMutex.RUnlock()
	fake.getFilesInDiffMutex.RLock()
	defer fake.getFilesInDiffMutex.RUnlock()
	fake.getGitFlowRegexpConfigMutex.RLock()
	defer fake.getGitFlowRegexpConfigMutex.RUnlock()
	fake.getLogMutex.RLock()
	defer fake.getLogMutex.RUnlock()
	fake.getOSMutex.RLock()
	defer fake.getOSMutex.RUnlock()
	fake.getPagerMutex.RLock()
	defer fake.getPagerMutex.RUnlock()
	fake.getPushToCurrentMutex.RLock()
	defer fake.getPushToCurrentMutex.RUnlock()
	fake.getReflogCommitsMutex.RLock()
	defer fake.getReflogCommitsMutex.RUnlock()
	fake.getRemoteURLMutex.RLock()
	defer fake.getRemoteURLMutex.RUnlock()
	fake.getRemotesMutex.RLock()
	defer fake.getRemotesMutex.RUnlock()
	fake.getRewordCommitCmdObjMutex.RLock()
	defer fake.getRewordCommitCmdObjMutex.RUnlock()
	fake.getStashEntriesMutex.RLock()
	defer fake.getStashEntriesMutex.RUnlock()
	fake.getStatusFilesMutex.RLock()
	defer fake.getStatusFilesMutex.RUnlock()
	fake.getSubmoduleConfigsMutex.RLock()
	defer fake.getSubmoduleConfigsMutex.RUnlock()
	fake.getTagsMutex.RLock()
	defer fake.getTagsMutex.RUnlock()
	fake.getUpstreamForBranchMutex.RLock()
	defer fake.getUpstreamForBranchMutex.RUnlock()
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	fake.interactiveRebaseMutex.RLock()
	defer fake.interactiveRebaseMutex.RUnlock()
	fake.interactiveRebaseCmdObjMutex.RLock()
	defer fake.interactiveRebaseCmdObjMutex.RUnlock()
	fake.isBareRepoMutex.RLock()
	defer fake.isBareRepoMutex.RUnlock()
	fake.isHeadDetachedMutex.RLock()
	defer fake.isHeadDetachedMutex.RUnlock()
	fake.isInMergeStateMutex.RLock()
	defer fake.isInMergeStateMutex.RUnlock()
	fake.mergeMutex.RLock()
	defer fake.mergeMutex.RUnlock()
	fake.mergeOrRebaseMutex.RLock()
	defer fake.mergeOrRebaseMutex.RUnlock()
	fake.moveCommitDownMutex.RLock()
	defer fake.moveCommitDownMutex.RUnlock()
	fake.movePatchIntoIndexMutex.RLock()
	defer fake.movePatchIntoIndexMutex.RUnlock()
	fake.movePatchToSelectedCommitMutex.RLock()
	defer fake.movePatchToSelectedCommitMutex.RUnlock()
	fake.moveTodoDownMutex.RLock()
	defer fake.moveTodoDownMutex.RUnlock()
	fake.newPatchManagerMutex.RLock()
	defer fake.newPatchManagerMutex.RUnlock()
	fake.openMergeToolCmdObjMutex.RLock()
	defer fake.openMergeToolCmdObjMutex.RUnlock()
	fake.pullPatchIntoNewCommitMutex.RLock()
	defer fake.pullPatchIntoNewCommitMutex.RUnlock()
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	fake.pushTagMutex.RLock()
	defer fake.pushTagMutex.RUnlock()
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	fake.rebaseBranchMutex.RLock()
	defer fake.rebaseBranchMutex.RUnlock()
	fake.rebaseModeMutex.RLock()
	defer fake.rebaseModeMutex.RUnlock()
	fake.removeRemoteMutex.RLock()
	defer fake.removeRemoteMutex.RUnlock()
	fake.removeTrackedFilesMutex.RLock()
	defer fake.removeTrackedFilesMutex.RUnlock()
	fake.removeUntrackedDirFilesMutex.RLock()
	defer fake.removeUntrackedDirFilesMutex.RUnlock()
	fake.removeUntrackedFilesMutex.RLock()
	defer fake.removeUntrackedFilesMutex.RUnlock()
	fake.renameBranchMutex.RLock()
	defer fake.renameBranchMutex.RUnlock()
	fake.renameRemoteMutex.RLock()
	defer fake.renameRemoteMutex.RUnlock()
	fake.resetAndCleanMutex.RLock()
	defer fake.resetAndCleanMutex.RUnlock()
	fake.resetHardMutex.RLock()
	defer fake.resetHardMutex.RUnlock()
	fake.resetMixedMutex.RLock()
	defer fake.resetMixedMutex.RUnlock()
	fake.resetSoftMutex.RLock()
	defer fake.resetSoftMutex.RUnlock()
	fake.resetSubmodulesMutex.RLock()
	defer fake.resetSubmodulesMutex.RUnlock()
	fake.resetToRefMutex.RLock()
	defer fake.resetToRefMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.runGitCmdFromStrMutex.RLock()
	defer fake.runGitCmdFromStrMutex.RUnlock()
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	fake.setBranchUpstreamMutex.RLock()
	defer fake.setBranchUpstreamMutex.RUnlock()
	fake.setCredentialHandlersMutex.RLock()
	defer fake.setCredentialHandlersMutex.RUnlock()
	fake.setUpstreamBranchMutex.RLock()
	defer fake.setUpstreamBranchMutex.RUnlock()
	fake.showFileDiffMutex.RLock()
	defer fake.showFileDiffMutex.RUnlock()
	fake.showFileDiffCmdObjMutex.RLock()
	defer fake.showFileDiffCmdObjMutex.RUnlock()
	fake.showStashEntryCmdObjMutex.RLock()
	defer fake.showStashEntryCmdObjMutex.RUnlock()
	fake.skipEditorMutex.RLock()
	defer fake.skipEditorMutex.RUnlock()
	fake.squashAllAboveFixupCommitsMutex.RLock()
	defer fake.squashAllAboveFixupCommitsMutex.RUnlock()
	fake.stageAllMutex.RLock()
	defer fake.stageAllMutex.RUnlock()
	fake.stageFileMutex.RLock()
	defer fake.stageFileMutex.RUnlock()
	fake.stashDoMutex.RLock()
	defer fake.stashDoMutex.RUnlock()
	fake.stashSaveMutex.RLock()
	defer fake.stashSaveMutex.RUnlock()
	fake.stashSaveStagedChangesMutex.RLock()
	defer fake.stashSaveStagedChangesMutex.RUnlock()
	fake.submoduleAddMutex.RLock()
	defer fake.submoduleAddMutex.RUnlock()
	fake.submoduleBulkDeinitCmdObjMutex.RLock()
	defer fake.submoduleBulkDeinitCmdObjMutex.RUnlock()
	fake.submoduleBulkInitCmdObjMutex.RLock()
	defer fake.submoduleBulkInitCmdObjMutex.RUnlock()
	fake.submoduleBulkUpdateCmdObjMutex.RLock()
	defer fake.submoduleBulkUpdateCmdObjMutex.RUnlock()
	fake.submoduleDeleteMutex.RLock()
	defer fake.submoduleDeleteMutex.RUnlock()
	fake.submoduleForceBulkUpdateCmdObjMutex.RLock()
	defer fake.submoduleForceBulkUpdateCmdObjMutex.RUnlock()
	fake.submoduleInitMutex.RLock()
	defer fake.submoduleInitMutex.RUnlock()
	fake.submoduleResetMutex.RLock()
	defer fake.submoduleResetMutex.RUnlock()
	fake.submoduleStashMutex.RLock()
	defer fake.submoduleStashMutex.RUnlock()
	fake.submoduleUpdateMutex.RLock()
	defer fake.submoduleUpdateMutex.RUnlock()
	fake.submoduleUpdateUrlMutex.RLock()
	defer fake.submoduleUpdateUrlMutex.RUnlock()
	fake.unStageFileMutex.RLock()
	defer fake.unStageFileMutex.RUnlock()
	fake.unstageAllMutex.RLock()
	defer fake.unstageAllMutex.RUnlock()
	fake.updateRemoteUrlMutex.RLock()
	defer fake.updateRemoteUrlMutex.RUnlock()
	fake.usingGpgMutex.RLock()
	defer fake.usingGpgMutex.RUnlock()
	fake.withSpanMutex.RLock()
	defer fake.withSpanMutex.RUnlock()
	fake.workingTreeStateMutex.RLock()
	defer fake.workingTreeStateMutex.RUnlock()
	fake.worktreeFileDiffMutex.RLock()
	defer fake.worktreeFileDiffMutex.RUnlock()
	fake.worktreeFileDiffCmdObjMutex.RLock()
	defer fake.worktreeFileDiffCmdObjMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIGit) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.IGit = new(FakeIGit)
