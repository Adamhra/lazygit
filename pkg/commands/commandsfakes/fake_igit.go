// Code generated by counterfeiter. DO NOT EDIT.
package commandsfakes

import (
	"sync"

	"github.com/jesseduffield/lazygit/pkg/commands"
	"github.com/jesseduffield/lazygit/pkg/commands/oscommands"
	"github.com/jesseduffield/lazygit/pkg/commands/types"
	"github.com/jesseduffield/lazygit/pkg/config"
	"github.com/sirupsen/logrus"
)

type FakeIGit struct {
	BranchesStub        func() commands.IBranchesMgr
	branchesMutex       sync.RWMutex
	branchesArgsForCall []struct {
	}
	branchesReturns struct {
		result1 commands.IBranchesMgr
	}
	branchesReturnsOnCall map[int]struct {
		result1 commands.IBranchesMgr
	}
	BuildGitCmdObjFromStrStub        func(string) types.ICmdObj
	buildGitCmdObjFromStrMutex       sync.RWMutex
	buildGitCmdObjFromStrArgsForCall []struct {
		arg1 string
	}
	buildGitCmdObjFromStrReturns struct {
		result1 types.ICmdObj
	}
	buildGitCmdObjFromStrReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	BuildShellCmdObjStub        func(string) types.ICmdObj
	buildShellCmdObjMutex       sync.RWMutex
	buildShellCmdObjArgsForCall []struct {
		arg1 string
	}
	buildShellCmdObjReturns struct {
		result1 types.ICmdObj
	}
	buildShellCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	ColorArgStub        func() string
	colorArgMutex       sync.RWMutex
	colorArgArgsForCall []struct {
	}
	colorArgReturns struct {
		result1 string
	}
	colorArgReturnsOnCall map[int]struct {
		result1 string
	}
	CommitsStub        func() commands.ICommitsMgr
	commitsMutex       sync.RWMutex
	commitsArgsForCall []struct {
	}
	commitsReturns struct {
		result1 commands.ICommitsMgr
	}
	commitsReturnsOnCall map[int]struct {
		result1 commands.ICommitsMgr
	}
	DiffStub        func() commands.IDiffMgr
	diffMutex       sync.RWMutex
	diffArgsForCall []struct {
	}
	diffReturns struct {
		result1 commands.IDiffMgr
	}
	diffReturnsOnCall map[int]struct {
		result1 commands.IDiffMgr
	}
	FindRemoteForBranchInConfigStub        func(string) (string, error)
	findRemoteForBranchInConfigMutex       sync.RWMutex
	findRemoteForBranchInConfigArgsForCall []struct {
		arg1 string
	}
	findRemoteForBranchInConfigReturns struct {
		result1 string
		result2 error
	}
	findRemoteForBranchInConfigReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FlowStub        func() commands.IFlowMgr
	flowMutex       sync.RWMutex
	flowArgsForCall []struct {
	}
	flowReturns struct {
		result1 commands.IFlowMgr
	}
	flowReturnsOnCall map[int]struct {
		result1 commands.IFlowMgr
	}
	GetConfigValueStub        func(string) string
	getConfigValueMutex       sync.RWMutex
	getConfigValueArgsForCall []struct {
		arg1 string
	}
	getConfigValueReturns struct {
		result1 string
	}
	getConfigValueReturnsOnCall map[int]struct {
		result1 string
	}
	GetDebugStub        func() bool
	getDebugMutex       sync.RWMutex
	getDebugArgsForCall []struct {
	}
	getDebugReturns struct {
		result1 bool
	}
	getDebugReturnsOnCall map[int]struct {
		result1 bool
	}
	GetDotGitDirStub        func() string
	getDotGitDirMutex       sync.RWMutex
	getDotGitDirArgsForCall []struct {
	}
	getDotGitDirReturns struct {
		result1 string
	}
	getDotGitDirReturnsOnCall map[int]struct {
		result1 string
	}
	GetLogStub        func() *logrus.Entry
	getLogMutex       sync.RWMutex
	getLogArgsForCall []struct {
	}
	getLogReturns struct {
		result1 *logrus.Entry
	}
	getLogReturnsOnCall map[int]struct {
		result1 *logrus.Entry
	}
	GetOSStub        func() oscommands.IOS
	getOSMutex       sync.RWMutex
	getOSArgsForCall []struct {
	}
	getOSReturns struct {
		result1 oscommands.IOS
	}
	getOSReturnsOnCall map[int]struct {
		result1 oscommands.IOS
	}
	GetPagerStub        func(int) string
	getPagerMutex       sync.RWMutex
	getPagerArgsForCall []struct {
		arg1 int
	}
	getPagerReturns struct {
		result1 string
	}
	getPagerReturnsOnCall map[int]struct {
		result1 string
	}
	GetPushToCurrentStub        func() bool
	getPushToCurrentMutex       sync.RWMutex
	getPushToCurrentArgsForCall []struct {
	}
	getPushToCurrentReturns struct {
		result1 bool
	}
	getPushToCurrentReturnsOnCall map[int]struct {
		result1 bool
	}
	GetUserConfigStub        func() *config.UserConfig
	getUserConfigMutex       sync.RWMutex
	getUserConfigArgsForCall []struct {
	}
	getUserConfigReturns struct {
		result1 *config.UserConfig
	}
	getUserConfigReturnsOnCall map[int]struct {
		result1 *config.UserConfig
	}
	GetUserConfigDirStub        func() string
	getUserConfigDirMutex       sync.RWMutex
	getUserConfigDirArgsForCall []struct {
	}
	getUserConfigDirReturns struct {
		result1 string
	}
	getUserConfigDirReturnsOnCall map[int]struct {
		result1 string
	}
	PatchesStub        func() commands.IPatchesMgr
	patchesMutex       sync.RWMutex
	patchesArgsForCall []struct {
	}
	patchesReturns struct {
		result1 commands.IPatchesMgr
	}
	patchesReturnsOnCall map[int]struct {
		result1 commands.IPatchesMgr
	}
	QuoteStub        func(string) string
	quoteMutex       sync.RWMutex
	quoteArgsForCall []struct {
		arg1 string
	}
	quoteReturns struct {
		result1 string
	}
	quoteReturnsOnCall map[int]struct {
		result1 string
	}
	RebasingStub        func() commands.IRebasingMgr
	rebasingMutex       sync.RWMutex
	rebasingArgsForCall []struct {
	}
	rebasingReturns struct {
		result1 commands.IRebasingMgr
	}
	rebasingReturnsOnCall map[int]struct {
		result1 commands.IRebasingMgr
	}
	ReflogStub        func() commands.IReflogMgr
	reflogMutex       sync.RWMutex
	reflogArgsForCall []struct {
	}
	reflogReturns struct {
		result1 commands.IReflogMgr
	}
	reflogReturnsOnCall map[int]struct {
		result1 commands.IReflogMgr
	}
	RemotesStub        func() commands.IRemotesMgr
	remotesMutex       sync.RWMutex
	remotesArgsForCall []struct {
	}
	remotesReturns struct {
		result1 commands.IRemotesMgr
	}
	remotesReturnsOnCall map[int]struct {
		result1 commands.IRemotesMgr
	}
	RunStub        func(types.ICmdObj) error
	runMutex       sync.RWMutex
	runArgsForCall []struct {
		arg1 types.ICmdObj
	}
	runReturns struct {
		result1 error
	}
	runReturnsOnCall map[int]struct {
		result1 error
	}
	RunGitCmdFromStrStub        func(string) error
	runGitCmdFromStrMutex       sync.RWMutex
	runGitCmdFromStrArgsForCall []struct {
		arg1 string
	}
	runGitCmdFromStrReturns struct {
		result1 error
	}
	runGitCmdFromStrReturnsOnCall map[int]struct {
		result1 error
	}
	RunWithOutputStub        func(types.ICmdObj) (string, error)
	runWithOutputMutex       sync.RWMutex
	runWithOutputArgsForCall []struct {
		arg1 types.ICmdObj
	}
	runWithOutputReturns struct {
		result1 string
		result2 error
	}
	runWithOutputReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SkipEditorStub        func(types.ICmdObj)
	skipEditorMutex       sync.RWMutex
	skipEditorArgsForCall []struct {
		arg1 types.ICmdObj
	}
	StashStub        func() commands.IStashMgr
	stashMutex       sync.RWMutex
	stashArgsForCall []struct {
	}
	stashReturns struct {
		result1 commands.IStashMgr
	}
	stashReturnsOnCall map[int]struct {
		result1 commands.IStashMgr
	}
	StatusStub        func() commands.IStatusMgr
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
	}
	statusReturns struct {
		result1 commands.IStatusMgr
	}
	statusReturnsOnCall map[int]struct {
		result1 commands.IStatusMgr
	}
	SubmodulesStub        func() commands.ISubmodulesMgr
	submodulesMutex       sync.RWMutex
	submodulesArgsForCall []struct {
	}
	submodulesReturns struct {
		result1 commands.ISubmodulesMgr
	}
	submodulesReturnsOnCall map[int]struct {
		result1 commands.ISubmodulesMgr
	}
	SyncStub        func() commands.ISyncMgr
	syncMutex       sync.RWMutex
	syncArgsForCall []struct {
	}
	syncReturns struct {
		result1 commands.ISyncMgr
	}
	syncReturnsOnCall map[int]struct {
		result1 commands.ISyncMgr
	}
	TagsStub        func() commands.ITagsMgr
	tagsMutex       sync.RWMutex
	tagsArgsForCall []struct {
	}
	tagsReturns struct {
		result1 commands.ITagsMgr
	}
	tagsReturnsOnCall map[int]struct {
		result1 commands.ITagsMgr
	}
	UsingGpgStub        func() bool
	usingGpgMutex       sync.RWMutex
	usingGpgArgsForCall []struct {
	}
	usingGpgReturns struct {
		result1 bool
	}
	usingGpgReturnsOnCall map[int]struct {
		result1 bool
	}
	WithSpanStub        func(string) commands.IGit
	withSpanMutex       sync.RWMutex
	withSpanArgsForCall []struct {
		arg1 string
	}
	withSpanReturns struct {
		result1 commands.IGit
	}
	withSpanReturnsOnCall map[int]struct {
		result1 commands.IGit
	}
	WorktreeStub        func() commands.IWorktreeMgr
	worktreeMutex       sync.RWMutex
	worktreeArgsForCall []struct {
	}
	worktreeReturns struct {
		result1 commands.IWorktreeMgr
	}
	worktreeReturnsOnCall map[int]struct {
		result1 commands.IWorktreeMgr
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIGit) Branches() commands.IBranchesMgr {
	fake.branchesMutex.Lock()
	ret, specificReturn := fake.branchesReturnsOnCall[len(fake.branchesArgsForCall)]
	fake.branchesArgsForCall = append(fake.branchesArgsForCall, struct {
	}{})
	stub := fake.BranchesStub
	fakeReturns := fake.branchesReturns
	fake.recordInvocation("Branches", []interface{}{})
	fake.branchesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) BranchesCallCount() int {
	fake.branchesMutex.RLock()
	defer fake.branchesMutex.RUnlock()
	return len(fake.branchesArgsForCall)
}

func (fake *FakeIGit) BranchesCalls(stub func() commands.IBranchesMgr) {
	fake.branchesMutex.Lock()
	defer fake.branchesMutex.Unlock()
	fake.BranchesStub = stub
}

func (fake *FakeIGit) BranchesReturns(result1 commands.IBranchesMgr) {
	fake.branchesMutex.Lock()
	defer fake.branchesMutex.Unlock()
	fake.BranchesStub = nil
	fake.branchesReturns = struct {
		result1 commands.IBranchesMgr
	}{result1}
}

func (fake *FakeIGit) BranchesReturnsOnCall(i int, result1 commands.IBranchesMgr) {
	fake.branchesMutex.Lock()
	defer fake.branchesMutex.Unlock()
	fake.BranchesStub = nil
	if fake.branchesReturnsOnCall == nil {
		fake.branchesReturnsOnCall = make(map[int]struct {
			result1 commands.IBranchesMgr
		})
	}
	fake.branchesReturnsOnCall[i] = struct {
		result1 commands.IBranchesMgr
	}{result1}
}

func (fake *FakeIGit) BuildGitCmdObjFromStr(arg1 string) types.ICmdObj {
	fake.buildGitCmdObjFromStrMutex.Lock()
	ret, specificReturn := fake.buildGitCmdObjFromStrReturnsOnCall[len(fake.buildGitCmdObjFromStrArgsForCall)]
	fake.buildGitCmdObjFromStrArgsForCall = append(fake.buildGitCmdObjFromStrArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.BuildGitCmdObjFromStrStub
	fakeReturns := fake.buildGitCmdObjFromStrReturns
	fake.recordInvocation("BuildGitCmdObjFromStr", []interface{}{arg1})
	fake.buildGitCmdObjFromStrMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) BuildGitCmdObjFromStrCallCount() int {
	fake.buildGitCmdObjFromStrMutex.RLock()
	defer fake.buildGitCmdObjFromStrMutex.RUnlock()
	return len(fake.buildGitCmdObjFromStrArgsForCall)
}

func (fake *FakeIGit) BuildGitCmdObjFromStrCalls(stub func(string) types.ICmdObj) {
	fake.buildGitCmdObjFromStrMutex.Lock()
	defer fake.buildGitCmdObjFromStrMutex.Unlock()
	fake.BuildGitCmdObjFromStrStub = stub
}

func (fake *FakeIGit) BuildGitCmdObjFromStrArgsForCall(i int) string {
	fake.buildGitCmdObjFromStrMutex.RLock()
	defer fake.buildGitCmdObjFromStrMutex.RUnlock()
	argsForCall := fake.buildGitCmdObjFromStrArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) BuildGitCmdObjFromStrReturns(result1 types.ICmdObj) {
	fake.buildGitCmdObjFromStrMutex.Lock()
	defer fake.buildGitCmdObjFromStrMutex.Unlock()
	fake.BuildGitCmdObjFromStrStub = nil
	fake.buildGitCmdObjFromStrReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) BuildGitCmdObjFromStrReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.buildGitCmdObjFromStrMutex.Lock()
	defer fake.buildGitCmdObjFromStrMutex.Unlock()
	fake.BuildGitCmdObjFromStrStub = nil
	if fake.buildGitCmdObjFromStrReturnsOnCall == nil {
		fake.buildGitCmdObjFromStrReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.buildGitCmdObjFromStrReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) BuildShellCmdObj(arg1 string) types.ICmdObj {
	fake.buildShellCmdObjMutex.Lock()
	ret, specificReturn := fake.buildShellCmdObjReturnsOnCall[len(fake.buildShellCmdObjArgsForCall)]
	fake.buildShellCmdObjArgsForCall = append(fake.buildShellCmdObjArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.BuildShellCmdObjStub
	fakeReturns := fake.buildShellCmdObjReturns
	fake.recordInvocation("BuildShellCmdObj", []interface{}{arg1})
	fake.buildShellCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) BuildShellCmdObjCallCount() int {
	fake.buildShellCmdObjMutex.RLock()
	defer fake.buildShellCmdObjMutex.RUnlock()
	return len(fake.buildShellCmdObjArgsForCall)
}

func (fake *FakeIGit) BuildShellCmdObjCalls(stub func(string) types.ICmdObj) {
	fake.buildShellCmdObjMutex.Lock()
	defer fake.buildShellCmdObjMutex.Unlock()
	fake.BuildShellCmdObjStub = stub
}

func (fake *FakeIGit) BuildShellCmdObjArgsForCall(i int) string {
	fake.buildShellCmdObjMutex.RLock()
	defer fake.buildShellCmdObjMutex.RUnlock()
	argsForCall := fake.buildShellCmdObjArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) BuildShellCmdObjReturns(result1 types.ICmdObj) {
	fake.buildShellCmdObjMutex.Lock()
	defer fake.buildShellCmdObjMutex.Unlock()
	fake.BuildShellCmdObjStub = nil
	fake.buildShellCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) BuildShellCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.buildShellCmdObjMutex.Lock()
	defer fake.buildShellCmdObjMutex.Unlock()
	fake.BuildShellCmdObjStub = nil
	if fake.buildShellCmdObjReturnsOnCall == nil {
		fake.buildShellCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.buildShellCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIGit) ColorArg() string {
	fake.colorArgMutex.Lock()
	ret, specificReturn := fake.colorArgReturnsOnCall[len(fake.colorArgArgsForCall)]
	fake.colorArgArgsForCall = append(fake.colorArgArgsForCall, struct {
	}{})
	stub := fake.ColorArgStub
	fakeReturns := fake.colorArgReturns
	fake.recordInvocation("ColorArg", []interface{}{})
	fake.colorArgMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ColorArgCallCount() int {
	fake.colorArgMutex.RLock()
	defer fake.colorArgMutex.RUnlock()
	return len(fake.colorArgArgsForCall)
}

func (fake *FakeIGit) ColorArgCalls(stub func() string) {
	fake.colorArgMutex.Lock()
	defer fake.colorArgMutex.Unlock()
	fake.ColorArgStub = stub
}

func (fake *FakeIGit) ColorArgReturns(result1 string) {
	fake.colorArgMutex.Lock()
	defer fake.colorArgMutex.Unlock()
	fake.ColorArgStub = nil
	fake.colorArgReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) ColorArgReturnsOnCall(i int, result1 string) {
	fake.colorArgMutex.Lock()
	defer fake.colorArgMutex.Unlock()
	fake.ColorArgStub = nil
	if fake.colorArgReturnsOnCall == nil {
		fake.colorArgReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.colorArgReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) Commits() commands.ICommitsMgr {
	fake.commitsMutex.Lock()
	ret, specificReturn := fake.commitsReturnsOnCall[len(fake.commitsArgsForCall)]
	fake.commitsArgsForCall = append(fake.commitsArgsForCall, struct {
	}{})
	stub := fake.CommitsStub
	fakeReturns := fake.commitsReturns
	fake.recordInvocation("Commits", []interface{}{})
	fake.commitsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) CommitsCallCount() int {
	fake.commitsMutex.RLock()
	defer fake.commitsMutex.RUnlock()
	return len(fake.commitsArgsForCall)
}

func (fake *FakeIGit) CommitsCalls(stub func() commands.ICommitsMgr) {
	fake.commitsMutex.Lock()
	defer fake.commitsMutex.Unlock()
	fake.CommitsStub = stub
}

func (fake *FakeIGit) CommitsReturns(result1 commands.ICommitsMgr) {
	fake.commitsMutex.Lock()
	defer fake.commitsMutex.Unlock()
	fake.CommitsStub = nil
	fake.commitsReturns = struct {
		result1 commands.ICommitsMgr
	}{result1}
}

func (fake *FakeIGit) CommitsReturnsOnCall(i int, result1 commands.ICommitsMgr) {
	fake.commitsMutex.Lock()
	defer fake.commitsMutex.Unlock()
	fake.CommitsStub = nil
	if fake.commitsReturnsOnCall == nil {
		fake.commitsReturnsOnCall = make(map[int]struct {
			result1 commands.ICommitsMgr
		})
	}
	fake.commitsReturnsOnCall[i] = struct {
		result1 commands.ICommitsMgr
	}{result1}
}

func (fake *FakeIGit) Diff() commands.IDiffMgr {
	fake.diffMutex.Lock()
	ret, specificReturn := fake.diffReturnsOnCall[len(fake.diffArgsForCall)]
	fake.diffArgsForCall = append(fake.diffArgsForCall, struct {
	}{})
	stub := fake.DiffStub
	fakeReturns := fake.diffReturns
	fake.recordInvocation("Diff", []interface{}{})
	fake.diffMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) DiffCallCount() int {
	fake.diffMutex.RLock()
	defer fake.diffMutex.RUnlock()
	return len(fake.diffArgsForCall)
}

func (fake *FakeIGit) DiffCalls(stub func() commands.IDiffMgr) {
	fake.diffMutex.Lock()
	defer fake.diffMutex.Unlock()
	fake.DiffStub = stub
}

func (fake *FakeIGit) DiffReturns(result1 commands.IDiffMgr) {
	fake.diffMutex.Lock()
	defer fake.diffMutex.Unlock()
	fake.DiffStub = nil
	fake.diffReturns = struct {
		result1 commands.IDiffMgr
	}{result1}
}

func (fake *FakeIGit) DiffReturnsOnCall(i int, result1 commands.IDiffMgr) {
	fake.diffMutex.Lock()
	defer fake.diffMutex.Unlock()
	fake.DiffStub = nil
	if fake.diffReturnsOnCall == nil {
		fake.diffReturnsOnCall = make(map[int]struct {
			result1 commands.IDiffMgr
		})
	}
	fake.diffReturnsOnCall[i] = struct {
		result1 commands.IDiffMgr
	}{result1}
}

func (fake *FakeIGit) FindRemoteForBranchInConfig(arg1 string) (string, error) {
	fake.findRemoteForBranchInConfigMutex.Lock()
	ret, specificReturn := fake.findRemoteForBranchInConfigReturnsOnCall[len(fake.findRemoteForBranchInConfigArgsForCall)]
	fake.findRemoteForBranchInConfigArgsForCall = append(fake.findRemoteForBranchInConfigArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FindRemoteForBranchInConfigStub
	fakeReturns := fake.findRemoteForBranchInConfigReturns
	fake.recordInvocation("FindRemoteForBranchInConfig", []interface{}{arg1})
	fake.findRemoteForBranchInConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) FindRemoteForBranchInConfigCallCount() int {
	fake.findRemoteForBranchInConfigMutex.RLock()
	defer fake.findRemoteForBranchInConfigMutex.RUnlock()
	return len(fake.findRemoteForBranchInConfigArgsForCall)
}

func (fake *FakeIGit) FindRemoteForBranchInConfigCalls(stub func(string) (string, error)) {
	fake.findRemoteForBranchInConfigMutex.Lock()
	defer fake.findRemoteForBranchInConfigMutex.Unlock()
	fake.FindRemoteForBranchInConfigStub = stub
}

func (fake *FakeIGit) FindRemoteForBranchInConfigArgsForCall(i int) string {
	fake.findRemoteForBranchInConfigMutex.RLock()
	defer fake.findRemoteForBranchInConfigMutex.RUnlock()
	argsForCall := fake.findRemoteForBranchInConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) FindRemoteForBranchInConfigReturns(result1 string, result2 error) {
	fake.findRemoteForBranchInConfigMutex.Lock()
	defer fake.findRemoteForBranchInConfigMutex.Unlock()
	fake.FindRemoteForBranchInConfigStub = nil
	fake.findRemoteForBranchInConfigReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) FindRemoteForBranchInConfigReturnsOnCall(i int, result1 string, result2 error) {
	fake.findRemoteForBranchInConfigMutex.Lock()
	defer fake.findRemoteForBranchInConfigMutex.Unlock()
	fake.FindRemoteForBranchInConfigStub = nil
	if fake.findRemoteForBranchInConfigReturnsOnCall == nil {
		fake.findRemoteForBranchInConfigReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findRemoteForBranchInConfigReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) Flow() commands.IFlowMgr {
	fake.flowMutex.Lock()
	ret, specificReturn := fake.flowReturnsOnCall[len(fake.flowArgsForCall)]
	fake.flowArgsForCall = append(fake.flowArgsForCall, struct {
	}{})
	stub := fake.FlowStub
	fakeReturns := fake.flowReturns
	fake.recordInvocation("Flow", []interface{}{})
	fake.flowMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) FlowCallCount() int {
	fake.flowMutex.RLock()
	defer fake.flowMutex.RUnlock()
	return len(fake.flowArgsForCall)
}

func (fake *FakeIGit) FlowCalls(stub func() commands.IFlowMgr) {
	fake.flowMutex.Lock()
	defer fake.flowMutex.Unlock()
	fake.FlowStub = stub
}

func (fake *FakeIGit) FlowReturns(result1 commands.IFlowMgr) {
	fake.flowMutex.Lock()
	defer fake.flowMutex.Unlock()
	fake.FlowStub = nil
	fake.flowReturns = struct {
		result1 commands.IFlowMgr
	}{result1}
}

func (fake *FakeIGit) FlowReturnsOnCall(i int, result1 commands.IFlowMgr) {
	fake.flowMutex.Lock()
	defer fake.flowMutex.Unlock()
	fake.FlowStub = nil
	if fake.flowReturnsOnCall == nil {
		fake.flowReturnsOnCall = make(map[int]struct {
			result1 commands.IFlowMgr
		})
	}
	fake.flowReturnsOnCall[i] = struct {
		result1 commands.IFlowMgr
	}{result1}
}

func (fake *FakeIGit) GetConfigValue(arg1 string) string {
	fake.getConfigValueMutex.Lock()
	ret, specificReturn := fake.getConfigValueReturnsOnCall[len(fake.getConfigValueArgsForCall)]
	fake.getConfigValueArgsForCall = append(fake.getConfigValueArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetConfigValueStub
	fakeReturns := fake.getConfigValueReturns
	fake.recordInvocation("GetConfigValue", []interface{}{arg1})
	fake.getConfigValueMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetConfigValueCallCount() int {
	fake.getConfigValueMutex.RLock()
	defer fake.getConfigValueMutex.RUnlock()
	return len(fake.getConfigValueArgsForCall)
}

func (fake *FakeIGit) GetConfigValueCalls(stub func(string) string) {
	fake.getConfigValueMutex.Lock()
	defer fake.getConfigValueMutex.Unlock()
	fake.GetConfigValueStub = stub
}

func (fake *FakeIGit) GetConfigValueArgsForCall(i int) string {
	fake.getConfigValueMutex.RLock()
	defer fake.getConfigValueMutex.RUnlock()
	argsForCall := fake.getConfigValueArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) GetConfigValueReturns(result1 string) {
	fake.getConfigValueMutex.Lock()
	defer fake.getConfigValueMutex.Unlock()
	fake.GetConfigValueStub = nil
	fake.getConfigValueReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetConfigValueReturnsOnCall(i int, result1 string) {
	fake.getConfigValueMutex.Lock()
	defer fake.getConfigValueMutex.Unlock()
	fake.GetConfigValueStub = nil
	if fake.getConfigValueReturnsOnCall == nil {
		fake.getConfigValueReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getConfigValueReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetDebug() bool {
	fake.getDebugMutex.Lock()
	ret, specificReturn := fake.getDebugReturnsOnCall[len(fake.getDebugArgsForCall)]
	fake.getDebugArgsForCall = append(fake.getDebugArgsForCall, struct {
	}{})
	stub := fake.GetDebugStub
	fakeReturns := fake.getDebugReturns
	fake.recordInvocation("GetDebug", []interface{}{})
	fake.getDebugMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetDebugCallCount() int {
	fake.getDebugMutex.RLock()
	defer fake.getDebugMutex.RUnlock()
	return len(fake.getDebugArgsForCall)
}

func (fake *FakeIGit) GetDebugCalls(stub func() bool) {
	fake.getDebugMutex.Lock()
	defer fake.getDebugMutex.Unlock()
	fake.GetDebugStub = stub
}

func (fake *FakeIGit) GetDebugReturns(result1 bool) {
	fake.getDebugMutex.Lock()
	defer fake.getDebugMutex.Unlock()
	fake.GetDebugStub = nil
	fake.getDebugReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) GetDebugReturnsOnCall(i int, result1 bool) {
	fake.getDebugMutex.Lock()
	defer fake.getDebugMutex.Unlock()
	fake.GetDebugStub = nil
	if fake.getDebugReturnsOnCall == nil {
		fake.getDebugReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.getDebugReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) GetDotGitDir() string {
	fake.getDotGitDirMutex.Lock()
	ret, specificReturn := fake.getDotGitDirReturnsOnCall[len(fake.getDotGitDirArgsForCall)]
	fake.getDotGitDirArgsForCall = append(fake.getDotGitDirArgsForCall, struct {
	}{})
	stub := fake.GetDotGitDirStub
	fakeReturns := fake.getDotGitDirReturns
	fake.recordInvocation("GetDotGitDir", []interface{}{})
	fake.getDotGitDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetDotGitDirCallCount() int {
	fake.getDotGitDirMutex.RLock()
	defer fake.getDotGitDirMutex.RUnlock()
	return len(fake.getDotGitDirArgsForCall)
}

func (fake *FakeIGit) GetDotGitDirCalls(stub func() string) {
	fake.getDotGitDirMutex.Lock()
	defer fake.getDotGitDirMutex.Unlock()
	fake.GetDotGitDirStub = stub
}

func (fake *FakeIGit) GetDotGitDirReturns(result1 string) {
	fake.getDotGitDirMutex.Lock()
	defer fake.getDotGitDirMutex.Unlock()
	fake.GetDotGitDirStub = nil
	fake.getDotGitDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetDotGitDirReturnsOnCall(i int, result1 string) {
	fake.getDotGitDirMutex.Lock()
	defer fake.getDotGitDirMutex.Unlock()
	fake.GetDotGitDirStub = nil
	if fake.getDotGitDirReturnsOnCall == nil {
		fake.getDotGitDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getDotGitDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetLog() *logrus.Entry {
	fake.getLogMutex.Lock()
	ret, specificReturn := fake.getLogReturnsOnCall[len(fake.getLogArgsForCall)]
	fake.getLogArgsForCall = append(fake.getLogArgsForCall, struct {
	}{})
	stub := fake.GetLogStub
	fakeReturns := fake.getLogReturns
	fake.recordInvocation("GetLog", []interface{}{})
	fake.getLogMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetLogCallCount() int {
	fake.getLogMutex.RLock()
	defer fake.getLogMutex.RUnlock()
	return len(fake.getLogArgsForCall)
}

func (fake *FakeIGit) GetLogCalls(stub func() *logrus.Entry) {
	fake.getLogMutex.Lock()
	defer fake.getLogMutex.Unlock()
	fake.GetLogStub = stub
}

func (fake *FakeIGit) GetLogReturns(result1 *logrus.Entry) {
	fake.getLogMutex.Lock()
	defer fake.getLogMutex.Unlock()
	fake.GetLogStub = nil
	fake.getLogReturns = struct {
		result1 *logrus.Entry
	}{result1}
}

func (fake *FakeIGit) GetLogReturnsOnCall(i int, result1 *logrus.Entry) {
	fake.getLogMutex.Lock()
	defer fake.getLogMutex.Unlock()
	fake.GetLogStub = nil
	if fake.getLogReturnsOnCall == nil {
		fake.getLogReturnsOnCall = make(map[int]struct {
			result1 *logrus.Entry
		})
	}
	fake.getLogReturnsOnCall[i] = struct {
		result1 *logrus.Entry
	}{result1}
}

func (fake *FakeIGit) GetOS() oscommands.IOS {
	fake.getOSMutex.Lock()
	ret, specificReturn := fake.getOSReturnsOnCall[len(fake.getOSArgsForCall)]
	fake.getOSArgsForCall = append(fake.getOSArgsForCall, struct {
	}{})
	stub := fake.GetOSStub
	fakeReturns := fake.getOSReturns
	fake.recordInvocation("GetOS", []interface{}{})
	fake.getOSMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetOSCallCount() int {
	fake.getOSMutex.RLock()
	defer fake.getOSMutex.RUnlock()
	return len(fake.getOSArgsForCall)
}

func (fake *FakeIGit) GetOSCalls(stub func() oscommands.IOS) {
	fake.getOSMutex.Lock()
	defer fake.getOSMutex.Unlock()
	fake.GetOSStub = stub
}

func (fake *FakeIGit) GetOSReturns(result1 oscommands.IOS) {
	fake.getOSMutex.Lock()
	defer fake.getOSMutex.Unlock()
	fake.GetOSStub = nil
	fake.getOSReturns = struct {
		result1 oscommands.IOS
	}{result1}
}

func (fake *FakeIGit) GetOSReturnsOnCall(i int, result1 oscommands.IOS) {
	fake.getOSMutex.Lock()
	defer fake.getOSMutex.Unlock()
	fake.GetOSStub = nil
	if fake.getOSReturnsOnCall == nil {
		fake.getOSReturnsOnCall = make(map[int]struct {
			result1 oscommands.IOS
		})
	}
	fake.getOSReturnsOnCall[i] = struct {
		result1 oscommands.IOS
	}{result1}
}

func (fake *FakeIGit) GetPager(arg1 int) string {
	fake.getPagerMutex.Lock()
	ret, specificReturn := fake.getPagerReturnsOnCall[len(fake.getPagerArgsForCall)]
	fake.getPagerArgsForCall = append(fake.getPagerArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetPagerStub
	fakeReturns := fake.getPagerReturns
	fake.recordInvocation("GetPager", []interface{}{arg1})
	fake.getPagerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetPagerCallCount() int {
	fake.getPagerMutex.RLock()
	defer fake.getPagerMutex.RUnlock()
	return len(fake.getPagerArgsForCall)
}

func (fake *FakeIGit) GetPagerCalls(stub func(int) string) {
	fake.getPagerMutex.Lock()
	defer fake.getPagerMutex.Unlock()
	fake.GetPagerStub = stub
}

func (fake *FakeIGit) GetPagerArgsForCall(i int) int {
	fake.getPagerMutex.RLock()
	defer fake.getPagerMutex.RUnlock()
	argsForCall := fake.getPagerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) GetPagerReturns(result1 string) {
	fake.getPagerMutex.Lock()
	defer fake.getPagerMutex.Unlock()
	fake.GetPagerStub = nil
	fake.getPagerReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetPagerReturnsOnCall(i int, result1 string) {
	fake.getPagerMutex.Lock()
	defer fake.getPagerMutex.Unlock()
	fake.GetPagerStub = nil
	if fake.getPagerReturnsOnCall == nil {
		fake.getPagerReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getPagerReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetPushToCurrent() bool {
	fake.getPushToCurrentMutex.Lock()
	ret, specificReturn := fake.getPushToCurrentReturnsOnCall[len(fake.getPushToCurrentArgsForCall)]
	fake.getPushToCurrentArgsForCall = append(fake.getPushToCurrentArgsForCall, struct {
	}{})
	stub := fake.GetPushToCurrentStub
	fakeReturns := fake.getPushToCurrentReturns
	fake.recordInvocation("GetPushToCurrent", []interface{}{})
	fake.getPushToCurrentMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetPushToCurrentCallCount() int {
	fake.getPushToCurrentMutex.RLock()
	defer fake.getPushToCurrentMutex.RUnlock()
	return len(fake.getPushToCurrentArgsForCall)
}

func (fake *FakeIGit) GetPushToCurrentCalls(stub func() bool) {
	fake.getPushToCurrentMutex.Lock()
	defer fake.getPushToCurrentMutex.Unlock()
	fake.GetPushToCurrentStub = stub
}

func (fake *FakeIGit) GetPushToCurrentReturns(result1 bool) {
	fake.getPushToCurrentMutex.Lock()
	defer fake.getPushToCurrentMutex.Unlock()
	fake.GetPushToCurrentStub = nil
	fake.getPushToCurrentReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) GetPushToCurrentReturnsOnCall(i int, result1 bool) {
	fake.getPushToCurrentMutex.Lock()
	defer fake.getPushToCurrentMutex.Unlock()
	fake.GetPushToCurrentStub = nil
	if fake.getPushToCurrentReturnsOnCall == nil {
		fake.getPushToCurrentReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.getPushToCurrentReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) GetUserConfig() *config.UserConfig {
	fake.getUserConfigMutex.Lock()
	ret, specificReturn := fake.getUserConfigReturnsOnCall[len(fake.getUserConfigArgsForCall)]
	fake.getUserConfigArgsForCall = append(fake.getUserConfigArgsForCall, struct {
	}{})
	stub := fake.GetUserConfigStub
	fakeReturns := fake.getUserConfigReturns
	fake.recordInvocation("GetUserConfig", []interface{}{})
	fake.getUserConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetUserConfigCallCount() int {
	fake.getUserConfigMutex.RLock()
	defer fake.getUserConfigMutex.RUnlock()
	return len(fake.getUserConfigArgsForCall)
}

func (fake *FakeIGit) GetUserConfigCalls(stub func() *config.UserConfig) {
	fake.getUserConfigMutex.Lock()
	defer fake.getUserConfigMutex.Unlock()
	fake.GetUserConfigStub = stub
}

func (fake *FakeIGit) GetUserConfigReturns(result1 *config.UserConfig) {
	fake.getUserConfigMutex.Lock()
	defer fake.getUserConfigMutex.Unlock()
	fake.GetUserConfigStub = nil
	fake.getUserConfigReturns = struct {
		result1 *config.UserConfig
	}{result1}
}

func (fake *FakeIGit) GetUserConfigReturnsOnCall(i int, result1 *config.UserConfig) {
	fake.getUserConfigMutex.Lock()
	defer fake.getUserConfigMutex.Unlock()
	fake.GetUserConfigStub = nil
	if fake.getUserConfigReturnsOnCall == nil {
		fake.getUserConfigReturnsOnCall = make(map[int]struct {
			result1 *config.UserConfig
		})
	}
	fake.getUserConfigReturnsOnCall[i] = struct {
		result1 *config.UserConfig
	}{result1}
}

func (fake *FakeIGit) GetUserConfigDir() string {
	fake.getUserConfigDirMutex.Lock()
	ret, specificReturn := fake.getUserConfigDirReturnsOnCall[len(fake.getUserConfigDirArgsForCall)]
	fake.getUserConfigDirArgsForCall = append(fake.getUserConfigDirArgsForCall, struct {
	}{})
	stub := fake.GetUserConfigDirStub
	fakeReturns := fake.getUserConfigDirReturns
	fake.recordInvocation("GetUserConfigDir", []interface{}{})
	fake.getUserConfigDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) GetUserConfigDirCallCount() int {
	fake.getUserConfigDirMutex.RLock()
	defer fake.getUserConfigDirMutex.RUnlock()
	return len(fake.getUserConfigDirArgsForCall)
}

func (fake *FakeIGit) GetUserConfigDirCalls(stub func() string) {
	fake.getUserConfigDirMutex.Lock()
	defer fake.getUserConfigDirMutex.Unlock()
	fake.GetUserConfigDirStub = stub
}

func (fake *FakeIGit) GetUserConfigDirReturns(result1 string) {
	fake.getUserConfigDirMutex.Lock()
	defer fake.getUserConfigDirMutex.Unlock()
	fake.GetUserConfigDirStub = nil
	fake.getUserConfigDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) GetUserConfigDirReturnsOnCall(i int, result1 string) {
	fake.getUserConfigDirMutex.Lock()
	defer fake.getUserConfigDirMutex.Unlock()
	fake.GetUserConfigDirStub = nil
	if fake.getUserConfigDirReturnsOnCall == nil {
		fake.getUserConfigDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getUserConfigDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) Patches() commands.IPatchesMgr {
	fake.patchesMutex.Lock()
	ret, specificReturn := fake.patchesReturnsOnCall[len(fake.patchesArgsForCall)]
	fake.patchesArgsForCall = append(fake.patchesArgsForCall, struct {
	}{})
	stub := fake.PatchesStub
	fakeReturns := fake.patchesReturns
	fake.recordInvocation("Patches", []interface{}{})
	fake.patchesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) PatchesCallCount() int {
	fake.patchesMutex.RLock()
	defer fake.patchesMutex.RUnlock()
	return len(fake.patchesArgsForCall)
}

func (fake *FakeIGit) PatchesCalls(stub func() commands.IPatchesMgr) {
	fake.patchesMutex.Lock()
	defer fake.patchesMutex.Unlock()
	fake.PatchesStub = stub
}

func (fake *FakeIGit) PatchesReturns(result1 commands.IPatchesMgr) {
	fake.patchesMutex.Lock()
	defer fake.patchesMutex.Unlock()
	fake.PatchesStub = nil
	fake.patchesReturns = struct {
		result1 commands.IPatchesMgr
	}{result1}
}

func (fake *FakeIGit) PatchesReturnsOnCall(i int, result1 commands.IPatchesMgr) {
	fake.patchesMutex.Lock()
	defer fake.patchesMutex.Unlock()
	fake.PatchesStub = nil
	if fake.patchesReturnsOnCall == nil {
		fake.patchesReturnsOnCall = make(map[int]struct {
			result1 commands.IPatchesMgr
		})
	}
	fake.patchesReturnsOnCall[i] = struct {
		result1 commands.IPatchesMgr
	}{result1}
}

func (fake *FakeIGit) Quote(arg1 string) string {
	fake.quoteMutex.Lock()
	ret, specificReturn := fake.quoteReturnsOnCall[len(fake.quoteArgsForCall)]
	fake.quoteArgsForCall = append(fake.quoteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.QuoteStub
	fakeReturns := fake.quoteReturns
	fake.recordInvocation("Quote", []interface{}{arg1})
	fake.quoteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) QuoteCallCount() int {
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	return len(fake.quoteArgsForCall)
}

func (fake *FakeIGit) QuoteCalls(stub func(string) string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = stub
}

func (fake *FakeIGit) QuoteArgsForCall(i int) string {
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	argsForCall := fake.quoteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) QuoteReturns(result1 string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = nil
	fake.quoteReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) QuoteReturnsOnCall(i int, result1 string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = nil
	if fake.quoteReturnsOnCall == nil {
		fake.quoteReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.quoteReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIGit) Rebasing() commands.IRebasingMgr {
	fake.rebasingMutex.Lock()
	ret, specificReturn := fake.rebasingReturnsOnCall[len(fake.rebasingArgsForCall)]
	fake.rebasingArgsForCall = append(fake.rebasingArgsForCall, struct {
	}{})
	stub := fake.RebasingStub
	fakeReturns := fake.rebasingReturns
	fake.recordInvocation("Rebasing", []interface{}{})
	fake.rebasingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RebasingCallCount() int {
	fake.rebasingMutex.RLock()
	defer fake.rebasingMutex.RUnlock()
	return len(fake.rebasingArgsForCall)
}

func (fake *FakeIGit) RebasingCalls(stub func() commands.IRebasingMgr) {
	fake.rebasingMutex.Lock()
	defer fake.rebasingMutex.Unlock()
	fake.RebasingStub = stub
}

func (fake *FakeIGit) RebasingReturns(result1 commands.IRebasingMgr) {
	fake.rebasingMutex.Lock()
	defer fake.rebasingMutex.Unlock()
	fake.RebasingStub = nil
	fake.rebasingReturns = struct {
		result1 commands.IRebasingMgr
	}{result1}
}

func (fake *FakeIGit) RebasingReturnsOnCall(i int, result1 commands.IRebasingMgr) {
	fake.rebasingMutex.Lock()
	defer fake.rebasingMutex.Unlock()
	fake.RebasingStub = nil
	if fake.rebasingReturnsOnCall == nil {
		fake.rebasingReturnsOnCall = make(map[int]struct {
			result1 commands.IRebasingMgr
		})
	}
	fake.rebasingReturnsOnCall[i] = struct {
		result1 commands.IRebasingMgr
	}{result1}
}

func (fake *FakeIGit) Reflog() commands.IReflogMgr {
	fake.reflogMutex.Lock()
	ret, specificReturn := fake.reflogReturnsOnCall[len(fake.reflogArgsForCall)]
	fake.reflogArgsForCall = append(fake.reflogArgsForCall, struct {
	}{})
	stub := fake.ReflogStub
	fakeReturns := fake.reflogReturns
	fake.recordInvocation("Reflog", []interface{}{})
	fake.reflogMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) ReflogCallCount() int {
	fake.reflogMutex.RLock()
	defer fake.reflogMutex.RUnlock()
	return len(fake.reflogArgsForCall)
}

func (fake *FakeIGit) ReflogCalls(stub func() commands.IReflogMgr) {
	fake.reflogMutex.Lock()
	defer fake.reflogMutex.Unlock()
	fake.ReflogStub = stub
}

func (fake *FakeIGit) ReflogReturns(result1 commands.IReflogMgr) {
	fake.reflogMutex.Lock()
	defer fake.reflogMutex.Unlock()
	fake.ReflogStub = nil
	fake.reflogReturns = struct {
		result1 commands.IReflogMgr
	}{result1}
}

func (fake *FakeIGit) ReflogReturnsOnCall(i int, result1 commands.IReflogMgr) {
	fake.reflogMutex.Lock()
	defer fake.reflogMutex.Unlock()
	fake.ReflogStub = nil
	if fake.reflogReturnsOnCall == nil {
		fake.reflogReturnsOnCall = make(map[int]struct {
			result1 commands.IReflogMgr
		})
	}
	fake.reflogReturnsOnCall[i] = struct {
		result1 commands.IReflogMgr
	}{result1}
}

func (fake *FakeIGit) Remotes() commands.IRemotesMgr {
	fake.remotesMutex.Lock()
	ret, specificReturn := fake.remotesReturnsOnCall[len(fake.remotesArgsForCall)]
	fake.remotesArgsForCall = append(fake.remotesArgsForCall, struct {
	}{})
	stub := fake.RemotesStub
	fakeReturns := fake.remotesReturns
	fake.recordInvocation("Remotes", []interface{}{})
	fake.remotesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RemotesCallCount() int {
	fake.remotesMutex.RLock()
	defer fake.remotesMutex.RUnlock()
	return len(fake.remotesArgsForCall)
}

func (fake *FakeIGit) RemotesCalls(stub func() commands.IRemotesMgr) {
	fake.remotesMutex.Lock()
	defer fake.remotesMutex.Unlock()
	fake.RemotesStub = stub
}

func (fake *FakeIGit) RemotesReturns(result1 commands.IRemotesMgr) {
	fake.remotesMutex.Lock()
	defer fake.remotesMutex.Unlock()
	fake.RemotesStub = nil
	fake.remotesReturns = struct {
		result1 commands.IRemotesMgr
	}{result1}
}

func (fake *FakeIGit) RemotesReturnsOnCall(i int, result1 commands.IRemotesMgr) {
	fake.remotesMutex.Lock()
	defer fake.remotesMutex.Unlock()
	fake.RemotesStub = nil
	if fake.remotesReturnsOnCall == nil {
		fake.remotesReturnsOnCall = make(map[int]struct {
			result1 commands.IRemotesMgr
		})
	}
	fake.remotesReturnsOnCall[i] = struct {
		result1 commands.IRemotesMgr
	}{result1}
}

func (fake *FakeIGit) Run(arg1 types.ICmdObj) error {
	fake.runMutex.Lock()
	ret, specificReturn := fake.runReturnsOnCall[len(fake.runArgsForCall)]
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		arg1 types.ICmdObj
	}{arg1})
	stub := fake.RunStub
	fakeReturns := fake.runReturns
	fake.recordInvocation("Run", []interface{}{arg1})
	fake.runMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeIGit) RunCalls(stub func(types.ICmdObj) error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = stub
}

func (fake *FakeIGit) RunArgsForCall(i int) types.ICmdObj {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	argsForCall := fake.runArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) RunReturns(result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RunReturnsOnCall(i int, result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	if fake.runReturnsOnCall == nil {
		fake.runReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RunGitCmdFromStr(arg1 string) error {
	fake.runGitCmdFromStrMutex.Lock()
	ret, specificReturn := fake.runGitCmdFromStrReturnsOnCall[len(fake.runGitCmdFromStrArgsForCall)]
	fake.runGitCmdFromStrArgsForCall = append(fake.runGitCmdFromStrArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RunGitCmdFromStrStub
	fakeReturns := fake.runGitCmdFromStrReturns
	fake.recordInvocation("RunGitCmdFromStr", []interface{}{arg1})
	fake.runGitCmdFromStrMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) RunGitCmdFromStrCallCount() int {
	fake.runGitCmdFromStrMutex.RLock()
	defer fake.runGitCmdFromStrMutex.RUnlock()
	return len(fake.runGitCmdFromStrArgsForCall)
}

func (fake *FakeIGit) RunGitCmdFromStrCalls(stub func(string) error) {
	fake.runGitCmdFromStrMutex.Lock()
	defer fake.runGitCmdFromStrMutex.Unlock()
	fake.RunGitCmdFromStrStub = stub
}

func (fake *FakeIGit) RunGitCmdFromStrArgsForCall(i int) string {
	fake.runGitCmdFromStrMutex.RLock()
	defer fake.runGitCmdFromStrMutex.RUnlock()
	argsForCall := fake.runGitCmdFromStrArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) RunGitCmdFromStrReturns(result1 error) {
	fake.runGitCmdFromStrMutex.Lock()
	defer fake.runGitCmdFromStrMutex.Unlock()
	fake.RunGitCmdFromStrStub = nil
	fake.runGitCmdFromStrReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RunGitCmdFromStrReturnsOnCall(i int, result1 error) {
	fake.runGitCmdFromStrMutex.Lock()
	defer fake.runGitCmdFromStrMutex.Unlock()
	fake.RunGitCmdFromStrStub = nil
	if fake.runGitCmdFromStrReturnsOnCall == nil {
		fake.runGitCmdFromStrReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runGitCmdFromStrReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIGit) RunWithOutput(arg1 types.ICmdObj) (string, error) {
	fake.runWithOutputMutex.Lock()
	ret, specificReturn := fake.runWithOutputReturnsOnCall[len(fake.runWithOutputArgsForCall)]
	fake.runWithOutputArgsForCall = append(fake.runWithOutputArgsForCall, struct {
		arg1 types.ICmdObj
	}{arg1})
	stub := fake.RunWithOutputStub
	fakeReturns := fake.runWithOutputReturns
	fake.recordInvocation("RunWithOutput", []interface{}{arg1})
	fake.runWithOutputMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGit) RunWithOutputCallCount() int {
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	return len(fake.runWithOutputArgsForCall)
}

func (fake *FakeIGit) RunWithOutputCalls(stub func(types.ICmdObj) (string, error)) {
	fake.runWithOutputMutex.Lock()
	defer fake.runWithOutputMutex.Unlock()
	fake.RunWithOutputStub = stub
}

func (fake *FakeIGit) RunWithOutputArgsForCall(i int) types.ICmdObj {
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	argsForCall := fake.runWithOutputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) RunWithOutputReturns(result1 string, result2 error) {
	fake.runWithOutputMutex.Lock()
	defer fake.runWithOutputMutex.Unlock()
	fake.RunWithOutputStub = nil
	fake.runWithOutputReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) RunWithOutputReturnsOnCall(i int, result1 string, result2 error) {
	fake.runWithOutputMutex.Lock()
	defer fake.runWithOutputMutex.Unlock()
	fake.RunWithOutputStub = nil
	if fake.runWithOutputReturnsOnCall == nil {
		fake.runWithOutputReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.runWithOutputReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGit) SkipEditor(arg1 types.ICmdObj) {
	fake.skipEditorMutex.Lock()
	fake.skipEditorArgsForCall = append(fake.skipEditorArgsForCall, struct {
		arg1 types.ICmdObj
	}{arg1})
	stub := fake.SkipEditorStub
	fake.recordInvocation("SkipEditor", []interface{}{arg1})
	fake.skipEditorMutex.Unlock()
	if stub != nil {
		fake.SkipEditorStub(arg1)
	}
}

func (fake *FakeIGit) SkipEditorCallCount() int {
	fake.skipEditorMutex.RLock()
	defer fake.skipEditorMutex.RUnlock()
	return len(fake.skipEditorArgsForCall)
}

func (fake *FakeIGit) SkipEditorCalls(stub func(types.ICmdObj)) {
	fake.skipEditorMutex.Lock()
	defer fake.skipEditorMutex.Unlock()
	fake.SkipEditorStub = stub
}

func (fake *FakeIGit) SkipEditorArgsForCall(i int) types.ICmdObj {
	fake.skipEditorMutex.RLock()
	defer fake.skipEditorMutex.RUnlock()
	argsForCall := fake.skipEditorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) Stash() commands.IStashMgr {
	fake.stashMutex.Lock()
	ret, specificReturn := fake.stashReturnsOnCall[len(fake.stashArgsForCall)]
	fake.stashArgsForCall = append(fake.stashArgsForCall, struct {
	}{})
	stub := fake.StashStub
	fakeReturns := fake.stashReturns
	fake.recordInvocation("Stash", []interface{}{})
	fake.stashMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) StashCallCount() int {
	fake.stashMutex.RLock()
	defer fake.stashMutex.RUnlock()
	return len(fake.stashArgsForCall)
}

func (fake *FakeIGit) StashCalls(stub func() commands.IStashMgr) {
	fake.stashMutex.Lock()
	defer fake.stashMutex.Unlock()
	fake.StashStub = stub
}

func (fake *FakeIGit) StashReturns(result1 commands.IStashMgr) {
	fake.stashMutex.Lock()
	defer fake.stashMutex.Unlock()
	fake.StashStub = nil
	fake.stashReturns = struct {
		result1 commands.IStashMgr
	}{result1}
}

func (fake *FakeIGit) StashReturnsOnCall(i int, result1 commands.IStashMgr) {
	fake.stashMutex.Lock()
	defer fake.stashMutex.Unlock()
	fake.StashStub = nil
	if fake.stashReturnsOnCall == nil {
		fake.stashReturnsOnCall = make(map[int]struct {
			result1 commands.IStashMgr
		})
	}
	fake.stashReturnsOnCall[i] = struct {
		result1 commands.IStashMgr
	}{result1}
}

func (fake *FakeIGit) Status() commands.IStatusMgr {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
	}{})
	stub := fake.StatusStub
	fakeReturns := fake.statusReturns
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeIGit) StatusCalls(stub func() commands.IStatusMgr) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeIGit) StatusReturns(result1 commands.IStatusMgr) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 commands.IStatusMgr
	}{result1}
}

func (fake *FakeIGit) StatusReturnsOnCall(i int, result1 commands.IStatusMgr) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 commands.IStatusMgr
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 commands.IStatusMgr
	}{result1}
}

func (fake *FakeIGit) Submodules() commands.ISubmodulesMgr {
	fake.submodulesMutex.Lock()
	ret, specificReturn := fake.submodulesReturnsOnCall[len(fake.submodulesArgsForCall)]
	fake.submodulesArgsForCall = append(fake.submodulesArgsForCall, struct {
	}{})
	stub := fake.SubmodulesStub
	fakeReturns := fake.submodulesReturns
	fake.recordInvocation("Submodules", []interface{}{})
	fake.submodulesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SubmodulesCallCount() int {
	fake.submodulesMutex.RLock()
	defer fake.submodulesMutex.RUnlock()
	return len(fake.submodulesArgsForCall)
}

func (fake *FakeIGit) SubmodulesCalls(stub func() commands.ISubmodulesMgr) {
	fake.submodulesMutex.Lock()
	defer fake.submodulesMutex.Unlock()
	fake.SubmodulesStub = stub
}

func (fake *FakeIGit) SubmodulesReturns(result1 commands.ISubmodulesMgr) {
	fake.submodulesMutex.Lock()
	defer fake.submodulesMutex.Unlock()
	fake.SubmodulesStub = nil
	fake.submodulesReturns = struct {
		result1 commands.ISubmodulesMgr
	}{result1}
}

func (fake *FakeIGit) SubmodulesReturnsOnCall(i int, result1 commands.ISubmodulesMgr) {
	fake.submodulesMutex.Lock()
	defer fake.submodulesMutex.Unlock()
	fake.SubmodulesStub = nil
	if fake.submodulesReturnsOnCall == nil {
		fake.submodulesReturnsOnCall = make(map[int]struct {
			result1 commands.ISubmodulesMgr
		})
	}
	fake.submodulesReturnsOnCall[i] = struct {
		result1 commands.ISubmodulesMgr
	}{result1}
}

func (fake *FakeIGit) Sync() commands.ISyncMgr {
	fake.syncMutex.Lock()
	ret, specificReturn := fake.syncReturnsOnCall[len(fake.syncArgsForCall)]
	fake.syncArgsForCall = append(fake.syncArgsForCall, struct {
	}{})
	stub := fake.SyncStub
	fakeReturns := fake.syncReturns
	fake.recordInvocation("Sync", []interface{}{})
	fake.syncMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) SyncCallCount() int {
	fake.syncMutex.RLock()
	defer fake.syncMutex.RUnlock()
	return len(fake.syncArgsForCall)
}

func (fake *FakeIGit) SyncCalls(stub func() commands.ISyncMgr) {
	fake.syncMutex.Lock()
	defer fake.syncMutex.Unlock()
	fake.SyncStub = stub
}

func (fake *FakeIGit) SyncReturns(result1 commands.ISyncMgr) {
	fake.syncMutex.Lock()
	defer fake.syncMutex.Unlock()
	fake.SyncStub = nil
	fake.syncReturns = struct {
		result1 commands.ISyncMgr
	}{result1}
}

func (fake *FakeIGit) SyncReturnsOnCall(i int, result1 commands.ISyncMgr) {
	fake.syncMutex.Lock()
	defer fake.syncMutex.Unlock()
	fake.SyncStub = nil
	if fake.syncReturnsOnCall == nil {
		fake.syncReturnsOnCall = make(map[int]struct {
			result1 commands.ISyncMgr
		})
	}
	fake.syncReturnsOnCall[i] = struct {
		result1 commands.ISyncMgr
	}{result1}
}

func (fake *FakeIGit) Tags() commands.ITagsMgr {
	fake.tagsMutex.Lock()
	ret, specificReturn := fake.tagsReturnsOnCall[len(fake.tagsArgsForCall)]
	fake.tagsArgsForCall = append(fake.tagsArgsForCall, struct {
	}{})
	stub := fake.TagsStub
	fakeReturns := fake.tagsReturns
	fake.recordInvocation("Tags", []interface{}{})
	fake.tagsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) TagsCallCount() int {
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	return len(fake.tagsArgsForCall)
}

func (fake *FakeIGit) TagsCalls(stub func() commands.ITagsMgr) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = stub
}

func (fake *FakeIGit) TagsReturns(result1 commands.ITagsMgr) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	fake.tagsReturns = struct {
		result1 commands.ITagsMgr
	}{result1}
}

func (fake *FakeIGit) TagsReturnsOnCall(i int, result1 commands.ITagsMgr) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	if fake.tagsReturnsOnCall == nil {
		fake.tagsReturnsOnCall = make(map[int]struct {
			result1 commands.ITagsMgr
		})
	}
	fake.tagsReturnsOnCall[i] = struct {
		result1 commands.ITagsMgr
	}{result1}
}

func (fake *FakeIGit) UsingGpg() bool {
	fake.usingGpgMutex.Lock()
	ret, specificReturn := fake.usingGpgReturnsOnCall[len(fake.usingGpgArgsForCall)]
	fake.usingGpgArgsForCall = append(fake.usingGpgArgsForCall, struct {
	}{})
	stub := fake.UsingGpgStub
	fakeReturns := fake.usingGpgReturns
	fake.recordInvocation("UsingGpg", []interface{}{})
	fake.usingGpgMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) UsingGpgCallCount() int {
	fake.usingGpgMutex.RLock()
	defer fake.usingGpgMutex.RUnlock()
	return len(fake.usingGpgArgsForCall)
}

func (fake *FakeIGit) UsingGpgCalls(stub func() bool) {
	fake.usingGpgMutex.Lock()
	defer fake.usingGpgMutex.Unlock()
	fake.UsingGpgStub = stub
}

func (fake *FakeIGit) UsingGpgReturns(result1 bool) {
	fake.usingGpgMutex.Lock()
	defer fake.usingGpgMutex.Unlock()
	fake.UsingGpgStub = nil
	fake.usingGpgReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) UsingGpgReturnsOnCall(i int, result1 bool) {
	fake.usingGpgMutex.Lock()
	defer fake.usingGpgMutex.Unlock()
	fake.UsingGpgStub = nil
	if fake.usingGpgReturnsOnCall == nil {
		fake.usingGpgReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.usingGpgReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIGit) WithSpan(arg1 string) commands.IGit {
	fake.withSpanMutex.Lock()
	ret, specificReturn := fake.withSpanReturnsOnCall[len(fake.withSpanArgsForCall)]
	fake.withSpanArgsForCall = append(fake.withSpanArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WithSpanStub
	fakeReturns := fake.withSpanReturns
	fake.recordInvocation("WithSpan", []interface{}{arg1})
	fake.withSpanMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) WithSpanCallCount() int {
	fake.withSpanMutex.RLock()
	defer fake.withSpanMutex.RUnlock()
	return len(fake.withSpanArgsForCall)
}

func (fake *FakeIGit) WithSpanCalls(stub func(string) commands.IGit) {
	fake.withSpanMutex.Lock()
	defer fake.withSpanMutex.Unlock()
	fake.WithSpanStub = stub
}

func (fake *FakeIGit) WithSpanArgsForCall(i int) string {
	fake.withSpanMutex.RLock()
	defer fake.withSpanMutex.RUnlock()
	argsForCall := fake.withSpanArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIGit) WithSpanReturns(result1 commands.IGit) {
	fake.withSpanMutex.Lock()
	defer fake.withSpanMutex.Unlock()
	fake.WithSpanStub = nil
	fake.withSpanReturns = struct {
		result1 commands.IGit
	}{result1}
}

func (fake *FakeIGit) WithSpanReturnsOnCall(i int, result1 commands.IGit) {
	fake.withSpanMutex.Lock()
	defer fake.withSpanMutex.Unlock()
	fake.WithSpanStub = nil
	if fake.withSpanReturnsOnCall == nil {
		fake.withSpanReturnsOnCall = make(map[int]struct {
			result1 commands.IGit
		})
	}
	fake.withSpanReturnsOnCall[i] = struct {
		result1 commands.IGit
	}{result1}
}

func (fake *FakeIGit) Worktree() commands.IWorktreeMgr {
	fake.worktreeMutex.Lock()
	ret, specificReturn := fake.worktreeReturnsOnCall[len(fake.worktreeArgsForCall)]
	fake.worktreeArgsForCall = append(fake.worktreeArgsForCall, struct {
	}{})
	stub := fake.WorktreeStub
	fakeReturns := fake.worktreeReturns
	fake.recordInvocation("Worktree", []interface{}{})
	fake.worktreeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIGit) WorktreeCallCount() int {
	fake.worktreeMutex.RLock()
	defer fake.worktreeMutex.RUnlock()
	return len(fake.worktreeArgsForCall)
}

func (fake *FakeIGit) WorktreeCalls(stub func() commands.IWorktreeMgr) {
	fake.worktreeMutex.Lock()
	defer fake.worktreeMutex.Unlock()
	fake.WorktreeStub = stub
}

func (fake *FakeIGit) WorktreeReturns(result1 commands.IWorktreeMgr) {
	fake.worktreeMutex.Lock()
	defer fake.worktreeMutex.Unlock()
	fake.WorktreeStub = nil
	fake.worktreeReturns = struct {
		result1 commands.IWorktreeMgr
	}{result1}
}

func (fake *FakeIGit) WorktreeReturnsOnCall(i int, result1 commands.IWorktreeMgr) {
	fake.worktreeMutex.Lock()
	defer fake.worktreeMutex.Unlock()
	fake.WorktreeStub = nil
	if fake.worktreeReturnsOnCall == nil {
		fake.worktreeReturnsOnCall = make(map[int]struct {
			result1 commands.IWorktreeMgr
		})
	}
	fake.worktreeReturnsOnCall[i] = struct {
		result1 commands.IWorktreeMgr
	}{result1}
}

func (fake *FakeIGit) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.branchesMutex.RLock()
	defer fake.branchesMutex.RUnlock()
	fake.buildGitCmdObjFromStrMutex.RLock()
	defer fake.buildGitCmdObjFromStrMutex.RUnlock()
	fake.buildShellCmdObjMutex.RLock()
	defer fake.buildShellCmdObjMutex.RUnlock()
	fake.colorArgMutex.RLock()
	defer fake.colorArgMutex.RUnlock()
	fake.commitsMutex.RLock()
	defer fake.commitsMutex.RUnlock()
	fake.diffMutex.RLock()
	defer fake.diffMutex.RUnlock()
	fake.findRemoteForBranchInConfigMutex.RLock()
	defer fake.findRemoteForBranchInConfigMutex.RUnlock()
	fake.flowMutex.RLock()
	defer fake.flowMutex.RUnlock()
	fake.getConfigValueMutex.RLock()
	defer fake.getConfigValueMutex.RUnlock()
	fake.getDebugMutex.RLock()
	defer fake.getDebugMutex.RUnlock()
	fake.getDotGitDirMutex.RLock()
	defer fake.getDotGitDirMutex.RUnlock()
	fake.getLogMutex.RLock()
	defer fake.getLogMutex.RUnlock()
	fake.getOSMutex.RLock()
	defer fake.getOSMutex.RUnlock()
	fake.getPagerMutex.RLock()
	defer fake.getPagerMutex.RUnlock()
	fake.getPushToCurrentMutex.RLock()
	defer fake.getPushToCurrentMutex.RUnlock()
	fake.getUserConfigMutex.RLock()
	defer fake.getUserConfigMutex.RUnlock()
	fake.getUserConfigDirMutex.RLock()
	defer fake.getUserConfigDirMutex.RUnlock()
	fake.patchesMutex.RLock()
	defer fake.patchesMutex.RUnlock()
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	fake.rebasingMutex.RLock()
	defer fake.rebasingMutex.RUnlock()
	fake.reflogMutex.RLock()
	defer fake.reflogMutex.RUnlock()
	fake.remotesMutex.RLock()
	defer fake.remotesMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.runGitCmdFromStrMutex.RLock()
	defer fake.runGitCmdFromStrMutex.RUnlock()
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	fake.skipEditorMutex.RLock()
	defer fake.skipEditorMutex.RUnlock()
	fake.stashMutex.RLock()
	defer fake.stashMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.submodulesMutex.RLock()
	defer fake.submodulesMutex.RUnlock()
	fake.syncMutex.RLock()
	defer fake.syncMutex.RUnlock()
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	fake.usingGpgMutex.RLock()
	defer fake.usingGpgMutex.RUnlock()
	fake.withSpanMutex.RLock()
	defer fake.withSpanMutex.RUnlock()
	fake.worktreeMutex.RLock()
	defer fake.worktreeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIGit) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.IGit = new(FakeIGit)
