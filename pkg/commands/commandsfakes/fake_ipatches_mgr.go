// Code generated by counterfeiter. DO NOT EDIT.
package commandsfakes

import (
	"sync"

	"github.com/jesseduffield/lazygit/pkg/commands"
	"github.com/jesseduffield/lazygit/pkg/commands/models"
	"github.com/jesseduffield/lazygit/pkg/commands/patch"
)

type FakeIPatchesMgr struct {
	ApplyPatchStub        func(string, ...string) error
	applyPatchMutex       sync.RWMutex
	applyPatchArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	applyPatchReturns struct {
		result1 error
	}
	applyPatchReturnsOnCall map[int]struct {
		result1 error
	}
	DeletePatchesFromCommitStub        func([]*models.Commit, int, *patch.PatchManager) error
	deletePatchesFromCommitMutex       sync.RWMutex
	deletePatchesFromCommitArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
	}
	deletePatchesFromCommitReturns struct {
		result1 error
	}
	deletePatchesFromCommitReturnsOnCall map[int]struct {
		result1 error
	}
	MovePatchIntoIndexStub        func([]*models.Commit, int, *patch.PatchManager, bool) error
	movePatchIntoIndexMutex       sync.RWMutex
	movePatchIntoIndexArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
		arg4 bool
	}
	movePatchIntoIndexReturns struct {
		result1 error
	}
	movePatchIntoIndexReturnsOnCall map[int]struct {
		result1 error
	}
	MovePatchToSelectedCommitStub        func([]*models.Commit, int, int, *patch.PatchManager) error
	movePatchToSelectedCommitMutex       sync.RWMutex
	movePatchToSelectedCommitArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 int
		arg4 *patch.PatchManager
	}
	movePatchToSelectedCommitReturns struct {
		result1 error
	}
	movePatchToSelectedCommitReturnsOnCall map[int]struct {
		result1 error
	}
	NewPatchManagerStub        func() *patch.PatchManager
	newPatchManagerMutex       sync.RWMutex
	newPatchManagerArgsForCall []struct {
	}
	newPatchManagerReturns struct {
		result1 *patch.PatchManager
	}
	newPatchManagerReturnsOnCall map[int]struct {
		result1 *patch.PatchManager
	}
	PullPatchIntoNewCommitStub        func([]*models.Commit, int, *patch.PatchManager) error
	pullPatchIntoNewCommitMutex       sync.RWMutex
	pullPatchIntoNewCommitArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
	}
	pullPatchIntoNewCommitReturns struct {
		result1 error
	}
	pullPatchIntoNewCommitReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIPatchesMgr) ApplyPatch(arg1 string, arg2 ...string) error {
	fake.applyPatchMutex.Lock()
	ret, specificReturn := fake.applyPatchReturnsOnCall[len(fake.applyPatchArgsForCall)]
	fake.applyPatchArgsForCall = append(fake.applyPatchArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2})
	stub := fake.ApplyPatchStub
	fakeReturns := fake.applyPatchReturns
	fake.recordInvocation("ApplyPatch", []interface{}{arg1, arg2})
	fake.applyPatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPatchesMgr) ApplyPatchCallCount() int {
	fake.applyPatchMutex.RLock()
	defer fake.applyPatchMutex.RUnlock()
	return len(fake.applyPatchArgsForCall)
}

func (fake *FakeIPatchesMgr) ApplyPatchCalls(stub func(string, ...string) error) {
	fake.applyPatchMutex.Lock()
	defer fake.applyPatchMutex.Unlock()
	fake.ApplyPatchStub = stub
}

func (fake *FakeIPatchesMgr) ApplyPatchArgsForCall(i int) (string, []string) {
	fake.applyPatchMutex.RLock()
	defer fake.applyPatchMutex.RUnlock()
	argsForCall := fake.applyPatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPatchesMgr) ApplyPatchReturns(result1 error) {
	fake.applyPatchMutex.Lock()
	defer fake.applyPatchMutex.Unlock()
	fake.ApplyPatchStub = nil
	fake.applyPatchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPatchesMgr) ApplyPatchReturnsOnCall(i int, result1 error) {
	fake.applyPatchMutex.Lock()
	defer fake.applyPatchMutex.Unlock()
	fake.ApplyPatchStub = nil
	if fake.applyPatchReturnsOnCall == nil {
		fake.applyPatchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyPatchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPatchesMgr) DeletePatchesFromCommit(arg1 []*models.Commit, arg2 int, arg3 *patch.PatchManager) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deletePatchesFromCommitMutex.Lock()
	ret, specificReturn := fake.deletePatchesFromCommitReturnsOnCall[len(fake.deletePatchesFromCommitArgsForCall)]
	fake.deletePatchesFromCommitArgsForCall = append(fake.deletePatchesFromCommitArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
	}{arg1Copy, arg2, arg3})
	stub := fake.DeletePatchesFromCommitStub
	fakeReturns := fake.deletePatchesFromCommitReturns
	fake.recordInvocation("DeletePatchesFromCommit", []interface{}{arg1Copy, arg2, arg3})
	fake.deletePatchesFromCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPatchesMgr) DeletePatchesFromCommitCallCount() int {
	fake.deletePatchesFromCommitMutex.RLock()
	defer fake.deletePatchesFromCommitMutex.RUnlock()
	return len(fake.deletePatchesFromCommitArgsForCall)
}

func (fake *FakeIPatchesMgr) DeletePatchesFromCommitCalls(stub func([]*models.Commit, int, *patch.PatchManager) error) {
	fake.deletePatchesFromCommitMutex.Lock()
	defer fake.deletePatchesFromCommitMutex.Unlock()
	fake.DeletePatchesFromCommitStub = stub
}

func (fake *FakeIPatchesMgr) DeletePatchesFromCommitArgsForCall(i int) ([]*models.Commit, int, *patch.PatchManager) {
	fake.deletePatchesFromCommitMutex.RLock()
	defer fake.deletePatchesFromCommitMutex.RUnlock()
	argsForCall := fake.deletePatchesFromCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIPatchesMgr) DeletePatchesFromCommitReturns(result1 error) {
	fake.deletePatchesFromCommitMutex.Lock()
	defer fake.deletePatchesFromCommitMutex.Unlock()
	fake.DeletePatchesFromCommitStub = nil
	fake.deletePatchesFromCommitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPatchesMgr) DeletePatchesFromCommitReturnsOnCall(i int, result1 error) {
	fake.deletePatchesFromCommitMutex.Lock()
	defer fake.deletePatchesFromCommitMutex.Unlock()
	fake.DeletePatchesFromCommitStub = nil
	if fake.deletePatchesFromCommitReturnsOnCall == nil {
		fake.deletePatchesFromCommitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deletePatchesFromCommitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPatchesMgr) MovePatchIntoIndex(arg1 []*models.Commit, arg2 int, arg3 *patch.PatchManager, arg4 bool) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.movePatchIntoIndexMutex.Lock()
	ret, specificReturn := fake.movePatchIntoIndexReturnsOnCall[len(fake.movePatchIntoIndexArgsForCall)]
	fake.movePatchIntoIndexArgsForCall = append(fake.movePatchIntoIndexArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
		arg4 bool
	}{arg1Copy, arg2, arg3, arg4})
	stub := fake.MovePatchIntoIndexStub
	fakeReturns := fake.movePatchIntoIndexReturns
	fake.recordInvocation("MovePatchIntoIndex", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.movePatchIntoIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPatchesMgr) MovePatchIntoIndexCallCount() int {
	fake.movePatchIntoIndexMutex.RLock()
	defer fake.movePatchIntoIndexMutex.RUnlock()
	return len(fake.movePatchIntoIndexArgsForCall)
}

func (fake *FakeIPatchesMgr) MovePatchIntoIndexCalls(stub func([]*models.Commit, int, *patch.PatchManager, bool) error) {
	fake.movePatchIntoIndexMutex.Lock()
	defer fake.movePatchIntoIndexMutex.Unlock()
	fake.MovePatchIntoIndexStub = stub
}

func (fake *FakeIPatchesMgr) MovePatchIntoIndexArgsForCall(i int) ([]*models.Commit, int, *patch.PatchManager, bool) {
	fake.movePatchIntoIndexMutex.RLock()
	defer fake.movePatchIntoIndexMutex.RUnlock()
	argsForCall := fake.movePatchIntoIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIPatchesMgr) MovePatchIntoIndexReturns(result1 error) {
	fake.movePatchIntoIndexMutex.Lock()
	defer fake.movePatchIntoIndexMutex.Unlock()
	fake.MovePatchIntoIndexStub = nil
	fake.movePatchIntoIndexReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPatchesMgr) MovePatchIntoIndexReturnsOnCall(i int, result1 error) {
	fake.movePatchIntoIndexMutex.Lock()
	defer fake.movePatchIntoIndexMutex.Unlock()
	fake.MovePatchIntoIndexStub = nil
	if fake.movePatchIntoIndexReturnsOnCall == nil {
		fake.movePatchIntoIndexReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.movePatchIntoIndexReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPatchesMgr) MovePatchToSelectedCommit(arg1 []*models.Commit, arg2 int, arg3 int, arg4 *patch.PatchManager) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.movePatchToSelectedCommitMutex.Lock()
	ret, specificReturn := fake.movePatchToSelectedCommitReturnsOnCall[len(fake.movePatchToSelectedCommitArgsForCall)]
	fake.movePatchToSelectedCommitArgsForCall = append(fake.movePatchToSelectedCommitArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 int
		arg4 *patch.PatchManager
	}{arg1Copy, arg2, arg3, arg4})
	stub := fake.MovePatchToSelectedCommitStub
	fakeReturns := fake.movePatchToSelectedCommitReturns
	fake.recordInvocation("MovePatchToSelectedCommit", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.movePatchToSelectedCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPatchesMgr) MovePatchToSelectedCommitCallCount() int {
	fake.movePatchToSelectedCommitMutex.RLock()
	defer fake.movePatchToSelectedCommitMutex.RUnlock()
	return len(fake.movePatchToSelectedCommitArgsForCall)
}

func (fake *FakeIPatchesMgr) MovePatchToSelectedCommitCalls(stub func([]*models.Commit, int, int, *patch.PatchManager) error) {
	fake.movePatchToSelectedCommitMutex.Lock()
	defer fake.movePatchToSelectedCommitMutex.Unlock()
	fake.MovePatchToSelectedCommitStub = stub
}

func (fake *FakeIPatchesMgr) MovePatchToSelectedCommitArgsForCall(i int) ([]*models.Commit, int, int, *patch.PatchManager) {
	fake.movePatchToSelectedCommitMutex.RLock()
	defer fake.movePatchToSelectedCommitMutex.RUnlock()
	argsForCall := fake.movePatchToSelectedCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIPatchesMgr) MovePatchToSelectedCommitReturns(result1 error) {
	fake.movePatchToSelectedCommitMutex.Lock()
	defer fake.movePatchToSelectedCommitMutex.Unlock()
	fake.MovePatchToSelectedCommitStub = nil
	fake.movePatchToSelectedCommitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPatchesMgr) MovePatchToSelectedCommitReturnsOnCall(i int, result1 error) {
	fake.movePatchToSelectedCommitMutex.Lock()
	defer fake.movePatchToSelectedCommitMutex.Unlock()
	fake.MovePatchToSelectedCommitStub = nil
	if fake.movePatchToSelectedCommitReturnsOnCall == nil {
		fake.movePatchToSelectedCommitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.movePatchToSelectedCommitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPatchesMgr) NewPatchManager() *patch.PatchManager {
	fake.newPatchManagerMutex.Lock()
	ret, specificReturn := fake.newPatchManagerReturnsOnCall[len(fake.newPatchManagerArgsForCall)]
	fake.newPatchManagerArgsForCall = append(fake.newPatchManagerArgsForCall, struct {
	}{})
	stub := fake.NewPatchManagerStub
	fakeReturns := fake.newPatchManagerReturns
	fake.recordInvocation("NewPatchManager", []interface{}{})
	fake.newPatchManagerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPatchesMgr) NewPatchManagerCallCount() int {
	fake.newPatchManagerMutex.RLock()
	defer fake.newPatchManagerMutex.RUnlock()
	return len(fake.newPatchManagerArgsForCall)
}

func (fake *FakeIPatchesMgr) NewPatchManagerCalls(stub func() *patch.PatchManager) {
	fake.newPatchManagerMutex.Lock()
	defer fake.newPatchManagerMutex.Unlock()
	fake.NewPatchManagerStub = stub
}

func (fake *FakeIPatchesMgr) NewPatchManagerReturns(result1 *patch.PatchManager) {
	fake.newPatchManagerMutex.Lock()
	defer fake.newPatchManagerMutex.Unlock()
	fake.NewPatchManagerStub = nil
	fake.newPatchManagerReturns = struct {
		result1 *patch.PatchManager
	}{result1}
}

func (fake *FakeIPatchesMgr) NewPatchManagerReturnsOnCall(i int, result1 *patch.PatchManager) {
	fake.newPatchManagerMutex.Lock()
	defer fake.newPatchManagerMutex.Unlock()
	fake.NewPatchManagerStub = nil
	if fake.newPatchManagerReturnsOnCall == nil {
		fake.newPatchManagerReturnsOnCall = make(map[int]struct {
			result1 *patch.PatchManager
		})
	}
	fake.newPatchManagerReturnsOnCall[i] = struct {
		result1 *patch.PatchManager
	}{result1}
}

func (fake *FakeIPatchesMgr) PullPatchIntoNewCommit(arg1 []*models.Commit, arg2 int, arg3 *patch.PatchManager) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.pullPatchIntoNewCommitMutex.Lock()
	ret, specificReturn := fake.pullPatchIntoNewCommitReturnsOnCall[len(fake.pullPatchIntoNewCommitArgsForCall)]
	fake.pullPatchIntoNewCommitArgsForCall = append(fake.pullPatchIntoNewCommitArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 *patch.PatchManager
	}{arg1Copy, arg2, arg3})
	stub := fake.PullPatchIntoNewCommitStub
	fakeReturns := fake.pullPatchIntoNewCommitReturns
	fake.recordInvocation("PullPatchIntoNewCommit", []interface{}{arg1Copy, arg2, arg3})
	fake.pullPatchIntoNewCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPatchesMgr) PullPatchIntoNewCommitCallCount() int {
	fake.pullPatchIntoNewCommitMutex.RLock()
	defer fake.pullPatchIntoNewCommitMutex.RUnlock()
	return len(fake.pullPatchIntoNewCommitArgsForCall)
}

func (fake *FakeIPatchesMgr) PullPatchIntoNewCommitCalls(stub func([]*models.Commit, int, *patch.PatchManager) error) {
	fake.pullPatchIntoNewCommitMutex.Lock()
	defer fake.pullPatchIntoNewCommitMutex.Unlock()
	fake.PullPatchIntoNewCommitStub = stub
}

func (fake *FakeIPatchesMgr) PullPatchIntoNewCommitArgsForCall(i int) ([]*models.Commit, int, *patch.PatchManager) {
	fake.pullPatchIntoNewCommitMutex.RLock()
	defer fake.pullPatchIntoNewCommitMutex.RUnlock()
	argsForCall := fake.pullPatchIntoNewCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIPatchesMgr) PullPatchIntoNewCommitReturns(result1 error) {
	fake.pullPatchIntoNewCommitMutex.Lock()
	defer fake.pullPatchIntoNewCommitMutex.Unlock()
	fake.PullPatchIntoNewCommitStub = nil
	fake.pullPatchIntoNewCommitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPatchesMgr) PullPatchIntoNewCommitReturnsOnCall(i int, result1 error) {
	fake.pullPatchIntoNewCommitMutex.Lock()
	defer fake.pullPatchIntoNewCommitMutex.Unlock()
	fake.PullPatchIntoNewCommitStub = nil
	if fake.pullPatchIntoNewCommitReturnsOnCall == nil {
		fake.pullPatchIntoNewCommitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pullPatchIntoNewCommitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPatchesMgr) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.applyPatchMutex.RLock()
	defer fake.applyPatchMutex.RUnlock()
	fake.deletePatchesFromCommitMutex.RLock()
	defer fake.deletePatchesFromCommitMutex.RUnlock()
	fake.movePatchIntoIndexMutex.RLock()
	defer fake.movePatchIntoIndexMutex.RUnlock()
	fake.movePatchToSelectedCommitMutex.RLock()
	defer fake.movePatchToSelectedCommitMutex.RUnlock()
	fake.newPatchManagerMutex.RLock()
	defer fake.newPatchManagerMutex.RUnlock()
	fake.pullPatchIntoNewCommitMutex.RLock()
	defer fake.pullPatchIntoNewCommitMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIPatchesMgr) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.IPatchesMgr = new(FakeIPatchesMgr)
