// Code generated by counterfeiter. DO NOT EDIT.
package commandsfakes

import (
	"sync"

	"github.com/jesseduffield/lazygit/pkg/commands"
	"github.com/jesseduffield/lazygit/pkg/commands/models"
	"github.com/jesseduffield/lazygit/pkg/commands/types"
)

type FakeIRebasingMgr struct {
	AbortRebaseStub        func() error
	abortRebaseMutex       sync.RWMutex
	abortRebaseArgsForCall []struct {
	}
	abortRebaseReturns struct {
		result1 error
	}
	abortRebaseReturnsOnCall map[int]struct {
		result1 error
	}
	AmendToStub        func(string) error
	amendToMutex       sync.RWMutex
	amendToArgsForCall []struct {
		arg1 string
	}
	amendToReturns struct {
		result1 error
	}
	amendToReturnsOnCall map[int]struct {
		result1 error
	}
	BeginInteractiveRebaseForCommitStub        func([]*models.Commit, int) error
	beginInteractiveRebaseForCommitMutex       sync.RWMutex
	beginInteractiveRebaseForCommitArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
	}
	beginInteractiveRebaseForCommitReturns struct {
		result1 error
	}
	beginInteractiveRebaseForCommitReturnsOnCall map[int]struct {
		result1 error
	}
	CherryPickCommitsStub        func([]*models.Commit) error
	cherryPickCommitsMutex       sync.RWMutex
	cherryPickCommitsArgsForCall []struct {
		arg1 []*models.Commit
	}
	cherryPickCommitsReturns struct {
		result1 error
	}
	cherryPickCommitsReturnsOnCall map[int]struct {
		result1 error
	}
	ContinueRebaseStub        func() error
	continueRebaseMutex       sync.RWMutex
	continueRebaseArgsForCall []struct {
	}
	continueRebaseReturns struct {
		result1 error
	}
	continueRebaseReturnsOnCall map[int]struct {
		result1 error
	}
	DiscardOldFileChangesStub        func([]*models.Commit, int, string) error
	discardOldFileChangesMutex       sync.RWMutex
	discardOldFileChangesArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}
	discardOldFileChangesReturns struct {
		result1 error
	}
	discardOldFileChangesReturnsOnCall map[int]struct {
		result1 error
	}
	EditRebaseTodoStub        func(int, string) error
	editRebaseTodoMutex       sync.RWMutex
	editRebaseTodoArgsForCall []struct {
		arg1 int
		arg2 string
	}
	editRebaseTodoReturns struct {
		result1 error
	}
	editRebaseTodoReturnsOnCall map[int]struct {
		result1 error
	}
	GenerateGenericRebaseTodoStub        func([]*models.Commit, int, string) (string, string, error)
	generateGenericRebaseTodoMutex       sync.RWMutex
	generateGenericRebaseTodoArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}
	generateGenericRebaseTodoReturns struct {
		result1 string
		result2 string
		result3 error
	}
	generateGenericRebaseTodoReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	GenericAbortCmdObjStub        func() types.ICmdObj
	genericAbortCmdObjMutex       sync.RWMutex
	genericAbortCmdObjArgsForCall []struct {
	}
	genericAbortCmdObjReturns struct {
		result1 types.ICmdObj
	}
	genericAbortCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	GenericContinueCmdObjStub        func() types.ICmdObj
	genericContinueCmdObjMutex       sync.RWMutex
	genericContinueCmdObjArgsForCall []struct {
	}
	genericContinueCmdObjReturns struct {
		result1 types.ICmdObj
	}
	genericContinueCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	GenericMergeOrRebaseActionStub        func(string, string) error
	genericMergeOrRebaseActionMutex       sync.RWMutex
	genericMergeOrRebaseActionArgsForCall []struct {
		arg1 string
		arg2 string
	}
	genericMergeOrRebaseActionReturns struct {
		result1 error
	}
	genericMergeOrRebaseActionReturnsOnCall map[int]struct {
		result1 error
	}
	GenericMergeOrRebaseCmdObjStub        func(string) types.ICmdObj
	genericMergeOrRebaseCmdObjMutex       sync.RWMutex
	genericMergeOrRebaseCmdObjArgsForCall []struct {
		arg1 string
	}
	genericMergeOrRebaseCmdObjReturns struct {
		result1 types.ICmdObj
	}
	genericMergeOrRebaseCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	GetRewordCommitCmdObjStub        func([]*models.Commit, int) (types.ICmdObj, error)
	getRewordCommitCmdObjMutex       sync.RWMutex
	getRewordCommitCmdObjArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
	}
	getRewordCommitCmdObjReturns struct {
		result1 types.ICmdObj
		result2 error
	}
	getRewordCommitCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
		result2 error
	}
	GetWorkflowStub        func() *commands.RebaseWorkflow
	getWorkflowMutex       sync.RWMutex
	getWorkflowArgsForCall []struct {
	}
	getWorkflowReturns struct {
		result1 *commands.RebaseWorkflow
	}
	getWorkflowReturnsOnCall map[int]struct {
		result1 *commands.RebaseWorkflow
	}
	InteractiveRebaseStub        func([]*models.Commit, int, string) error
	interactiveRebaseMutex       sync.RWMutex
	interactiveRebaseArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}
	interactiveRebaseReturns struct {
		result1 error
	}
	interactiveRebaseReturnsOnCall map[int]struct {
		result1 error
	}
	InteractiveRebaseCmdObjStub        func(string, string, bool) types.ICmdObj
	interactiveRebaseCmdObjMutex       sync.RWMutex
	interactiveRebaseCmdObjArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
	}
	interactiveRebaseCmdObjReturns struct {
		result1 types.ICmdObj
	}
	interactiveRebaseCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	MergeOrRebaseStub        func() string
	mergeOrRebaseMutex       sync.RWMutex
	mergeOrRebaseArgsForCall []struct {
	}
	mergeOrRebaseReturns struct {
		result1 string
	}
	mergeOrRebaseReturnsOnCall map[int]struct {
		result1 string
	}
	MoveCommitDownStub        func([]*models.Commit, int) error
	moveCommitDownMutex       sync.RWMutex
	moveCommitDownArgsForCall []struct {
		arg1 []*models.Commit
		arg2 int
	}
	moveCommitDownReturns struct {
		result1 error
	}
	moveCommitDownReturnsOnCall map[int]struct {
		result1 error
	}
	MoveTodoDownStub        func(int) error
	moveTodoDownMutex       sync.RWMutex
	moveTodoDownArgsForCall []struct {
		arg1 int
	}
	moveTodoDownReturns struct {
		result1 error
	}
	moveTodoDownReturnsOnCall map[int]struct {
		result1 error
	}
	RebaseBranchStub        func(string) error
	rebaseBranchMutex       sync.RWMutex
	rebaseBranchArgsForCall []struct {
		arg1 string
	}
	rebaseBranchReturns struct {
		result1 error
	}
	rebaseBranchReturnsOnCall map[int]struct {
		result1 error
	}
	SquashAllAboveFixupCommitsStub        func(string) error
	squashAllAboveFixupCommitsMutex       sync.RWMutex
	squashAllAboveFixupCommitsArgsForCall []struct {
		arg1 string
	}
	squashAllAboveFixupCommitsReturns struct {
		result1 error
	}
	squashAllAboveFixupCommitsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIRebasingMgr) AbortRebase() error {
	fake.abortRebaseMutex.Lock()
	ret, specificReturn := fake.abortRebaseReturnsOnCall[len(fake.abortRebaseArgsForCall)]
	fake.abortRebaseArgsForCall = append(fake.abortRebaseArgsForCall, struct {
	}{})
	stub := fake.AbortRebaseStub
	fakeReturns := fake.abortRebaseReturns
	fake.recordInvocation("AbortRebase", []interface{}{})
	fake.abortRebaseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) AbortRebaseCallCount() int {
	fake.abortRebaseMutex.RLock()
	defer fake.abortRebaseMutex.RUnlock()
	return len(fake.abortRebaseArgsForCall)
}

func (fake *FakeIRebasingMgr) AbortRebaseCalls(stub func() error) {
	fake.abortRebaseMutex.Lock()
	defer fake.abortRebaseMutex.Unlock()
	fake.AbortRebaseStub = stub
}

func (fake *FakeIRebasingMgr) AbortRebaseReturns(result1 error) {
	fake.abortRebaseMutex.Lock()
	defer fake.abortRebaseMutex.Unlock()
	fake.AbortRebaseStub = nil
	fake.abortRebaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) AbortRebaseReturnsOnCall(i int, result1 error) {
	fake.abortRebaseMutex.Lock()
	defer fake.abortRebaseMutex.Unlock()
	fake.AbortRebaseStub = nil
	if fake.abortRebaseReturnsOnCall == nil {
		fake.abortRebaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.abortRebaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) AmendTo(arg1 string) error {
	fake.amendToMutex.Lock()
	ret, specificReturn := fake.amendToReturnsOnCall[len(fake.amendToArgsForCall)]
	fake.amendToArgsForCall = append(fake.amendToArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AmendToStub
	fakeReturns := fake.amendToReturns
	fake.recordInvocation("AmendTo", []interface{}{arg1})
	fake.amendToMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) AmendToCallCount() int {
	fake.amendToMutex.RLock()
	defer fake.amendToMutex.RUnlock()
	return len(fake.amendToArgsForCall)
}

func (fake *FakeIRebasingMgr) AmendToCalls(stub func(string) error) {
	fake.amendToMutex.Lock()
	defer fake.amendToMutex.Unlock()
	fake.AmendToStub = stub
}

func (fake *FakeIRebasingMgr) AmendToArgsForCall(i int) string {
	fake.amendToMutex.RLock()
	defer fake.amendToMutex.RUnlock()
	argsForCall := fake.amendToArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIRebasingMgr) AmendToReturns(result1 error) {
	fake.amendToMutex.Lock()
	defer fake.amendToMutex.Unlock()
	fake.AmendToStub = nil
	fake.amendToReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) AmendToReturnsOnCall(i int, result1 error) {
	fake.amendToMutex.Lock()
	defer fake.amendToMutex.Unlock()
	fake.AmendToStub = nil
	if fake.amendToReturnsOnCall == nil {
		fake.amendToReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.amendToReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) BeginInteractiveRebaseForCommit(arg1 []*models.Commit, arg2 int) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.beginInteractiveRebaseForCommitMutex.Lock()
	ret, specificReturn := fake.beginInteractiveRebaseForCommitReturnsOnCall[len(fake.beginInteractiveRebaseForCommitArgsForCall)]
	fake.beginInteractiveRebaseForCommitArgsForCall = append(fake.beginInteractiveRebaseForCommitArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
	}{arg1Copy, arg2})
	stub := fake.BeginInteractiveRebaseForCommitStub
	fakeReturns := fake.beginInteractiveRebaseForCommitReturns
	fake.recordInvocation("BeginInteractiveRebaseForCommit", []interface{}{arg1Copy, arg2})
	fake.beginInteractiveRebaseForCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) BeginInteractiveRebaseForCommitCallCount() int {
	fake.beginInteractiveRebaseForCommitMutex.RLock()
	defer fake.beginInteractiveRebaseForCommitMutex.RUnlock()
	return len(fake.beginInteractiveRebaseForCommitArgsForCall)
}

func (fake *FakeIRebasingMgr) BeginInteractiveRebaseForCommitCalls(stub func([]*models.Commit, int) error) {
	fake.beginInteractiveRebaseForCommitMutex.Lock()
	defer fake.beginInteractiveRebaseForCommitMutex.Unlock()
	fake.BeginInteractiveRebaseForCommitStub = stub
}

func (fake *FakeIRebasingMgr) BeginInteractiveRebaseForCommitArgsForCall(i int) ([]*models.Commit, int) {
	fake.beginInteractiveRebaseForCommitMutex.RLock()
	defer fake.beginInteractiveRebaseForCommitMutex.RUnlock()
	argsForCall := fake.beginInteractiveRebaseForCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIRebasingMgr) BeginInteractiveRebaseForCommitReturns(result1 error) {
	fake.beginInteractiveRebaseForCommitMutex.Lock()
	defer fake.beginInteractiveRebaseForCommitMutex.Unlock()
	fake.BeginInteractiveRebaseForCommitStub = nil
	fake.beginInteractiveRebaseForCommitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) BeginInteractiveRebaseForCommitReturnsOnCall(i int, result1 error) {
	fake.beginInteractiveRebaseForCommitMutex.Lock()
	defer fake.beginInteractiveRebaseForCommitMutex.Unlock()
	fake.BeginInteractiveRebaseForCommitStub = nil
	if fake.beginInteractiveRebaseForCommitReturnsOnCall == nil {
		fake.beginInteractiveRebaseForCommitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.beginInteractiveRebaseForCommitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) CherryPickCommits(arg1 []*models.Commit) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.cherryPickCommitsMutex.Lock()
	ret, specificReturn := fake.cherryPickCommitsReturnsOnCall[len(fake.cherryPickCommitsArgsForCall)]
	fake.cherryPickCommitsArgsForCall = append(fake.cherryPickCommitsArgsForCall, struct {
		arg1 []*models.Commit
	}{arg1Copy})
	stub := fake.CherryPickCommitsStub
	fakeReturns := fake.cherryPickCommitsReturns
	fake.recordInvocation("CherryPickCommits", []interface{}{arg1Copy})
	fake.cherryPickCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) CherryPickCommitsCallCount() int {
	fake.cherryPickCommitsMutex.RLock()
	defer fake.cherryPickCommitsMutex.RUnlock()
	return len(fake.cherryPickCommitsArgsForCall)
}

func (fake *FakeIRebasingMgr) CherryPickCommitsCalls(stub func([]*models.Commit) error) {
	fake.cherryPickCommitsMutex.Lock()
	defer fake.cherryPickCommitsMutex.Unlock()
	fake.CherryPickCommitsStub = stub
}

func (fake *FakeIRebasingMgr) CherryPickCommitsArgsForCall(i int) []*models.Commit {
	fake.cherryPickCommitsMutex.RLock()
	defer fake.cherryPickCommitsMutex.RUnlock()
	argsForCall := fake.cherryPickCommitsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIRebasingMgr) CherryPickCommitsReturns(result1 error) {
	fake.cherryPickCommitsMutex.Lock()
	defer fake.cherryPickCommitsMutex.Unlock()
	fake.CherryPickCommitsStub = nil
	fake.cherryPickCommitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) CherryPickCommitsReturnsOnCall(i int, result1 error) {
	fake.cherryPickCommitsMutex.Lock()
	defer fake.cherryPickCommitsMutex.Unlock()
	fake.CherryPickCommitsStub = nil
	if fake.cherryPickCommitsReturnsOnCall == nil {
		fake.cherryPickCommitsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cherryPickCommitsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) ContinueRebase() error {
	fake.continueRebaseMutex.Lock()
	ret, specificReturn := fake.continueRebaseReturnsOnCall[len(fake.continueRebaseArgsForCall)]
	fake.continueRebaseArgsForCall = append(fake.continueRebaseArgsForCall, struct {
	}{})
	stub := fake.ContinueRebaseStub
	fakeReturns := fake.continueRebaseReturns
	fake.recordInvocation("ContinueRebase", []interface{}{})
	fake.continueRebaseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) ContinueRebaseCallCount() int {
	fake.continueRebaseMutex.RLock()
	defer fake.continueRebaseMutex.RUnlock()
	return len(fake.continueRebaseArgsForCall)
}

func (fake *FakeIRebasingMgr) ContinueRebaseCalls(stub func() error) {
	fake.continueRebaseMutex.Lock()
	defer fake.continueRebaseMutex.Unlock()
	fake.ContinueRebaseStub = stub
}

func (fake *FakeIRebasingMgr) ContinueRebaseReturns(result1 error) {
	fake.continueRebaseMutex.Lock()
	defer fake.continueRebaseMutex.Unlock()
	fake.ContinueRebaseStub = nil
	fake.continueRebaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) ContinueRebaseReturnsOnCall(i int, result1 error) {
	fake.continueRebaseMutex.Lock()
	defer fake.continueRebaseMutex.Unlock()
	fake.ContinueRebaseStub = nil
	if fake.continueRebaseReturnsOnCall == nil {
		fake.continueRebaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.continueRebaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) DiscardOldFileChanges(arg1 []*models.Commit, arg2 int, arg3 string) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.discardOldFileChangesMutex.Lock()
	ret, specificReturn := fake.discardOldFileChangesReturnsOnCall[len(fake.discardOldFileChangesArgsForCall)]
	fake.discardOldFileChangesArgsForCall = append(fake.discardOldFileChangesArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}{arg1Copy, arg2, arg3})
	stub := fake.DiscardOldFileChangesStub
	fakeReturns := fake.discardOldFileChangesReturns
	fake.recordInvocation("DiscardOldFileChanges", []interface{}{arg1Copy, arg2, arg3})
	fake.discardOldFileChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) DiscardOldFileChangesCallCount() int {
	fake.discardOldFileChangesMutex.RLock()
	defer fake.discardOldFileChangesMutex.RUnlock()
	return len(fake.discardOldFileChangesArgsForCall)
}

func (fake *FakeIRebasingMgr) DiscardOldFileChangesCalls(stub func([]*models.Commit, int, string) error) {
	fake.discardOldFileChangesMutex.Lock()
	defer fake.discardOldFileChangesMutex.Unlock()
	fake.DiscardOldFileChangesStub = stub
}

func (fake *FakeIRebasingMgr) DiscardOldFileChangesArgsForCall(i int) ([]*models.Commit, int, string) {
	fake.discardOldFileChangesMutex.RLock()
	defer fake.discardOldFileChangesMutex.RUnlock()
	argsForCall := fake.discardOldFileChangesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIRebasingMgr) DiscardOldFileChangesReturns(result1 error) {
	fake.discardOldFileChangesMutex.Lock()
	defer fake.discardOldFileChangesMutex.Unlock()
	fake.DiscardOldFileChangesStub = nil
	fake.discardOldFileChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) DiscardOldFileChangesReturnsOnCall(i int, result1 error) {
	fake.discardOldFileChangesMutex.Lock()
	defer fake.discardOldFileChangesMutex.Unlock()
	fake.DiscardOldFileChangesStub = nil
	if fake.discardOldFileChangesReturnsOnCall == nil {
		fake.discardOldFileChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardOldFileChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) EditRebaseTodo(arg1 int, arg2 string) error {
	fake.editRebaseTodoMutex.Lock()
	ret, specificReturn := fake.editRebaseTodoReturnsOnCall[len(fake.editRebaseTodoArgsForCall)]
	fake.editRebaseTodoArgsForCall = append(fake.editRebaseTodoArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.EditRebaseTodoStub
	fakeReturns := fake.editRebaseTodoReturns
	fake.recordInvocation("EditRebaseTodo", []interface{}{arg1, arg2})
	fake.editRebaseTodoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) EditRebaseTodoCallCount() int {
	fake.editRebaseTodoMutex.RLock()
	defer fake.editRebaseTodoMutex.RUnlock()
	return len(fake.editRebaseTodoArgsForCall)
}

func (fake *FakeIRebasingMgr) EditRebaseTodoCalls(stub func(int, string) error) {
	fake.editRebaseTodoMutex.Lock()
	defer fake.editRebaseTodoMutex.Unlock()
	fake.EditRebaseTodoStub = stub
}

func (fake *FakeIRebasingMgr) EditRebaseTodoArgsForCall(i int) (int, string) {
	fake.editRebaseTodoMutex.RLock()
	defer fake.editRebaseTodoMutex.RUnlock()
	argsForCall := fake.editRebaseTodoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIRebasingMgr) EditRebaseTodoReturns(result1 error) {
	fake.editRebaseTodoMutex.Lock()
	defer fake.editRebaseTodoMutex.Unlock()
	fake.EditRebaseTodoStub = nil
	fake.editRebaseTodoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) EditRebaseTodoReturnsOnCall(i int, result1 error) {
	fake.editRebaseTodoMutex.Lock()
	defer fake.editRebaseTodoMutex.Unlock()
	fake.EditRebaseTodoStub = nil
	if fake.editRebaseTodoReturnsOnCall == nil {
		fake.editRebaseTodoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editRebaseTodoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) GenerateGenericRebaseTodo(arg1 []*models.Commit, arg2 int, arg3 string) (string, string, error) {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.generateGenericRebaseTodoMutex.Lock()
	ret, specificReturn := fake.generateGenericRebaseTodoReturnsOnCall[len(fake.generateGenericRebaseTodoArgsForCall)]
	fake.generateGenericRebaseTodoArgsForCall = append(fake.generateGenericRebaseTodoArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}{arg1Copy, arg2, arg3})
	stub := fake.GenerateGenericRebaseTodoStub
	fakeReturns := fake.generateGenericRebaseTodoReturns
	fake.recordInvocation("GenerateGenericRebaseTodo", []interface{}{arg1Copy, arg2, arg3})
	fake.generateGenericRebaseTodoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIRebasingMgr) GenerateGenericRebaseTodoCallCount() int {
	fake.generateGenericRebaseTodoMutex.RLock()
	defer fake.generateGenericRebaseTodoMutex.RUnlock()
	return len(fake.generateGenericRebaseTodoArgsForCall)
}

func (fake *FakeIRebasingMgr) GenerateGenericRebaseTodoCalls(stub func([]*models.Commit, int, string) (string, string, error)) {
	fake.generateGenericRebaseTodoMutex.Lock()
	defer fake.generateGenericRebaseTodoMutex.Unlock()
	fake.GenerateGenericRebaseTodoStub = stub
}

func (fake *FakeIRebasingMgr) GenerateGenericRebaseTodoArgsForCall(i int) ([]*models.Commit, int, string) {
	fake.generateGenericRebaseTodoMutex.RLock()
	defer fake.generateGenericRebaseTodoMutex.RUnlock()
	argsForCall := fake.generateGenericRebaseTodoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIRebasingMgr) GenerateGenericRebaseTodoReturns(result1 string, result2 string, result3 error) {
	fake.generateGenericRebaseTodoMutex.Lock()
	defer fake.generateGenericRebaseTodoMutex.Unlock()
	fake.GenerateGenericRebaseTodoStub = nil
	fake.generateGenericRebaseTodoReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIRebasingMgr) GenerateGenericRebaseTodoReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.generateGenericRebaseTodoMutex.Lock()
	defer fake.generateGenericRebaseTodoMutex.Unlock()
	fake.GenerateGenericRebaseTodoStub = nil
	if fake.generateGenericRebaseTodoReturnsOnCall == nil {
		fake.generateGenericRebaseTodoReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.generateGenericRebaseTodoReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIRebasingMgr) GenericAbortCmdObj() types.ICmdObj {
	fake.genericAbortCmdObjMutex.Lock()
	ret, specificReturn := fake.genericAbortCmdObjReturnsOnCall[len(fake.genericAbortCmdObjArgsForCall)]
	fake.genericAbortCmdObjArgsForCall = append(fake.genericAbortCmdObjArgsForCall, struct {
	}{})
	stub := fake.GenericAbortCmdObjStub
	fakeReturns := fake.genericAbortCmdObjReturns
	fake.recordInvocation("GenericAbortCmdObj", []interface{}{})
	fake.genericAbortCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) GenericAbortCmdObjCallCount() int {
	fake.genericAbortCmdObjMutex.RLock()
	defer fake.genericAbortCmdObjMutex.RUnlock()
	return len(fake.genericAbortCmdObjArgsForCall)
}

func (fake *FakeIRebasingMgr) GenericAbortCmdObjCalls(stub func() types.ICmdObj) {
	fake.genericAbortCmdObjMutex.Lock()
	defer fake.genericAbortCmdObjMutex.Unlock()
	fake.GenericAbortCmdObjStub = stub
}

func (fake *FakeIRebasingMgr) GenericAbortCmdObjReturns(result1 types.ICmdObj) {
	fake.genericAbortCmdObjMutex.Lock()
	defer fake.genericAbortCmdObjMutex.Unlock()
	fake.GenericAbortCmdObjStub = nil
	fake.genericAbortCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIRebasingMgr) GenericAbortCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.genericAbortCmdObjMutex.Lock()
	defer fake.genericAbortCmdObjMutex.Unlock()
	fake.GenericAbortCmdObjStub = nil
	if fake.genericAbortCmdObjReturnsOnCall == nil {
		fake.genericAbortCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.genericAbortCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIRebasingMgr) GenericContinueCmdObj() types.ICmdObj {
	fake.genericContinueCmdObjMutex.Lock()
	ret, specificReturn := fake.genericContinueCmdObjReturnsOnCall[len(fake.genericContinueCmdObjArgsForCall)]
	fake.genericContinueCmdObjArgsForCall = append(fake.genericContinueCmdObjArgsForCall, struct {
	}{})
	stub := fake.GenericContinueCmdObjStub
	fakeReturns := fake.genericContinueCmdObjReturns
	fake.recordInvocation("GenericContinueCmdObj", []interface{}{})
	fake.genericContinueCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) GenericContinueCmdObjCallCount() int {
	fake.genericContinueCmdObjMutex.RLock()
	defer fake.genericContinueCmdObjMutex.RUnlock()
	return len(fake.genericContinueCmdObjArgsForCall)
}

func (fake *FakeIRebasingMgr) GenericContinueCmdObjCalls(stub func() types.ICmdObj) {
	fake.genericContinueCmdObjMutex.Lock()
	defer fake.genericContinueCmdObjMutex.Unlock()
	fake.GenericContinueCmdObjStub = stub
}

func (fake *FakeIRebasingMgr) GenericContinueCmdObjReturns(result1 types.ICmdObj) {
	fake.genericContinueCmdObjMutex.Lock()
	defer fake.genericContinueCmdObjMutex.Unlock()
	fake.GenericContinueCmdObjStub = nil
	fake.genericContinueCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIRebasingMgr) GenericContinueCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.genericContinueCmdObjMutex.Lock()
	defer fake.genericContinueCmdObjMutex.Unlock()
	fake.GenericContinueCmdObjStub = nil
	if fake.genericContinueCmdObjReturnsOnCall == nil {
		fake.genericContinueCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.genericContinueCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseAction(arg1 string, arg2 string) error {
	fake.genericMergeOrRebaseActionMutex.Lock()
	ret, specificReturn := fake.genericMergeOrRebaseActionReturnsOnCall[len(fake.genericMergeOrRebaseActionArgsForCall)]
	fake.genericMergeOrRebaseActionArgsForCall = append(fake.genericMergeOrRebaseActionArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GenericMergeOrRebaseActionStub
	fakeReturns := fake.genericMergeOrRebaseActionReturns
	fake.recordInvocation("GenericMergeOrRebaseAction", []interface{}{arg1, arg2})
	fake.genericMergeOrRebaseActionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseActionCallCount() int {
	fake.genericMergeOrRebaseActionMutex.RLock()
	defer fake.genericMergeOrRebaseActionMutex.RUnlock()
	return len(fake.genericMergeOrRebaseActionArgsForCall)
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseActionCalls(stub func(string, string) error) {
	fake.genericMergeOrRebaseActionMutex.Lock()
	defer fake.genericMergeOrRebaseActionMutex.Unlock()
	fake.GenericMergeOrRebaseActionStub = stub
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseActionArgsForCall(i int) (string, string) {
	fake.genericMergeOrRebaseActionMutex.RLock()
	defer fake.genericMergeOrRebaseActionMutex.RUnlock()
	argsForCall := fake.genericMergeOrRebaseActionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseActionReturns(result1 error) {
	fake.genericMergeOrRebaseActionMutex.Lock()
	defer fake.genericMergeOrRebaseActionMutex.Unlock()
	fake.GenericMergeOrRebaseActionStub = nil
	fake.genericMergeOrRebaseActionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseActionReturnsOnCall(i int, result1 error) {
	fake.genericMergeOrRebaseActionMutex.Lock()
	defer fake.genericMergeOrRebaseActionMutex.Unlock()
	fake.GenericMergeOrRebaseActionStub = nil
	if fake.genericMergeOrRebaseActionReturnsOnCall == nil {
		fake.genericMergeOrRebaseActionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.genericMergeOrRebaseActionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseCmdObj(arg1 string) types.ICmdObj {
	fake.genericMergeOrRebaseCmdObjMutex.Lock()
	ret, specificReturn := fake.genericMergeOrRebaseCmdObjReturnsOnCall[len(fake.genericMergeOrRebaseCmdObjArgsForCall)]
	fake.genericMergeOrRebaseCmdObjArgsForCall = append(fake.genericMergeOrRebaseCmdObjArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GenericMergeOrRebaseCmdObjStub
	fakeReturns := fake.genericMergeOrRebaseCmdObjReturns
	fake.recordInvocation("GenericMergeOrRebaseCmdObj", []interface{}{arg1})
	fake.genericMergeOrRebaseCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseCmdObjCallCount() int {
	fake.genericMergeOrRebaseCmdObjMutex.RLock()
	defer fake.genericMergeOrRebaseCmdObjMutex.RUnlock()
	return len(fake.genericMergeOrRebaseCmdObjArgsForCall)
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseCmdObjCalls(stub func(string) types.ICmdObj) {
	fake.genericMergeOrRebaseCmdObjMutex.Lock()
	defer fake.genericMergeOrRebaseCmdObjMutex.Unlock()
	fake.GenericMergeOrRebaseCmdObjStub = stub
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseCmdObjArgsForCall(i int) string {
	fake.genericMergeOrRebaseCmdObjMutex.RLock()
	defer fake.genericMergeOrRebaseCmdObjMutex.RUnlock()
	argsForCall := fake.genericMergeOrRebaseCmdObjArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseCmdObjReturns(result1 types.ICmdObj) {
	fake.genericMergeOrRebaseCmdObjMutex.Lock()
	defer fake.genericMergeOrRebaseCmdObjMutex.Unlock()
	fake.GenericMergeOrRebaseCmdObjStub = nil
	fake.genericMergeOrRebaseCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIRebasingMgr) GenericMergeOrRebaseCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.genericMergeOrRebaseCmdObjMutex.Lock()
	defer fake.genericMergeOrRebaseCmdObjMutex.Unlock()
	fake.GenericMergeOrRebaseCmdObjStub = nil
	if fake.genericMergeOrRebaseCmdObjReturnsOnCall == nil {
		fake.genericMergeOrRebaseCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.genericMergeOrRebaseCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIRebasingMgr) GetRewordCommitCmdObj(arg1 []*models.Commit, arg2 int) (types.ICmdObj, error) {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getRewordCommitCmdObjMutex.Lock()
	ret, specificReturn := fake.getRewordCommitCmdObjReturnsOnCall[len(fake.getRewordCommitCmdObjArgsForCall)]
	fake.getRewordCommitCmdObjArgsForCall = append(fake.getRewordCommitCmdObjArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
	}{arg1Copy, arg2})
	stub := fake.GetRewordCommitCmdObjStub
	fakeReturns := fake.getRewordCommitCmdObjReturns
	fake.recordInvocation("GetRewordCommitCmdObj", []interface{}{arg1Copy, arg2})
	fake.getRewordCommitCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIRebasingMgr) GetRewordCommitCmdObjCallCount() int {
	fake.getRewordCommitCmdObjMutex.RLock()
	defer fake.getRewordCommitCmdObjMutex.RUnlock()
	return len(fake.getRewordCommitCmdObjArgsForCall)
}

func (fake *FakeIRebasingMgr) GetRewordCommitCmdObjCalls(stub func([]*models.Commit, int) (types.ICmdObj, error)) {
	fake.getRewordCommitCmdObjMutex.Lock()
	defer fake.getRewordCommitCmdObjMutex.Unlock()
	fake.GetRewordCommitCmdObjStub = stub
}

func (fake *FakeIRebasingMgr) GetRewordCommitCmdObjArgsForCall(i int) ([]*models.Commit, int) {
	fake.getRewordCommitCmdObjMutex.RLock()
	defer fake.getRewordCommitCmdObjMutex.RUnlock()
	argsForCall := fake.getRewordCommitCmdObjArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIRebasingMgr) GetRewordCommitCmdObjReturns(result1 types.ICmdObj, result2 error) {
	fake.getRewordCommitCmdObjMutex.Lock()
	defer fake.getRewordCommitCmdObjMutex.Unlock()
	fake.GetRewordCommitCmdObjStub = nil
	fake.getRewordCommitCmdObjReturns = struct {
		result1 types.ICmdObj
		result2 error
	}{result1, result2}
}

func (fake *FakeIRebasingMgr) GetRewordCommitCmdObjReturnsOnCall(i int, result1 types.ICmdObj, result2 error) {
	fake.getRewordCommitCmdObjMutex.Lock()
	defer fake.getRewordCommitCmdObjMutex.Unlock()
	fake.GetRewordCommitCmdObjStub = nil
	if fake.getRewordCommitCmdObjReturnsOnCall == nil {
		fake.getRewordCommitCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
			result2 error
		})
	}
	fake.getRewordCommitCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
		result2 error
	}{result1, result2}
}

func (fake *FakeIRebasingMgr) GetWorkflow() *commands.RebaseWorkflow {
	fake.getWorkflowMutex.Lock()
	ret, specificReturn := fake.getWorkflowReturnsOnCall[len(fake.getWorkflowArgsForCall)]
	fake.getWorkflowArgsForCall = append(fake.getWorkflowArgsForCall, struct {
	}{})
	stub := fake.GetWorkflowStub
	fakeReturns := fake.getWorkflowReturns
	fake.recordInvocation("GetWorkflow", []interface{}{})
	fake.getWorkflowMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) GetWorkflowCallCount() int {
	fake.getWorkflowMutex.RLock()
	defer fake.getWorkflowMutex.RUnlock()
	return len(fake.getWorkflowArgsForCall)
}

func (fake *FakeIRebasingMgr) GetWorkflowCalls(stub func() *commands.RebaseWorkflow) {
	fake.getWorkflowMutex.Lock()
	defer fake.getWorkflowMutex.Unlock()
	fake.GetWorkflowStub = stub
}

func (fake *FakeIRebasingMgr) GetWorkflowReturns(result1 *commands.RebaseWorkflow) {
	fake.getWorkflowMutex.Lock()
	defer fake.getWorkflowMutex.Unlock()
	fake.GetWorkflowStub = nil
	fake.getWorkflowReturns = struct {
		result1 *commands.RebaseWorkflow
	}{result1}
}

func (fake *FakeIRebasingMgr) GetWorkflowReturnsOnCall(i int, result1 *commands.RebaseWorkflow) {
	fake.getWorkflowMutex.Lock()
	defer fake.getWorkflowMutex.Unlock()
	fake.GetWorkflowStub = nil
	if fake.getWorkflowReturnsOnCall == nil {
		fake.getWorkflowReturnsOnCall = make(map[int]struct {
			result1 *commands.RebaseWorkflow
		})
	}
	fake.getWorkflowReturnsOnCall[i] = struct {
		result1 *commands.RebaseWorkflow
	}{result1}
}

func (fake *FakeIRebasingMgr) InteractiveRebase(arg1 []*models.Commit, arg2 int, arg3 string) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.interactiveRebaseMutex.Lock()
	ret, specificReturn := fake.interactiveRebaseReturnsOnCall[len(fake.interactiveRebaseArgsForCall)]
	fake.interactiveRebaseArgsForCall = append(fake.interactiveRebaseArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
		arg3 string
	}{arg1Copy, arg2, arg3})
	stub := fake.InteractiveRebaseStub
	fakeReturns := fake.interactiveRebaseReturns
	fake.recordInvocation("InteractiveRebase", []interface{}{arg1Copy, arg2, arg3})
	fake.interactiveRebaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) InteractiveRebaseCallCount() int {
	fake.interactiveRebaseMutex.RLock()
	defer fake.interactiveRebaseMutex.RUnlock()
	return len(fake.interactiveRebaseArgsForCall)
}

func (fake *FakeIRebasingMgr) InteractiveRebaseCalls(stub func([]*models.Commit, int, string) error) {
	fake.interactiveRebaseMutex.Lock()
	defer fake.interactiveRebaseMutex.Unlock()
	fake.InteractiveRebaseStub = stub
}

func (fake *FakeIRebasingMgr) InteractiveRebaseArgsForCall(i int) ([]*models.Commit, int, string) {
	fake.interactiveRebaseMutex.RLock()
	defer fake.interactiveRebaseMutex.RUnlock()
	argsForCall := fake.interactiveRebaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIRebasingMgr) InteractiveRebaseReturns(result1 error) {
	fake.interactiveRebaseMutex.Lock()
	defer fake.interactiveRebaseMutex.Unlock()
	fake.InteractiveRebaseStub = nil
	fake.interactiveRebaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) InteractiveRebaseReturnsOnCall(i int, result1 error) {
	fake.interactiveRebaseMutex.Lock()
	defer fake.interactiveRebaseMutex.Unlock()
	fake.InteractiveRebaseStub = nil
	if fake.interactiveRebaseReturnsOnCall == nil {
		fake.interactiveRebaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.interactiveRebaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) InteractiveRebaseCmdObj(arg1 string, arg2 string, arg3 bool) types.ICmdObj {
	fake.interactiveRebaseCmdObjMutex.Lock()
	ret, specificReturn := fake.interactiveRebaseCmdObjReturnsOnCall[len(fake.interactiveRebaseCmdObjArgsForCall)]
	fake.interactiveRebaseCmdObjArgsForCall = append(fake.interactiveRebaseCmdObjArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.InteractiveRebaseCmdObjStub
	fakeReturns := fake.interactiveRebaseCmdObjReturns
	fake.recordInvocation("InteractiveRebaseCmdObj", []interface{}{arg1, arg2, arg3})
	fake.interactiveRebaseCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) InteractiveRebaseCmdObjCallCount() int {
	fake.interactiveRebaseCmdObjMutex.RLock()
	defer fake.interactiveRebaseCmdObjMutex.RUnlock()
	return len(fake.interactiveRebaseCmdObjArgsForCall)
}

func (fake *FakeIRebasingMgr) InteractiveRebaseCmdObjCalls(stub func(string, string, bool) types.ICmdObj) {
	fake.interactiveRebaseCmdObjMutex.Lock()
	defer fake.interactiveRebaseCmdObjMutex.Unlock()
	fake.InteractiveRebaseCmdObjStub = stub
}

func (fake *FakeIRebasingMgr) InteractiveRebaseCmdObjArgsForCall(i int) (string, string, bool) {
	fake.interactiveRebaseCmdObjMutex.RLock()
	defer fake.interactiveRebaseCmdObjMutex.RUnlock()
	argsForCall := fake.interactiveRebaseCmdObjArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIRebasingMgr) InteractiveRebaseCmdObjReturns(result1 types.ICmdObj) {
	fake.interactiveRebaseCmdObjMutex.Lock()
	defer fake.interactiveRebaseCmdObjMutex.Unlock()
	fake.InteractiveRebaseCmdObjStub = nil
	fake.interactiveRebaseCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIRebasingMgr) InteractiveRebaseCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.interactiveRebaseCmdObjMutex.Lock()
	defer fake.interactiveRebaseCmdObjMutex.Unlock()
	fake.InteractiveRebaseCmdObjStub = nil
	if fake.interactiveRebaseCmdObjReturnsOnCall == nil {
		fake.interactiveRebaseCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.interactiveRebaseCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIRebasingMgr) MergeOrRebase() string {
	fake.mergeOrRebaseMutex.Lock()
	ret, specificReturn := fake.mergeOrRebaseReturnsOnCall[len(fake.mergeOrRebaseArgsForCall)]
	fake.mergeOrRebaseArgsForCall = append(fake.mergeOrRebaseArgsForCall, struct {
	}{})
	stub := fake.MergeOrRebaseStub
	fakeReturns := fake.mergeOrRebaseReturns
	fake.recordInvocation("MergeOrRebase", []interface{}{})
	fake.mergeOrRebaseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) MergeOrRebaseCallCount() int {
	fake.mergeOrRebaseMutex.RLock()
	defer fake.mergeOrRebaseMutex.RUnlock()
	return len(fake.mergeOrRebaseArgsForCall)
}

func (fake *FakeIRebasingMgr) MergeOrRebaseCalls(stub func() string) {
	fake.mergeOrRebaseMutex.Lock()
	defer fake.mergeOrRebaseMutex.Unlock()
	fake.MergeOrRebaseStub = stub
}

func (fake *FakeIRebasingMgr) MergeOrRebaseReturns(result1 string) {
	fake.mergeOrRebaseMutex.Lock()
	defer fake.mergeOrRebaseMutex.Unlock()
	fake.MergeOrRebaseStub = nil
	fake.mergeOrRebaseReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIRebasingMgr) MergeOrRebaseReturnsOnCall(i int, result1 string) {
	fake.mergeOrRebaseMutex.Lock()
	defer fake.mergeOrRebaseMutex.Unlock()
	fake.MergeOrRebaseStub = nil
	if fake.mergeOrRebaseReturnsOnCall == nil {
		fake.mergeOrRebaseReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.mergeOrRebaseReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIRebasingMgr) MoveCommitDown(arg1 []*models.Commit, arg2 int) error {
	var arg1Copy []*models.Commit
	if arg1 != nil {
		arg1Copy = make([]*models.Commit, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.moveCommitDownMutex.Lock()
	ret, specificReturn := fake.moveCommitDownReturnsOnCall[len(fake.moveCommitDownArgsForCall)]
	fake.moveCommitDownArgsForCall = append(fake.moveCommitDownArgsForCall, struct {
		arg1 []*models.Commit
		arg2 int
	}{arg1Copy, arg2})
	stub := fake.MoveCommitDownStub
	fakeReturns := fake.moveCommitDownReturns
	fake.recordInvocation("MoveCommitDown", []interface{}{arg1Copy, arg2})
	fake.moveCommitDownMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) MoveCommitDownCallCount() int {
	fake.moveCommitDownMutex.RLock()
	defer fake.moveCommitDownMutex.RUnlock()
	return len(fake.moveCommitDownArgsForCall)
}

func (fake *FakeIRebasingMgr) MoveCommitDownCalls(stub func([]*models.Commit, int) error) {
	fake.moveCommitDownMutex.Lock()
	defer fake.moveCommitDownMutex.Unlock()
	fake.MoveCommitDownStub = stub
}

func (fake *FakeIRebasingMgr) MoveCommitDownArgsForCall(i int) ([]*models.Commit, int) {
	fake.moveCommitDownMutex.RLock()
	defer fake.moveCommitDownMutex.RUnlock()
	argsForCall := fake.moveCommitDownArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIRebasingMgr) MoveCommitDownReturns(result1 error) {
	fake.moveCommitDownMutex.Lock()
	defer fake.moveCommitDownMutex.Unlock()
	fake.MoveCommitDownStub = nil
	fake.moveCommitDownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) MoveCommitDownReturnsOnCall(i int, result1 error) {
	fake.moveCommitDownMutex.Lock()
	defer fake.moveCommitDownMutex.Unlock()
	fake.MoveCommitDownStub = nil
	if fake.moveCommitDownReturnsOnCall == nil {
		fake.moveCommitDownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.moveCommitDownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) MoveTodoDown(arg1 int) error {
	fake.moveTodoDownMutex.Lock()
	ret, specificReturn := fake.moveTodoDownReturnsOnCall[len(fake.moveTodoDownArgsForCall)]
	fake.moveTodoDownArgsForCall = append(fake.moveTodoDownArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.MoveTodoDownStub
	fakeReturns := fake.moveTodoDownReturns
	fake.recordInvocation("MoveTodoDown", []interface{}{arg1})
	fake.moveTodoDownMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) MoveTodoDownCallCount() int {
	fake.moveTodoDownMutex.RLock()
	defer fake.moveTodoDownMutex.RUnlock()
	return len(fake.moveTodoDownArgsForCall)
}

func (fake *FakeIRebasingMgr) MoveTodoDownCalls(stub func(int) error) {
	fake.moveTodoDownMutex.Lock()
	defer fake.moveTodoDownMutex.Unlock()
	fake.MoveTodoDownStub = stub
}

func (fake *FakeIRebasingMgr) MoveTodoDownArgsForCall(i int) int {
	fake.moveTodoDownMutex.RLock()
	defer fake.moveTodoDownMutex.RUnlock()
	argsForCall := fake.moveTodoDownArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIRebasingMgr) MoveTodoDownReturns(result1 error) {
	fake.moveTodoDownMutex.Lock()
	defer fake.moveTodoDownMutex.Unlock()
	fake.MoveTodoDownStub = nil
	fake.moveTodoDownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) MoveTodoDownReturnsOnCall(i int, result1 error) {
	fake.moveTodoDownMutex.Lock()
	defer fake.moveTodoDownMutex.Unlock()
	fake.MoveTodoDownStub = nil
	if fake.moveTodoDownReturnsOnCall == nil {
		fake.moveTodoDownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.moveTodoDownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) RebaseBranch(arg1 string) error {
	fake.rebaseBranchMutex.Lock()
	ret, specificReturn := fake.rebaseBranchReturnsOnCall[len(fake.rebaseBranchArgsForCall)]
	fake.rebaseBranchArgsForCall = append(fake.rebaseBranchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RebaseBranchStub
	fakeReturns := fake.rebaseBranchReturns
	fake.recordInvocation("RebaseBranch", []interface{}{arg1})
	fake.rebaseBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) RebaseBranchCallCount() int {
	fake.rebaseBranchMutex.RLock()
	defer fake.rebaseBranchMutex.RUnlock()
	return len(fake.rebaseBranchArgsForCall)
}

func (fake *FakeIRebasingMgr) RebaseBranchCalls(stub func(string) error) {
	fake.rebaseBranchMutex.Lock()
	defer fake.rebaseBranchMutex.Unlock()
	fake.RebaseBranchStub = stub
}

func (fake *FakeIRebasingMgr) RebaseBranchArgsForCall(i int) string {
	fake.rebaseBranchMutex.RLock()
	defer fake.rebaseBranchMutex.RUnlock()
	argsForCall := fake.rebaseBranchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIRebasingMgr) RebaseBranchReturns(result1 error) {
	fake.rebaseBranchMutex.Lock()
	defer fake.rebaseBranchMutex.Unlock()
	fake.RebaseBranchStub = nil
	fake.rebaseBranchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) RebaseBranchReturnsOnCall(i int, result1 error) {
	fake.rebaseBranchMutex.Lock()
	defer fake.rebaseBranchMutex.Unlock()
	fake.RebaseBranchStub = nil
	if fake.rebaseBranchReturnsOnCall == nil {
		fake.rebaseBranchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebaseBranchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) SquashAllAboveFixupCommits(arg1 string) error {
	fake.squashAllAboveFixupCommitsMutex.Lock()
	ret, specificReturn := fake.squashAllAboveFixupCommitsReturnsOnCall[len(fake.squashAllAboveFixupCommitsArgsForCall)]
	fake.squashAllAboveFixupCommitsArgsForCall = append(fake.squashAllAboveFixupCommitsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SquashAllAboveFixupCommitsStub
	fakeReturns := fake.squashAllAboveFixupCommitsReturns
	fake.recordInvocation("SquashAllAboveFixupCommits", []interface{}{arg1})
	fake.squashAllAboveFixupCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRebasingMgr) SquashAllAboveFixupCommitsCallCount() int {
	fake.squashAllAboveFixupCommitsMutex.RLock()
	defer fake.squashAllAboveFixupCommitsMutex.RUnlock()
	return len(fake.squashAllAboveFixupCommitsArgsForCall)
}

func (fake *FakeIRebasingMgr) SquashAllAboveFixupCommitsCalls(stub func(string) error) {
	fake.squashAllAboveFixupCommitsMutex.Lock()
	defer fake.squashAllAboveFixupCommitsMutex.Unlock()
	fake.SquashAllAboveFixupCommitsStub = stub
}

func (fake *FakeIRebasingMgr) SquashAllAboveFixupCommitsArgsForCall(i int) string {
	fake.squashAllAboveFixupCommitsMutex.RLock()
	defer fake.squashAllAboveFixupCommitsMutex.RUnlock()
	argsForCall := fake.squashAllAboveFixupCommitsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIRebasingMgr) SquashAllAboveFixupCommitsReturns(result1 error) {
	fake.squashAllAboveFixupCommitsMutex.Lock()
	defer fake.squashAllAboveFixupCommitsMutex.Unlock()
	fake.SquashAllAboveFixupCommitsStub = nil
	fake.squashAllAboveFixupCommitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) SquashAllAboveFixupCommitsReturnsOnCall(i int, result1 error) {
	fake.squashAllAboveFixupCommitsMutex.Lock()
	defer fake.squashAllAboveFixupCommitsMutex.Unlock()
	fake.SquashAllAboveFixupCommitsStub = nil
	if fake.squashAllAboveFixupCommitsReturnsOnCall == nil {
		fake.squashAllAboveFixupCommitsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.squashAllAboveFixupCommitsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRebasingMgr) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.abortRebaseMutex.RLock()
	defer fake.abortRebaseMutex.RUnlock()
	fake.amendToMutex.RLock()
	defer fake.amendToMutex.RUnlock()
	fake.beginInteractiveRebaseForCommitMutex.RLock()
	defer fake.beginInteractiveRebaseForCommitMutex.RUnlock()
	fake.cherryPickCommitsMutex.RLock()
	defer fake.cherryPickCommitsMutex.RUnlock()
	fake.continueRebaseMutex.RLock()
	defer fake.continueRebaseMutex.RUnlock()
	fake.discardOldFileChangesMutex.RLock()
	defer fake.discardOldFileChangesMutex.RUnlock()
	fake.editRebaseTodoMutex.RLock()
	defer fake.editRebaseTodoMutex.RUnlock()
	fake.generateGenericRebaseTodoMutex.RLock()
	defer fake.generateGenericRebaseTodoMutex.RUnlock()
	fake.genericAbortCmdObjMutex.RLock()
	defer fake.genericAbortCmdObjMutex.RUnlock()
	fake.genericContinueCmdObjMutex.RLock()
	defer fake.genericContinueCmdObjMutex.RUnlock()
	fake.genericMergeOrRebaseActionMutex.RLock()
	defer fake.genericMergeOrRebaseActionMutex.RUnlock()
	fake.genericMergeOrRebaseCmdObjMutex.RLock()
	defer fake.genericMergeOrRebaseCmdObjMutex.RUnlock()
	fake.getRewordCommitCmdObjMutex.RLock()
	defer fake.getRewordCommitCmdObjMutex.RUnlock()
	fake.getWorkflowMutex.RLock()
	defer fake.getWorkflowMutex.RUnlock()
	fake.interactiveRebaseMutex.RLock()
	defer fake.interactiveRebaseMutex.RUnlock()
	fake.interactiveRebaseCmdObjMutex.RLock()
	defer fake.interactiveRebaseCmdObjMutex.RUnlock()
	fake.mergeOrRebaseMutex.RLock()
	defer fake.mergeOrRebaseMutex.RUnlock()
	fake.moveCommitDownMutex.RLock()
	defer fake.moveCommitDownMutex.RUnlock()
	fake.moveTodoDownMutex.RLock()
	defer fake.moveTodoDownMutex.RUnlock()
	fake.rebaseBranchMutex.RLock()
	defer fake.rebaseBranchMutex.RUnlock()
	fake.squashAllAboveFixupCommitsMutex.RLock()
	defer fake.squashAllAboveFixupCommitsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIRebasingMgr) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.IRebasingMgr = new(FakeIRebasingMgr)
