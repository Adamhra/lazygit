// Code generated by counterfeiter. DO NOT EDIT.
package commandsfakes

import (
	"sync"

	"github.com/jesseduffield/lazygit/pkg/commands"
	"github.com/jesseduffield/lazygit/pkg/commands/models"
)

type FakeIRemotesMgr struct {
	AddStub        func(string, string) error
	addMutex       sync.RWMutex
	addArgsForCall []struct {
		arg1 string
		arg2 string
	}
	addReturns struct {
		result1 error
	}
	addReturnsOnCall map[int]struct {
		result1 error
	}
	GetCurrentRemoteUrlStub        func() string
	getCurrentRemoteUrlMutex       sync.RWMutex
	getCurrentRemoteUrlArgsForCall []struct {
	}
	getCurrentRemoteUrlReturns struct {
		result1 string
	}
	getCurrentRemoteUrlReturnsOnCall map[int]struct {
		result1 string
	}
	LoadStub        func() ([]*models.Remote, error)
	loadMutex       sync.RWMutex
	loadArgsForCall []struct {
	}
	loadReturns struct {
		result1 []*models.Remote
		result2 error
	}
	loadReturnsOnCall map[int]struct {
		result1 []*models.Remote
		result2 error
	}
	RemoteBranchExistsStub        func(*models.Branch) bool
	remoteBranchExistsMutex       sync.RWMutex
	remoteBranchExistsArgsForCall []struct {
		arg1 *models.Branch
	}
	remoteBranchExistsReturns struct {
		result1 bool
	}
	remoteBranchExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	RemoveStub        func(string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	RenameStub        func(string, string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameReturns struct {
		result1 error
	}
	renameReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateUrlStub        func(string, string) error
	updateUrlMutex       sync.RWMutex
	updateUrlArgsForCall []struct {
		arg1 string
		arg2 string
	}
	updateUrlReturns struct {
		result1 error
	}
	updateUrlReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIRemotesMgr) Add(arg1 string, arg2 string) error {
	fake.addMutex.Lock()
	ret, specificReturn := fake.addReturnsOnCall[len(fake.addArgsForCall)]
	fake.addArgsForCall = append(fake.addArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AddStub
	fakeReturns := fake.addReturns
	fake.recordInvocation("Add", []interface{}{arg1, arg2})
	fake.addMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRemotesMgr) AddCallCount() int {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	return len(fake.addArgsForCall)
}

func (fake *FakeIRemotesMgr) AddCalls(stub func(string, string) error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = stub
}

func (fake *FakeIRemotesMgr) AddArgsForCall(i int) (string, string) {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	argsForCall := fake.addArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIRemotesMgr) AddReturns(result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	fake.addReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRemotesMgr) AddReturnsOnCall(i int, result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	if fake.addReturnsOnCall == nil {
		fake.addReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRemotesMgr) GetCurrentRemoteUrl() string {
	fake.getCurrentRemoteUrlMutex.Lock()
	ret, specificReturn := fake.getCurrentRemoteUrlReturnsOnCall[len(fake.getCurrentRemoteUrlArgsForCall)]
	fake.getCurrentRemoteUrlArgsForCall = append(fake.getCurrentRemoteUrlArgsForCall, struct {
	}{})
	stub := fake.GetCurrentRemoteUrlStub
	fakeReturns := fake.getCurrentRemoteUrlReturns
	fake.recordInvocation("GetCurrentRemoteUrl", []interface{}{})
	fake.getCurrentRemoteUrlMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRemotesMgr) GetCurrentRemoteUrlCallCount() int {
	fake.getCurrentRemoteUrlMutex.RLock()
	defer fake.getCurrentRemoteUrlMutex.RUnlock()
	return len(fake.getCurrentRemoteUrlArgsForCall)
}

func (fake *FakeIRemotesMgr) GetCurrentRemoteUrlCalls(stub func() string) {
	fake.getCurrentRemoteUrlMutex.Lock()
	defer fake.getCurrentRemoteUrlMutex.Unlock()
	fake.GetCurrentRemoteUrlStub = stub
}

func (fake *FakeIRemotesMgr) GetCurrentRemoteUrlReturns(result1 string) {
	fake.getCurrentRemoteUrlMutex.Lock()
	defer fake.getCurrentRemoteUrlMutex.Unlock()
	fake.GetCurrentRemoteUrlStub = nil
	fake.getCurrentRemoteUrlReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIRemotesMgr) GetCurrentRemoteUrlReturnsOnCall(i int, result1 string) {
	fake.getCurrentRemoteUrlMutex.Lock()
	defer fake.getCurrentRemoteUrlMutex.Unlock()
	fake.GetCurrentRemoteUrlStub = nil
	if fake.getCurrentRemoteUrlReturnsOnCall == nil {
		fake.getCurrentRemoteUrlReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getCurrentRemoteUrlReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIRemotesMgr) Load() ([]*models.Remote, error) {
	fake.loadMutex.Lock()
	ret, specificReturn := fake.loadReturnsOnCall[len(fake.loadArgsForCall)]
	fake.loadArgsForCall = append(fake.loadArgsForCall, struct {
	}{})
	stub := fake.LoadStub
	fakeReturns := fake.loadReturns
	fake.recordInvocation("Load", []interface{}{})
	fake.loadMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIRemotesMgr) LoadCallCount() int {
	fake.loadMutex.RLock()
	defer fake.loadMutex.RUnlock()
	return len(fake.loadArgsForCall)
}

func (fake *FakeIRemotesMgr) LoadCalls(stub func() ([]*models.Remote, error)) {
	fake.loadMutex.Lock()
	defer fake.loadMutex.Unlock()
	fake.LoadStub = stub
}

func (fake *FakeIRemotesMgr) LoadReturns(result1 []*models.Remote, result2 error) {
	fake.loadMutex.Lock()
	defer fake.loadMutex.Unlock()
	fake.LoadStub = nil
	fake.loadReturns = struct {
		result1 []*models.Remote
		result2 error
	}{result1, result2}
}

func (fake *FakeIRemotesMgr) LoadReturnsOnCall(i int, result1 []*models.Remote, result2 error) {
	fake.loadMutex.Lock()
	defer fake.loadMutex.Unlock()
	fake.LoadStub = nil
	if fake.loadReturnsOnCall == nil {
		fake.loadReturnsOnCall = make(map[int]struct {
			result1 []*models.Remote
			result2 error
		})
	}
	fake.loadReturnsOnCall[i] = struct {
		result1 []*models.Remote
		result2 error
	}{result1, result2}
}

func (fake *FakeIRemotesMgr) RemoteBranchExists(arg1 *models.Branch) bool {
	fake.remoteBranchExistsMutex.Lock()
	ret, specificReturn := fake.remoteBranchExistsReturnsOnCall[len(fake.remoteBranchExistsArgsForCall)]
	fake.remoteBranchExistsArgsForCall = append(fake.remoteBranchExistsArgsForCall, struct {
		arg1 *models.Branch
	}{arg1})
	stub := fake.RemoteBranchExistsStub
	fakeReturns := fake.remoteBranchExistsReturns
	fake.recordInvocation("RemoteBranchExists", []interface{}{arg1})
	fake.remoteBranchExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRemotesMgr) RemoteBranchExistsCallCount() int {
	fake.remoteBranchExistsMutex.RLock()
	defer fake.remoteBranchExistsMutex.RUnlock()
	return len(fake.remoteBranchExistsArgsForCall)
}

func (fake *FakeIRemotesMgr) RemoteBranchExistsCalls(stub func(*models.Branch) bool) {
	fake.remoteBranchExistsMutex.Lock()
	defer fake.remoteBranchExistsMutex.Unlock()
	fake.RemoteBranchExistsStub = stub
}

func (fake *FakeIRemotesMgr) RemoteBranchExistsArgsForCall(i int) *models.Branch {
	fake.remoteBranchExistsMutex.RLock()
	defer fake.remoteBranchExistsMutex.RUnlock()
	argsForCall := fake.remoteBranchExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIRemotesMgr) RemoteBranchExistsReturns(result1 bool) {
	fake.remoteBranchExistsMutex.Lock()
	defer fake.remoteBranchExistsMutex.Unlock()
	fake.RemoteBranchExistsStub = nil
	fake.remoteBranchExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIRemotesMgr) RemoteBranchExistsReturnsOnCall(i int, result1 bool) {
	fake.remoteBranchExistsMutex.Lock()
	defer fake.remoteBranchExistsMutex.Unlock()
	fake.RemoteBranchExistsStub = nil
	if fake.remoteBranchExistsReturnsOnCall == nil {
		fake.remoteBranchExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.remoteBranchExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIRemotesMgr) Remove(arg1 string) error {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveStub
	fakeReturns := fake.removeReturns
	fake.recordInvocation("Remove", []interface{}{arg1})
	fake.removeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRemotesMgr) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeIRemotesMgr) RemoveCalls(stub func(string) error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *FakeIRemotesMgr) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIRemotesMgr) RemoveReturns(result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRemotesMgr) RemoveReturnsOnCall(i int, result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRemotesMgr) Rename(arg1 string, arg2 string) error {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RenameStub
	fakeReturns := fake.renameReturns
	fake.recordInvocation("Rename", []interface{}{arg1, arg2})
	fake.renameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRemotesMgr) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakeIRemotesMgr) RenameCalls(stub func(string, string) error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = stub
}

func (fake *FakeIRemotesMgr) RenameArgsForCall(i int) (string, string) {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	argsForCall := fake.renameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIRemotesMgr) RenameReturns(result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRemotesMgr) RenameReturnsOnCall(i int, result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRemotesMgr) UpdateUrl(arg1 string, arg2 string) error {
	fake.updateUrlMutex.Lock()
	ret, specificReturn := fake.updateUrlReturnsOnCall[len(fake.updateUrlArgsForCall)]
	fake.updateUrlArgsForCall = append(fake.updateUrlArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.UpdateUrlStub
	fakeReturns := fake.updateUrlReturns
	fake.recordInvocation("UpdateUrl", []interface{}{arg1, arg2})
	fake.updateUrlMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIRemotesMgr) UpdateUrlCallCount() int {
	fake.updateUrlMutex.RLock()
	defer fake.updateUrlMutex.RUnlock()
	return len(fake.updateUrlArgsForCall)
}

func (fake *FakeIRemotesMgr) UpdateUrlCalls(stub func(string, string) error) {
	fake.updateUrlMutex.Lock()
	defer fake.updateUrlMutex.Unlock()
	fake.UpdateUrlStub = stub
}

func (fake *FakeIRemotesMgr) UpdateUrlArgsForCall(i int) (string, string) {
	fake.updateUrlMutex.RLock()
	defer fake.updateUrlMutex.RUnlock()
	argsForCall := fake.updateUrlArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIRemotesMgr) UpdateUrlReturns(result1 error) {
	fake.updateUrlMutex.Lock()
	defer fake.updateUrlMutex.Unlock()
	fake.UpdateUrlStub = nil
	fake.updateUrlReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRemotesMgr) UpdateUrlReturnsOnCall(i int, result1 error) {
	fake.updateUrlMutex.Lock()
	defer fake.updateUrlMutex.Unlock()
	fake.UpdateUrlStub = nil
	if fake.updateUrlReturnsOnCall == nil {
		fake.updateUrlReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateUrlReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIRemotesMgr) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	fake.getCurrentRemoteUrlMutex.RLock()
	defer fake.getCurrentRemoteUrlMutex.RUnlock()
	fake.loadMutex.RLock()
	defer fake.loadMutex.RUnlock()
	fake.remoteBranchExistsMutex.RLock()
	defer fake.remoteBranchExistsMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.updateUrlMutex.RLock()
	defer fake.updateUrlMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIRemotesMgr) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.IRemotesMgr = new(FakeIRemotesMgr)
