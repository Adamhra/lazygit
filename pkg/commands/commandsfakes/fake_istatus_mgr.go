// Code generated by counterfeiter. DO NOT EDIT.
package commandsfakes

import (
	"sync"

	"github.com/jesseduffield/lazygit/pkg/commands"
)

type FakeIStatusMgr struct {
	CurrentBranchNameStub        func() (string, string, error)
	currentBranchNameMutex       sync.RWMutex
	currentBranchNameArgsForCall []struct {
	}
	currentBranchNameReturns struct {
		result1 string
		result2 string
		result3 error
	}
	currentBranchNameReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	InNormalWorkingTreeStateStub        func() bool
	inNormalWorkingTreeStateMutex       sync.RWMutex
	inNormalWorkingTreeStateArgsForCall []struct {
	}
	inNormalWorkingTreeStateReturns struct {
		result1 bool
	}
	inNormalWorkingTreeStateReturnsOnCall map[int]struct {
		result1 bool
	}
	IsBareRepoStub        func() bool
	isBareRepoMutex       sync.RWMutex
	isBareRepoArgsForCall []struct {
	}
	isBareRepoReturns struct {
		result1 bool
	}
	isBareRepoReturnsOnCall map[int]struct {
		result1 bool
	}
	IsHeadDetachedStub        func() bool
	isHeadDetachedMutex       sync.RWMutex
	isHeadDetachedArgsForCall []struct {
	}
	isHeadDetachedReturns struct {
		result1 bool
	}
	isHeadDetachedReturnsOnCall map[int]struct {
		result1 bool
	}
	IsMergingStub        func() bool
	isMergingMutex       sync.RWMutex
	isMergingArgsForCall []struct {
	}
	isMergingReturns struct {
		result1 bool
	}
	isMergingReturnsOnCall map[int]struct {
		result1 bool
	}
	IsRebasingStub        func() bool
	isRebasingMutex       sync.RWMutex
	isRebasingArgsForCall []struct {
	}
	isRebasingReturns struct {
		result1 bool
	}
	isRebasingReturnsOnCall map[int]struct {
		result1 bool
	}
	RebaseModeStub        func() commands.RebasingMode
	rebaseModeMutex       sync.RWMutex
	rebaseModeArgsForCall []struct {
	}
	rebaseModeReturns struct {
		result1 commands.RebasingMode
	}
	rebaseModeReturnsOnCall map[int]struct {
		result1 commands.RebasingMode
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIStatusMgr) CurrentBranchName() (string, string, error) {
	fake.currentBranchNameMutex.Lock()
	ret, specificReturn := fake.currentBranchNameReturnsOnCall[len(fake.currentBranchNameArgsForCall)]
	fake.currentBranchNameArgsForCall = append(fake.currentBranchNameArgsForCall, struct {
	}{})
	stub := fake.CurrentBranchNameStub
	fakeReturns := fake.currentBranchNameReturns
	fake.recordInvocation("CurrentBranchName", []interface{}{})
	fake.currentBranchNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIStatusMgr) CurrentBranchNameCallCount() int {
	fake.currentBranchNameMutex.RLock()
	defer fake.currentBranchNameMutex.RUnlock()
	return len(fake.currentBranchNameArgsForCall)
}

func (fake *FakeIStatusMgr) CurrentBranchNameCalls(stub func() (string, string, error)) {
	fake.currentBranchNameMutex.Lock()
	defer fake.currentBranchNameMutex.Unlock()
	fake.CurrentBranchNameStub = stub
}

func (fake *FakeIStatusMgr) CurrentBranchNameReturns(result1 string, result2 string, result3 error) {
	fake.currentBranchNameMutex.Lock()
	defer fake.currentBranchNameMutex.Unlock()
	fake.CurrentBranchNameStub = nil
	fake.currentBranchNameReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIStatusMgr) CurrentBranchNameReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.currentBranchNameMutex.Lock()
	defer fake.currentBranchNameMutex.Unlock()
	fake.CurrentBranchNameStub = nil
	if fake.currentBranchNameReturnsOnCall == nil {
		fake.currentBranchNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.currentBranchNameReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIStatusMgr) InNormalWorkingTreeState() bool {
	fake.inNormalWorkingTreeStateMutex.Lock()
	ret, specificReturn := fake.inNormalWorkingTreeStateReturnsOnCall[len(fake.inNormalWorkingTreeStateArgsForCall)]
	fake.inNormalWorkingTreeStateArgsForCall = append(fake.inNormalWorkingTreeStateArgsForCall, struct {
	}{})
	stub := fake.InNormalWorkingTreeStateStub
	fakeReturns := fake.inNormalWorkingTreeStateReturns
	fake.recordInvocation("InNormalWorkingTreeState", []interface{}{})
	fake.inNormalWorkingTreeStateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIStatusMgr) InNormalWorkingTreeStateCallCount() int {
	fake.inNormalWorkingTreeStateMutex.RLock()
	defer fake.inNormalWorkingTreeStateMutex.RUnlock()
	return len(fake.inNormalWorkingTreeStateArgsForCall)
}

func (fake *FakeIStatusMgr) InNormalWorkingTreeStateCalls(stub func() bool) {
	fake.inNormalWorkingTreeStateMutex.Lock()
	defer fake.inNormalWorkingTreeStateMutex.Unlock()
	fake.InNormalWorkingTreeStateStub = stub
}

func (fake *FakeIStatusMgr) InNormalWorkingTreeStateReturns(result1 bool) {
	fake.inNormalWorkingTreeStateMutex.Lock()
	defer fake.inNormalWorkingTreeStateMutex.Unlock()
	fake.InNormalWorkingTreeStateStub = nil
	fake.inNormalWorkingTreeStateReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIStatusMgr) InNormalWorkingTreeStateReturnsOnCall(i int, result1 bool) {
	fake.inNormalWorkingTreeStateMutex.Lock()
	defer fake.inNormalWorkingTreeStateMutex.Unlock()
	fake.InNormalWorkingTreeStateStub = nil
	if fake.inNormalWorkingTreeStateReturnsOnCall == nil {
		fake.inNormalWorkingTreeStateReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.inNormalWorkingTreeStateReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIStatusMgr) IsBareRepo() bool {
	fake.isBareRepoMutex.Lock()
	ret, specificReturn := fake.isBareRepoReturnsOnCall[len(fake.isBareRepoArgsForCall)]
	fake.isBareRepoArgsForCall = append(fake.isBareRepoArgsForCall, struct {
	}{})
	stub := fake.IsBareRepoStub
	fakeReturns := fake.isBareRepoReturns
	fake.recordInvocation("IsBareRepo", []interface{}{})
	fake.isBareRepoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIStatusMgr) IsBareRepoCallCount() int {
	fake.isBareRepoMutex.RLock()
	defer fake.isBareRepoMutex.RUnlock()
	return len(fake.isBareRepoArgsForCall)
}

func (fake *FakeIStatusMgr) IsBareRepoCalls(stub func() bool) {
	fake.isBareRepoMutex.Lock()
	defer fake.isBareRepoMutex.Unlock()
	fake.IsBareRepoStub = stub
}

func (fake *FakeIStatusMgr) IsBareRepoReturns(result1 bool) {
	fake.isBareRepoMutex.Lock()
	defer fake.isBareRepoMutex.Unlock()
	fake.IsBareRepoStub = nil
	fake.isBareRepoReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIStatusMgr) IsBareRepoReturnsOnCall(i int, result1 bool) {
	fake.isBareRepoMutex.Lock()
	defer fake.isBareRepoMutex.Unlock()
	fake.IsBareRepoStub = nil
	if fake.isBareRepoReturnsOnCall == nil {
		fake.isBareRepoReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isBareRepoReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIStatusMgr) IsHeadDetached() bool {
	fake.isHeadDetachedMutex.Lock()
	ret, specificReturn := fake.isHeadDetachedReturnsOnCall[len(fake.isHeadDetachedArgsForCall)]
	fake.isHeadDetachedArgsForCall = append(fake.isHeadDetachedArgsForCall, struct {
	}{})
	stub := fake.IsHeadDetachedStub
	fakeReturns := fake.isHeadDetachedReturns
	fake.recordInvocation("IsHeadDetached", []interface{}{})
	fake.isHeadDetachedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIStatusMgr) IsHeadDetachedCallCount() int {
	fake.isHeadDetachedMutex.RLock()
	defer fake.isHeadDetachedMutex.RUnlock()
	return len(fake.isHeadDetachedArgsForCall)
}

func (fake *FakeIStatusMgr) IsHeadDetachedCalls(stub func() bool) {
	fake.isHeadDetachedMutex.Lock()
	defer fake.isHeadDetachedMutex.Unlock()
	fake.IsHeadDetachedStub = stub
}

func (fake *FakeIStatusMgr) IsHeadDetachedReturns(result1 bool) {
	fake.isHeadDetachedMutex.Lock()
	defer fake.isHeadDetachedMutex.Unlock()
	fake.IsHeadDetachedStub = nil
	fake.isHeadDetachedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIStatusMgr) IsHeadDetachedReturnsOnCall(i int, result1 bool) {
	fake.isHeadDetachedMutex.Lock()
	defer fake.isHeadDetachedMutex.Unlock()
	fake.IsHeadDetachedStub = nil
	if fake.isHeadDetachedReturnsOnCall == nil {
		fake.isHeadDetachedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isHeadDetachedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIStatusMgr) IsMerging() bool {
	fake.isMergingMutex.Lock()
	ret, specificReturn := fake.isMergingReturnsOnCall[len(fake.isMergingArgsForCall)]
	fake.isMergingArgsForCall = append(fake.isMergingArgsForCall, struct {
	}{})
	stub := fake.IsMergingStub
	fakeReturns := fake.isMergingReturns
	fake.recordInvocation("IsMerging", []interface{}{})
	fake.isMergingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIStatusMgr) IsMergingCallCount() int {
	fake.isMergingMutex.RLock()
	defer fake.isMergingMutex.RUnlock()
	return len(fake.isMergingArgsForCall)
}

func (fake *FakeIStatusMgr) IsMergingCalls(stub func() bool) {
	fake.isMergingMutex.Lock()
	defer fake.isMergingMutex.Unlock()
	fake.IsMergingStub = stub
}

func (fake *FakeIStatusMgr) IsMergingReturns(result1 bool) {
	fake.isMergingMutex.Lock()
	defer fake.isMergingMutex.Unlock()
	fake.IsMergingStub = nil
	fake.isMergingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIStatusMgr) IsMergingReturnsOnCall(i int, result1 bool) {
	fake.isMergingMutex.Lock()
	defer fake.isMergingMutex.Unlock()
	fake.IsMergingStub = nil
	if fake.isMergingReturnsOnCall == nil {
		fake.isMergingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isMergingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIStatusMgr) IsRebasing() bool {
	fake.isRebasingMutex.Lock()
	ret, specificReturn := fake.isRebasingReturnsOnCall[len(fake.isRebasingArgsForCall)]
	fake.isRebasingArgsForCall = append(fake.isRebasingArgsForCall, struct {
	}{})
	stub := fake.IsRebasingStub
	fakeReturns := fake.isRebasingReturns
	fake.recordInvocation("IsRebasing", []interface{}{})
	fake.isRebasingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIStatusMgr) IsRebasingCallCount() int {
	fake.isRebasingMutex.RLock()
	defer fake.isRebasingMutex.RUnlock()
	return len(fake.isRebasingArgsForCall)
}

func (fake *FakeIStatusMgr) IsRebasingCalls(stub func() bool) {
	fake.isRebasingMutex.Lock()
	defer fake.isRebasingMutex.Unlock()
	fake.IsRebasingStub = stub
}

func (fake *FakeIStatusMgr) IsRebasingReturns(result1 bool) {
	fake.isRebasingMutex.Lock()
	defer fake.isRebasingMutex.Unlock()
	fake.IsRebasingStub = nil
	fake.isRebasingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIStatusMgr) IsRebasingReturnsOnCall(i int, result1 bool) {
	fake.isRebasingMutex.Lock()
	defer fake.isRebasingMutex.Unlock()
	fake.IsRebasingStub = nil
	if fake.isRebasingReturnsOnCall == nil {
		fake.isRebasingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRebasingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIStatusMgr) RebaseMode() commands.RebasingMode {
	fake.rebaseModeMutex.Lock()
	ret, specificReturn := fake.rebaseModeReturnsOnCall[len(fake.rebaseModeArgsForCall)]
	fake.rebaseModeArgsForCall = append(fake.rebaseModeArgsForCall, struct {
	}{})
	stub := fake.RebaseModeStub
	fakeReturns := fake.rebaseModeReturns
	fake.recordInvocation("RebaseMode", []interface{}{})
	fake.rebaseModeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIStatusMgr) RebaseModeCallCount() int {
	fake.rebaseModeMutex.RLock()
	defer fake.rebaseModeMutex.RUnlock()
	return len(fake.rebaseModeArgsForCall)
}

func (fake *FakeIStatusMgr) RebaseModeCalls(stub func() commands.RebasingMode) {
	fake.rebaseModeMutex.Lock()
	defer fake.rebaseModeMutex.Unlock()
	fake.RebaseModeStub = stub
}

func (fake *FakeIStatusMgr) RebaseModeReturns(result1 commands.RebasingMode) {
	fake.rebaseModeMutex.Lock()
	defer fake.rebaseModeMutex.Unlock()
	fake.RebaseModeStub = nil
	fake.rebaseModeReturns = struct {
		result1 commands.RebasingMode
	}{result1}
}

func (fake *FakeIStatusMgr) RebaseModeReturnsOnCall(i int, result1 commands.RebasingMode) {
	fake.rebaseModeMutex.Lock()
	defer fake.rebaseModeMutex.Unlock()
	fake.RebaseModeStub = nil
	if fake.rebaseModeReturnsOnCall == nil {
		fake.rebaseModeReturnsOnCall = make(map[int]struct {
			result1 commands.RebasingMode
		})
	}
	fake.rebaseModeReturnsOnCall[i] = struct {
		result1 commands.RebasingMode
	}{result1}
}

func (fake *FakeIStatusMgr) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.currentBranchNameMutex.RLock()
	defer fake.currentBranchNameMutex.RUnlock()
	fake.inNormalWorkingTreeStateMutex.RLock()
	defer fake.inNormalWorkingTreeStateMutex.RUnlock()
	fake.isBareRepoMutex.RLock()
	defer fake.isBareRepoMutex.RUnlock()
	fake.isHeadDetachedMutex.RLock()
	defer fake.isHeadDetachedMutex.RUnlock()
	fake.isMergingMutex.RLock()
	defer fake.isMergingMutex.RUnlock()
	fake.isRebasingMutex.RLock()
	defer fake.isRebasingMutex.RUnlock()
	fake.rebaseModeMutex.RLock()
	defer fake.rebaseModeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIStatusMgr) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.IStatusMgr = new(FakeIStatusMgr)
