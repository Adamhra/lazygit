// Code generated by counterfeiter. DO NOT EDIT.
package commandsfakes

import (
	"sync"

	"github.com/jesseduffield/lazygit/pkg/commands"
	"github.com/jesseduffield/lazygit/pkg/commands/models"
	"github.com/jesseduffield/lazygit/pkg/commands/types"
)

type FakeISubmodulesMgr struct {
	AddStub        func(string, string, string) error
	addMutex       sync.RWMutex
	addArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	addReturns struct {
		result1 error
	}
	addReturnsOnCall map[int]struct {
		result1 error
	}
	BulkDeinitCmdObjStub        func() types.ICmdObj
	bulkDeinitCmdObjMutex       sync.RWMutex
	bulkDeinitCmdObjArgsForCall []struct {
	}
	bulkDeinitCmdObjReturns struct {
		result1 types.ICmdObj
	}
	bulkDeinitCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	BulkInitCmdObjStub        func() types.ICmdObj
	bulkInitCmdObjMutex       sync.RWMutex
	bulkInitCmdObjArgsForCall []struct {
	}
	bulkInitCmdObjReturns struct {
		result1 types.ICmdObj
	}
	bulkInitCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	BulkUpdateCmdObjStub        func() types.ICmdObj
	bulkUpdateCmdObjMutex       sync.RWMutex
	bulkUpdateCmdObjArgsForCall []struct {
	}
	bulkUpdateCmdObjReturns struct {
		result1 types.ICmdObj
	}
	bulkUpdateCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	DeleteStub        func(*models.SubmoduleConfig) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 *models.SubmoduleConfig
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	ForceBulkUpdateCmdObjStub        func() types.ICmdObj
	forceBulkUpdateCmdObjMutex       sync.RWMutex
	forceBulkUpdateCmdObjArgsForCall []struct {
	}
	forceBulkUpdateCmdObjReturns struct {
		result1 types.ICmdObj
	}
	forceBulkUpdateCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	GetConfigsStub        func() ([]*models.SubmoduleConfig, error)
	getConfigsMutex       sync.RWMutex
	getConfigsArgsForCall []struct {
	}
	getConfigsReturns struct {
		result1 []*models.SubmoduleConfig
		result2 error
	}
	getConfigsReturnsOnCall map[int]struct {
		result1 []*models.SubmoduleConfig
		result2 error
	}
	InitStub        func(string) error
	initMutex       sync.RWMutex
	initArgsForCall []struct {
		arg1 string
	}
	initReturns struct {
		result1 error
	}
	initReturnsOnCall map[int]struct {
		result1 error
	}
	ResetStub        func(*models.SubmoduleConfig) error
	resetMutex       sync.RWMutex
	resetArgsForCall []struct {
		arg1 *models.SubmoduleConfig
	}
	resetReturns struct {
		result1 error
	}
	resetReturnsOnCall map[int]struct {
		result1 error
	}
	StashStub        func(*models.SubmoduleConfig) error
	stashMutex       sync.RWMutex
	stashArgsForCall []struct {
		arg1 *models.SubmoduleConfig
	}
	stashReturns struct {
		result1 error
	}
	stashReturnsOnCall map[int]struct {
		result1 error
	}
	StashAndResetStub        func([]*models.SubmoduleConfig) error
	stashAndResetMutex       sync.RWMutex
	stashAndResetArgsForCall []struct {
		arg1 []*models.SubmoduleConfig
	}
	stashAndResetReturns struct {
		result1 error
	}
	stashAndResetReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateStub        func(string) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 string
	}
	updateReturns struct {
		result1 error
	}
	updateReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateUrlStub        func(string, string, string) error
	updateUrlMutex       sync.RWMutex
	updateUrlArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	updateUrlReturns struct {
		result1 error
	}
	updateUrlReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeISubmodulesMgr) Add(arg1 string, arg2 string, arg3 string) error {
	fake.addMutex.Lock()
	ret, specificReturn := fake.addReturnsOnCall[len(fake.addArgsForCall)]
	fake.addArgsForCall = append(fake.addArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AddStub
	fakeReturns := fake.addReturns
	fake.recordInvocation("Add", []interface{}{arg1, arg2, arg3})
	fake.addMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) AddCallCount() int {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	return len(fake.addArgsForCall)
}

func (fake *FakeISubmodulesMgr) AddCalls(stub func(string, string, string) error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = stub
}

func (fake *FakeISubmodulesMgr) AddArgsForCall(i int) (string, string, string) {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	argsForCall := fake.addArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeISubmodulesMgr) AddReturns(result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	fake.addReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) AddReturnsOnCall(i int, result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	if fake.addReturnsOnCall == nil {
		fake.addReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) BulkDeinitCmdObj() types.ICmdObj {
	fake.bulkDeinitCmdObjMutex.Lock()
	ret, specificReturn := fake.bulkDeinitCmdObjReturnsOnCall[len(fake.bulkDeinitCmdObjArgsForCall)]
	fake.bulkDeinitCmdObjArgsForCall = append(fake.bulkDeinitCmdObjArgsForCall, struct {
	}{})
	stub := fake.BulkDeinitCmdObjStub
	fakeReturns := fake.bulkDeinitCmdObjReturns
	fake.recordInvocation("BulkDeinitCmdObj", []interface{}{})
	fake.bulkDeinitCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) BulkDeinitCmdObjCallCount() int {
	fake.bulkDeinitCmdObjMutex.RLock()
	defer fake.bulkDeinitCmdObjMutex.RUnlock()
	return len(fake.bulkDeinitCmdObjArgsForCall)
}

func (fake *FakeISubmodulesMgr) BulkDeinitCmdObjCalls(stub func() types.ICmdObj) {
	fake.bulkDeinitCmdObjMutex.Lock()
	defer fake.bulkDeinitCmdObjMutex.Unlock()
	fake.BulkDeinitCmdObjStub = stub
}

func (fake *FakeISubmodulesMgr) BulkDeinitCmdObjReturns(result1 types.ICmdObj) {
	fake.bulkDeinitCmdObjMutex.Lock()
	defer fake.bulkDeinitCmdObjMutex.Unlock()
	fake.BulkDeinitCmdObjStub = nil
	fake.bulkDeinitCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeISubmodulesMgr) BulkDeinitCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.bulkDeinitCmdObjMutex.Lock()
	defer fake.bulkDeinitCmdObjMutex.Unlock()
	fake.BulkDeinitCmdObjStub = nil
	if fake.bulkDeinitCmdObjReturnsOnCall == nil {
		fake.bulkDeinitCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.bulkDeinitCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeISubmodulesMgr) BulkInitCmdObj() types.ICmdObj {
	fake.bulkInitCmdObjMutex.Lock()
	ret, specificReturn := fake.bulkInitCmdObjReturnsOnCall[len(fake.bulkInitCmdObjArgsForCall)]
	fake.bulkInitCmdObjArgsForCall = append(fake.bulkInitCmdObjArgsForCall, struct {
	}{})
	stub := fake.BulkInitCmdObjStub
	fakeReturns := fake.bulkInitCmdObjReturns
	fake.recordInvocation("BulkInitCmdObj", []interface{}{})
	fake.bulkInitCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) BulkInitCmdObjCallCount() int {
	fake.bulkInitCmdObjMutex.RLock()
	defer fake.bulkInitCmdObjMutex.RUnlock()
	return len(fake.bulkInitCmdObjArgsForCall)
}

func (fake *FakeISubmodulesMgr) BulkInitCmdObjCalls(stub func() types.ICmdObj) {
	fake.bulkInitCmdObjMutex.Lock()
	defer fake.bulkInitCmdObjMutex.Unlock()
	fake.BulkInitCmdObjStub = stub
}

func (fake *FakeISubmodulesMgr) BulkInitCmdObjReturns(result1 types.ICmdObj) {
	fake.bulkInitCmdObjMutex.Lock()
	defer fake.bulkInitCmdObjMutex.Unlock()
	fake.BulkInitCmdObjStub = nil
	fake.bulkInitCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeISubmodulesMgr) BulkInitCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.bulkInitCmdObjMutex.Lock()
	defer fake.bulkInitCmdObjMutex.Unlock()
	fake.BulkInitCmdObjStub = nil
	if fake.bulkInitCmdObjReturnsOnCall == nil {
		fake.bulkInitCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.bulkInitCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeISubmodulesMgr) BulkUpdateCmdObj() types.ICmdObj {
	fake.bulkUpdateCmdObjMutex.Lock()
	ret, specificReturn := fake.bulkUpdateCmdObjReturnsOnCall[len(fake.bulkUpdateCmdObjArgsForCall)]
	fake.bulkUpdateCmdObjArgsForCall = append(fake.bulkUpdateCmdObjArgsForCall, struct {
	}{})
	stub := fake.BulkUpdateCmdObjStub
	fakeReturns := fake.bulkUpdateCmdObjReturns
	fake.recordInvocation("BulkUpdateCmdObj", []interface{}{})
	fake.bulkUpdateCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) BulkUpdateCmdObjCallCount() int {
	fake.bulkUpdateCmdObjMutex.RLock()
	defer fake.bulkUpdateCmdObjMutex.RUnlock()
	return len(fake.bulkUpdateCmdObjArgsForCall)
}

func (fake *FakeISubmodulesMgr) BulkUpdateCmdObjCalls(stub func() types.ICmdObj) {
	fake.bulkUpdateCmdObjMutex.Lock()
	defer fake.bulkUpdateCmdObjMutex.Unlock()
	fake.BulkUpdateCmdObjStub = stub
}

func (fake *FakeISubmodulesMgr) BulkUpdateCmdObjReturns(result1 types.ICmdObj) {
	fake.bulkUpdateCmdObjMutex.Lock()
	defer fake.bulkUpdateCmdObjMutex.Unlock()
	fake.BulkUpdateCmdObjStub = nil
	fake.bulkUpdateCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeISubmodulesMgr) BulkUpdateCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.bulkUpdateCmdObjMutex.Lock()
	defer fake.bulkUpdateCmdObjMutex.Unlock()
	fake.BulkUpdateCmdObjStub = nil
	if fake.bulkUpdateCmdObjReturnsOnCall == nil {
		fake.bulkUpdateCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.bulkUpdateCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeISubmodulesMgr) Delete(arg1 *models.SubmoduleConfig) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 *models.SubmoduleConfig
	}{arg1})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeISubmodulesMgr) DeleteCalls(stub func(*models.SubmoduleConfig) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeISubmodulesMgr) DeleteArgsForCall(i int) *models.SubmoduleConfig {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeISubmodulesMgr) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) ForceBulkUpdateCmdObj() types.ICmdObj {
	fake.forceBulkUpdateCmdObjMutex.Lock()
	ret, specificReturn := fake.forceBulkUpdateCmdObjReturnsOnCall[len(fake.forceBulkUpdateCmdObjArgsForCall)]
	fake.forceBulkUpdateCmdObjArgsForCall = append(fake.forceBulkUpdateCmdObjArgsForCall, struct {
	}{})
	stub := fake.ForceBulkUpdateCmdObjStub
	fakeReturns := fake.forceBulkUpdateCmdObjReturns
	fake.recordInvocation("ForceBulkUpdateCmdObj", []interface{}{})
	fake.forceBulkUpdateCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) ForceBulkUpdateCmdObjCallCount() int {
	fake.forceBulkUpdateCmdObjMutex.RLock()
	defer fake.forceBulkUpdateCmdObjMutex.RUnlock()
	return len(fake.forceBulkUpdateCmdObjArgsForCall)
}

func (fake *FakeISubmodulesMgr) ForceBulkUpdateCmdObjCalls(stub func() types.ICmdObj) {
	fake.forceBulkUpdateCmdObjMutex.Lock()
	defer fake.forceBulkUpdateCmdObjMutex.Unlock()
	fake.ForceBulkUpdateCmdObjStub = stub
}

func (fake *FakeISubmodulesMgr) ForceBulkUpdateCmdObjReturns(result1 types.ICmdObj) {
	fake.forceBulkUpdateCmdObjMutex.Lock()
	defer fake.forceBulkUpdateCmdObjMutex.Unlock()
	fake.ForceBulkUpdateCmdObjStub = nil
	fake.forceBulkUpdateCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeISubmodulesMgr) ForceBulkUpdateCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.forceBulkUpdateCmdObjMutex.Lock()
	defer fake.forceBulkUpdateCmdObjMutex.Unlock()
	fake.ForceBulkUpdateCmdObjStub = nil
	if fake.forceBulkUpdateCmdObjReturnsOnCall == nil {
		fake.forceBulkUpdateCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.forceBulkUpdateCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeISubmodulesMgr) GetConfigs() ([]*models.SubmoduleConfig, error) {
	fake.getConfigsMutex.Lock()
	ret, specificReturn := fake.getConfigsReturnsOnCall[len(fake.getConfigsArgsForCall)]
	fake.getConfigsArgsForCall = append(fake.getConfigsArgsForCall, struct {
	}{})
	stub := fake.GetConfigsStub
	fakeReturns := fake.getConfigsReturns
	fake.recordInvocation("GetConfigs", []interface{}{})
	fake.getConfigsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeISubmodulesMgr) GetConfigsCallCount() int {
	fake.getConfigsMutex.RLock()
	defer fake.getConfigsMutex.RUnlock()
	return len(fake.getConfigsArgsForCall)
}

func (fake *FakeISubmodulesMgr) GetConfigsCalls(stub func() ([]*models.SubmoduleConfig, error)) {
	fake.getConfigsMutex.Lock()
	defer fake.getConfigsMutex.Unlock()
	fake.GetConfigsStub = stub
}

func (fake *FakeISubmodulesMgr) GetConfigsReturns(result1 []*models.SubmoduleConfig, result2 error) {
	fake.getConfigsMutex.Lock()
	defer fake.getConfigsMutex.Unlock()
	fake.GetConfigsStub = nil
	fake.getConfigsReturns = struct {
		result1 []*models.SubmoduleConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeISubmodulesMgr) GetConfigsReturnsOnCall(i int, result1 []*models.SubmoduleConfig, result2 error) {
	fake.getConfigsMutex.Lock()
	defer fake.getConfigsMutex.Unlock()
	fake.GetConfigsStub = nil
	if fake.getConfigsReturnsOnCall == nil {
		fake.getConfigsReturnsOnCall = make(map[int]struct {
			result1 []*models.SubmoduleConfig
			result2 error
		})
	}
	fake.getConfigsReturnsOnCall[i] = struct {
		result1 []*models.SubmoduleConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeISubmodulesMgr) Init(arg1 string) error {
	fake.initMutex.Lock()
	ret, specificReturn := fake.initReturnsOnCall[len(fake.initArgsForCall)]
	fake.initArgsForCall = append(fake.initArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.InitStub
	fakeReturns := fake.initReturns
	fake.recordInvocation("Init", []interface{}{arg1})
	fake.initMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) InitCallCount() int {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return len(fake.initArgsForCall)
}

func (fake *FakeISubmodulesMgr) InitCalls(stub func(string) error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = stub
}

func (fake *FakeISubmodulesMgr) InitArgsForCall(i int) string {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	argsForCall := fake.initArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeISubmodulesMgr) InitReturns(result1 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	fake.initReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) InitReturnsOnCall(i int, result1 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	if fake.initReturnsOnCall == nil {
		fake.initReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) Reset(arg1 *models.SubmoduleConfig) error {
	fake.resetMutex.Lock()
	ret, specificReturn := fake.resetReturnsOnCall[len(fake.resetArgsForCall)]
	fake.resetArgsForCall = append(fake.resetArgsForCall, struct {
		arg1 *models.SubmoduleConfig
	}{arg1})
	stub := fake.ResetStub
	fakeReturns := fake.resetReturns
	fake.recordInvocation("Reset", []interface{}{arg1})
	fake.resetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) ResetCallCount() int {
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	return len(fake.resetArgsForCall)
}

func (fake *FakeISubmodulesMgr) ResetCalls(stub func(*models.SubmoduleConfig) error) {
	fake.resetMutex.Lock()
	defer fake.resetMutex.Unlock()
	fake.ResetStub = stub
}

func (fake *FakeISubmodulesMgr) ResetArgsForCall(i int) *models.SubmoduleConfig {
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	argsForCall := fake.resetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeISubmodulesMgr) ResetReturns(result1 error) {
	fake.resetMutex.Lock()
	defer fake.resetMutex.Unlock()
	fake.ResetStub = nil
	fake.resetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) ResetReturnsOnCall(i int, result1 error) {
	fake.resetMutex.Lock()
	defer fake.resetMutex.Unlock()
	fake.ResetStub = nil
	if fake.resetReturnsOnCall == nil {
		fake.resetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) Stash(arg1 *models.SubmoduleConfig) error {
	fake.stashMutex.Lock()
	ret, specificReturn := fake.stashReturnsOnCall[len(fake.stashArgsForCall)]
	fake.stashArgsForCall = append(fake.stashArgsForCall, struct {
		arg1 *models.SubmoduleConfig
	}{arg1})
	stub := fake.StashStub
	fakeReturns := fake.stashReturns
	fake.recordInvocation("Stash", []interface{}{arg1})
	fake.stashMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) StashCallCount() int {
	fake.stashMutex.RLock()
	defer fake.stashMutex.RUnlock()
	return len(fake.stashArgsForCall)
}

func (fake *FakeISubmodulesMgr) StashCalls(stub func(*models.SubmoduleConfig) error) {
	fake.stashMutex.Lock()
	defer fake.stashMutex.Unlock()
	fake.StashStub = stub
}

func (fake *FakeISubmodulesMgr) StashArgsForCall(i int) *models.SubmoduleConfig {
	fake.stashMutex.RLock()
	defer fake.stashMutex.RUnlock()
	argsForCall := fake.stashArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeISubmodulesMgr) StashReturns(result1 error) {
	fake.stashMutex.Lock()
	defer fake.stashMutex.Unlock()
	fake.StashStub = nil
	fake.stashReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) StashReturnsOnCall(i int, result1 error) {
	fake.stashMutex.Lock()
	defer fake.stashMutex.Unlock()
	fake.StashStub = nil
	if fake.stashReturnsOnCall == nil {
		fake.stashReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stashReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) StashAndReset(arg1 []*models.SubmoduleConfig) error {
	var arg1Copy []*models.SubmoduleConfig
	if arg1 != nil {
		arg1Copy = make([]*models.SubmoduleConfig, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.stashAndResetMutex.Lock()
	ret, specificReturn := fake.stashAndResetReturnsOnCall[len(fake.stashAndResetArgsForCall)]
	fake.stashAndResetArgsForCall = append(fake.stashAndResetArgsForCall, struct {
		arg1 []*models.SubmoduleConfig
	}{arg1Copy})
	stub := fake.StashAndResetStub
	fakeReturns := fake.stashAndResetReturns
	fake.recordInvocation("StashAndReset", []interface{}{arg1Copy})
	fake.stashAndResetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) StashAndResetCallCount() int {
	fake.stashAndResetMutex.RLock()
	defer fake.stashAndResetMutex.RUnlock()
	return len(fake.stashAndResetArgsForCall)
}

func (fake *FakeISubmodulesMgr) StashAndResetCalls(stub func([]*models.SubmoduleConfig) error) {
	fake.stashAndResetMutex.Lock()
	defer fake.stashAndResetMutex.Unlock()
	fake.StashAndResetStub = stub
}

func (fake *FakeISubmodulesMgr) StashAndResetArgsForCall(i int) []*models.SubmoduleConfig {
	fake.stashAndResetMutex.RLock()
	defer fake.stashAndResetMutex.RUnlock()
	argsForCall := fake.stashAndResetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeISubmodulesMgr) StashAndResetReturns(result1 error) {
	fake.stashAndResetMutex.Lock()
	defer fake.stashAndResetMutex.Unlock()
	fake.StashAndResetStub = nil
	fake.stashAndResetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) StashAndResetReturnsOnCall(i int, result1 error) {
	fake.stashAndResetMutex.Lock()
	defer fake.stashAndResetMutex.Unlock()
	fake.StashAndResetStub = nil
	if fake.stashAndResetReturnsOnCall == nil {
		fake.stashAndResetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stashAndResetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) Update(arg1 string) error {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeISubmodulesMgr) UpdateCalls(stub func(string) error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeISubmodulesMgr) UpdateArgsForCall(i int) string {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeISubmodulesMgr) UpdateReturns(result1 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) UpdateReturnsOnCall(i int, result1 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) UpdateUrl(arg1 string, arg2 string, arg3 string) error {
	fake.updateUrlMutex.Lock()
	ret, specificReturn := fake.updateUrlReturnsOnCall[len(fake.updateUrlArgsForCall)]
	fake.updateUrlArgsForCall = append(fake.updateUrlArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdateUrlStub
	fakeReturns := fake.updateUrlReturns
	fake.recordInvocation("UpdateUrl", []interface{}{arg1, arg2, arg3})
	fake.updateUrlMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISubmodulesMgr) UpdateUrlCallCount() int {
	fake.updateUrlMutex.RLock()
	defer fake.updateUrlMutex.RUnlock()
	return len(fake.updateUrlArgsForCall)
}

func (fake *FakeISubmodulesMgr) UpdateUrlCalls(stub func(string, string, string) error) {
	fake.updateUrlMutex.Lock()
	defer fake.updateUrlMutex.Unlock()
	fake.UpdateUrlStub = stub
}

func (fake *FakeISubmodulesMgr) UpdateUrlArgsForCall(i int) (string, string, string) {
	fake.updateUrlMutex.RLock()
	defer fake.updateUrlMutex.RUnlock()
	argsForCall := fake.updateUrlArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeISubmodulesMgr) UpdateUrlReturns(result1 error) {
	fake.updateUrlMutex.Lock()
	defer fake.updateUrlMutex.Unlock()
	fake.UpdateUrlStub = nil
	fake.updateUrlReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) UpdateUrlReturnsOnCall(i int, result1 error) {
	fake.updateUrlMutex.Lock()
	defer fake.updateUrlMutex.Unlock()
	fake.UpdateUrlStub = nil
	if fake.updateUrlReturnsOnCall == nil {
		fake.updateUrlReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateUrlReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISubmodulesMgr) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	fake.bulkDeinitCmdObjMutex.RLock()
	defer fake.bulkDeinitCmdObjMutex.RUnlock()
	fake.bulkInitCmdObjMutex.RLock()
	defer fake.bulkInitCmdObjMutex.RUnlock()
	fake.bulkUpdateCmdObjMutex.RLock()
	defer fake.bulkUpdateCmdObjMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.forceBulkUpdateCmdObjMutex.RLock()
	defer fake.forceBulkUpdateCmdObjMutex.RUnlock()
	fake.getConfigsMutex.RLock()
	defer fake.getConfigsMutex.RUnlock()
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	fake.stashMutex.RLock()
	defer fake.stashMutex.RUnlock()
	fake.stashAndResetMutex.RLock()
	defer fake.stashAndResetMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.updateUrlMutex.RLock()
	defer fake.updateUrlMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeISubmodulesMgr) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.ISubmodulesMgr = new(FakeISubmodulesMgr)
