// Code generated by counterfeiter. DO NOT EDIT.
package commandsfakes

import (
	"sync"

	"github.com/jesseduffield/lazygit/pkg/commands"
	"github.com/jesseduffield/lazygit/pkg/commands/types"
)

type FakeISyncMgr struct {
	DeleteRemoteRefStub        func(string, string) error
	deleteRemoteRefMutex       sync.RWMutex
	deleteRemoteRefArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteRemoteRefReturns struct {
		result1 error
	}
	deleteRemoteRefReturnsOnCall map[int]struct {
		result1 error
	}
	FastForwardStub        func(string, string, string) error
	fastForwardMutex       sync.RWMutex
	fastForwardArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	fastForwardReturns struct {
		result1 error
	}
	fastForwardReturnsOnCall map[int]struct {
		result1 error
	}
	FetchStub        func(commands.FetchOptions) error
	fetchMutex       sync.RWMutex
	fetchArgsForCall []struct {
		arg1 commands.FetchOptions
	}
	fetchReturns struct {
		result1 error
	}
	fetchReturnsOnCall map[int]struct {
		result1 error
	}
	FetchInBackgroundStub        func(commands.FetchOptions) error
	fetchInBackgroundMutex       sync.RWMutex
	fetchInBackgroundArgsForCall []struct {
		arg1 commands.FetchOptions
	}
	fetchInBackgroundReturns struct {
		result1 error
	}
	fetchInBackgroundReturnsOnCall map[int]struct {
		result1 error
	}
	FetchRemoteStub        func(string) error
	fetchRemoteMutex       sync.RWMutex
	fetchRemoteArgsForCall []struct {
		arg1 string
	}
	fetchRemoteReturns struct {
		result1 error
	}
	fetchRemoteReturnsOnCall map[int]struct {
		result1 error
	}
	PushStub        func(commands.PushOpts) (bool, error)
	pushMutex       sync.RWMutex
	pushArgsForCall []struct {
		arg1 commands.PushOpts
	}
	pushReturns struct {
		result1 bool
		result2 error
	}
	pushReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PushRefStub        func(string, string) error
	pushRefMutex       sync.RWMutex
	pushRefArgsForCall []struct {
		arg1 string
		arg2 string
	}
	pushRefReturns struct {
		result1 error
	}
	pushRefReturnsOnCall map[int]struct {
		result1 error
	}
	SetCredentialHandlersStub        func(func(types.CredentialKind) string, func(error))
	setCredentialHandlersMutex       sync.RWMutex
	setCredentialHandlersArgsForCall []struct {
		arg1 func(types.CredentialKind) string
		arg2 func(error)
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeISyncMgr) DeleteRemoteRef(arg1 string, arg2 string) error {
	fake.deleteRemoteRefMutex.Lock()
	ret, specificReturn := fake.deleteRemoteRefReturnsOnCall[len(fake.deleteRemoteRefArgsForCall)]
	fake.deleteRemoteRefArgsForCall = append(fake.deleteRemoteRefArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteRemoteRefStub
	fakeReturns := fake.deleteRemoteRefReturns
	fake.recordInvocation("DeleteRemoteRef", []interface{}{arg1, arg2})
	fake.deleteRemoteRefMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISyncMgr) DeleteRemoteRefCallCount() int {
	fake.deleteRemoteRefMutex.RLock()
	defer fake.deleteRemoteRefMutex.RUnlock()
	return len(fake.deleteRemoteRefArgsForCall)
}

func (fake *FakeISyncMgr) DeleteRemoteRefCalls(stub func(string, string) error) {
	fake.deleteRemoteRefMutex.Lock()
	defer fake.deleteRemoteRefMutex.Unlock()
	fake.DeleteRemoteRefStub = stub
}

func (fake *FakeISyncMgr) DeleteRemoteRefArgsForCall(i int) (string, string) {
	fake.deleteRemoteRefMutex.RLock()
	defer fake.deleteRemoteRefMutex.RUnlock()
	argsForCall := fake.deleteRemoteRefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeISyncMgr) DeleteRemoteRefReturns(result1 error) {
	fake.deleteRemoteRefMutex.Lock()
	defer fake.deleteRemoteRefMutex.Unlock()
	fake.DeleteRemoteRefStub = nil
	fake.deleteRemoteRefReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) DeleteRemoteRefReturnsOnCall(i int, result1 error) {
	fake.deleteRemoteRefMutex.Lock()
	defer fake.deleteRemoteRefMutex.Unlock()
	fake.DeleteRemoteRefStub = nil
	if fake.deleteRemoteRefReturnsOnCall == nil {
		fake.deleteRemoteRefReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRemoteRefReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) FastForward(arg1 string, arg2 string, arg3 string) error {
	fake.fastForwardMutex.Lock()
	ret, specificReturn := fake.fastForwardReturnsOnCall[len(fake.fastForwardArgsForCall)]
	fake.fastForwardArgsForCall = append(fake.fastForwardArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FastForwardStub
	fakeReturns := fake.fastForwardReturns
	fake.recordInvocation("FastForward", []interface{}{arg1, arg2, arg3})
	fake.fastForwardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISyncMgr) FastForwardCallCount() int {
	fake.fastForwardMutex.RLock()
	defer fake.fastForwardMutex.RUnlock()
	return len(fake.fastForwardArgsForCall)
}

func (fake *FakeISyncMgr) FastForwardCalls(stub func(string, string, string) error) {
	fake.fastForwardMutex.Lock()
	defer fake.fastForwardMutex.Unlock()
	fake.FastForwardStub = stub
}

func (fake *FakeISyncMgr) FastForwardArgsForCall(i int) (string, string, string) {
	fake.fastForwardMutex.RLock()
	defer fake.fastForwardMutex.RUnlock()
	argsForCall := fake.fastForwardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeISyncMgr) FastForwardReturns(result1 error) {
	fake.fastForwardMutex.Lock()
	defer fake.fastForwardMutex.Unlock()
	fake.FastForwardStub = nil
	fake.fastForwardReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) FastForwardReturnsOnCall(i int, result1 error) {
	fake.fastForwardMutex.Lock()
	defer fake.fastForwardMutex.Unlock()
	fake.FastForwardStub = nil
	if fake.fastForwardReturnsOnCall == nil {
		fake.fastForwardReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fastForwardReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) Fetch(arg1 commands.FetchOptions) error {
	fake.fetchMutex.Lock()
	ret, specificReturn := fake.fetchReturnsOnCall[len(fake.fetchArgsForCall)]
	fake.fetchArgsForCall = append(fake.fetchArgsForCall, struct {
		arg1 commands.FetchOptions
	}{arg1})
	stub := fake.FetchStub
	fakeReturns := fake.fetchReturns
	fake.recordInvocation("Fetch", []interface{}{arg1})
	fake.fetchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISyncMgr) FetchCallCount() int {
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	return len(fake.fetchArgsForCall)
}

func (fake *FakeISyncMgr) FetchCalls(stub func(commands.FetchOptions) error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = stub
}

func (fake *FakeISyncMgr) FetchArgsForCall(i int) commands.FetchOptions {
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	argsForCall := fake.fetchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeISyncMgr) FetchReturns(result1 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	fake.fetchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) FetchReturnsOnCall(i int, result1 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	if fake.fetchReturnsOnCall == nil {
		fake.fetchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fetchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) FetchInBackground(arg1 commands.FetchOptions) error {
	fake.fetchInBackgroundMutex.Lock()
	ret, specificReturn := fake.fetchInBackgroundReturnsOnCall[len(fake.fetchInBackgroundArgsForCall)]
	fake.fetchInBackgroundArgsForCall = append(fake.fetchInBackgroundArgsForCall, struct {
		arg1 commands.FetchOptions
	}{arg1})
	stub := fake.FetchInBackgroundStub
	fakeReturns := fake.fetchInBackgroundReturns
	fake.recordInvocation("FetchInBackground", []interface{}{arg1})
	fake.fetchInBackgroundMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISyncMgr) FetchInBackgroundCallCount() int {
	fake.fetchInBackgroundMutex.RLock()
	defer fake.fetchInBackgroundMutex.RUnlock()
	return len(fake.fetchInBackgroundArgsForCall)
}

func (fake *FakeISyncMgr) FetchInBackgroundCalls(stub func(commands.FetchOptions) error) {
	fake.fetchInBackgroundMutex.Lock()
	defer fake.fetchInBackgroundMutex.Unlock()
	fake.FetchInBackgroundStub = stub
}

func (fake *FakeISyncMgr) FetchInBackgroundArgsForCall(i int) commands.FetchOptions {
	fake.fetchInBackgroundMutex.RLock()
	defer fake.fetchInBackgroundMutex.RUnlock()
	argsForCall := fake.fetchInBackgroundArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeISyncMgr) FetchInBackgroundReturns(result1 error) {
	fake.fetchInBackgroundMutex.Lock()
	defer fake.fetchInBackgroundMutex.Unlock()
	fake.FetchInBackgroundStub = nil
	fake.fetchInBackgroundReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) FetchInBackgroundReturnsOnCall(i int, result1 error) {
	fake.fetchInBackgroundMutex.Lock()
	defer fake.fetchInBackgroundMutex.Unlock()
	fake.FetchInBackgroundStub = nil
	if fake.fetchInBackgroundReturnsOnCall == nil {
		fake.fetchInBackgroundReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fetchInBackgroundReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) FetchRemote(arg1 string) error {
	fake.fetchRemoteMutex.Lock()
	ret, specificReturn := fake.fetchRemoteReturnsOnCall[len(fake.fetchRemoteArgsForCall)]
	fake.fetchRemoteArgsForCall = append(fake.fetchRemoteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FetchRemoteStub
	fakeReturns := fake.fetchRemoteReturns
	fake.recordInvocation("FetchRemote", []interface{}{arg1})
	fake.fetchRemoteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISyncMgr) FetchRemoteCallCount() int {
	fake.fetchRemoteMutex.RLock()
	defer fake.fetchRemoteMutex.RUnlock()
	return len(fake.fetchRemoteArgsForCall)
}

func (fake *FakeISyncMgr) FetchRemoteCalls(stub func(string) error) {
	fake.fetchRemoteMutex.Lock()
	defer fake.fetchRemoteMutex.Unlock()
	fake.FetchRemoteStub = stub
}

func (fake *FakeISyncMgr) FetchRemoteArgsForCall(i int) string {
	fake.fetchRemoteMutex.RLock()
	defer fake.fetchRemoteMutex.RUnlock()
	argsForCall := fake.fetchRemoteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeISyncMgr) FetchRemoteReturns(result1 error) {
	fake.fetchRemoteMutex.Lock()
	defer fake.fetchRemoteMutex.Unlock()
	fake.FetchRemoteStub = nil
	fake.fetchRemoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) FetchRemoteReturnsOnCall(i int, result1 error) {
	fake.fetchRemoteMutex.Lock()
	defer fake.fetchRemoteMutex.Unlock()
	fake.FetchRemoteStub = nil
	if fake.fetchRemoteReturnsOnCall == nil {
		fake.fetchRemoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fetchRemoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) Push(arg1 commands.PushOpts) (bool, error) {
	fake.pushMutex.Lock()
	ret, specificReturn := fake.pushReturnsOnCall[len(fake.pushArgsForCall)]
	fake.pushArgsForCall = append(fake.pushArgsForCall, struct {
		arg1 commands.PushOpts
	}{arg1})
	stub := fake.PushStub
	fakeReturns := fake.pushReturns
	fake.recordInvocation("Push", []interface{}{arg1})
	fake.pushMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeISyncMgr) PushCallCount() int {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	return len(fake.pushArgsForCall)
}

func (fake *FakeISyncMgr) PushCalls(stub func(commands.PushOpts) (bool, error)) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = stub
}

func (fake *FakeISyncMgr) PushArgsForCall(i int) commands.PushOpts {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	argsForCall := fake.pushArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeISyncMgr) PushReturns(result1 bool, result2 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	fake.pushReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeISyncMgr) PushReturnsOnCall(i int, result1 bool, result2 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	if fake.pushReturnsOnCall == nil {
		fake.pushReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.pushReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeISyncMgr) PushRef(arg1 string, arg2 string) error {
	fake.pushRefMutex.Lock()
	ret, specificReturn := fake.pushRefReturnsOnCall[len(fake.pushRefArgsForCall)]
	fake.pushRefArgsForCall = append(fake.pushRefArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.PushRefStub
	fakeReturns := fake.pushRefReturns
	fake.recordInvocation("PushRef", []interface{}{arg1, arg2})
	fake.pushRefMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeISyncMgr) PushRefCallCount() int {
	fake.pushRefMutex.RLock()
	defer fake.pushRefMutex.RUnlock()
	return len(fake.pushRefArgsForCall)
}

func (fake *FakeISyncMgr) PushRefCalls(stub func(string, string) error) {
	fake.pushRefMutex.Lock()
	defer fake.pushRefMutex.Unlock()
	fake.PushRefStub = stub
}

func (fake *FakeISyncMgr) PushRefArgsForCall(i int) (string, string) {
	fake.pushRefMutex.RLock()
	defer fake.pushRefMutex.RUnlock()
	argsForCall := fake.pushRefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeISyncMgr) PushRefReturns(result1 error) {
	fake.pushRefMutex.Lock()
	defer fake.pushRefMutex.Unlock()
	fake.PushRefStub = nil
	fake.pushRefReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) PushRefReturnsOnCall(i int, result1 error) {
	fake.pushRefMutex.Lock()
	defer fake.pushRefMutex.Unlock()
	fake.PushRefStub = nil
	if fake.pushRefReturnsOnCall == nil {
		fake.pushRefReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pushRefReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISyncMgr) SetCredentialHandlers(arg1 func(types.CredentialKind) string, arg2 func(error)) {
	fake.setCredentialHandlersMutex.Lock()
	fake.setCredentialHandlersArgsForCall = append(fake.setCredentialHandlersArgsForCall, struct {
		arg1 func(types.CredentialKind) string
		arg2 func(error)
	}{arg1, arg2})
	stub := fake.SetCredentialHandlersStub
	fake.recordInvocation("SetCredentialHandlers", []interface{}{arg1, arg2})
	fake.setCredentialHandlersMutex.Unlock()
	if stub != nil {
		fake.SetCredentialHandlersStub(arg1, arg2)
	}
}

func (fake *FakeISyncMgr) SetCredentialHandlersCallCount() int {
	fake.setCredentialHandlersMutex.RLock()
	defer fake.setCredentialHandlersMutex.RUnlock()
	return len(fake.setCredentialHandlersArgsForCall)
}

func (fake *FakeISyncMgr) SetCredentialHandlersCalls(stub func(func(types.CredentialKind) string, func(error))) {
	fake.setCredentialHandlersMutex.Lock()
	defer fake.setCredentialHandlersMutex.Unlock()
	fake.SetCredentialHandlersStub = stub
}

func (fake *FakeISyncMgr) SetCredentialHandlersArgsForCall(i int) (func(types.CredentialKind) string, func(error)) {
	fake.setCredentialHandlersMutex.RLock()
	defer fake.setCredentialHandlersMutex.RUnlock()
	argsForCall := fake.setCredentialHandlersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeISyncMgr) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteRemoteRefMutex.RLock()
	defer fake.deleteRemoteRefMutex.RUnlock()
	fake.fastForwardMutex.RLock()
	defer fake.fastForwardMutex.RUnlock()
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	fake.fetchInBackgroundMutex.RLock()
	defer fake.fetchInBackgroundMutex.RUnlock()
	fake.fetchRemoteMutex.RLock()
	defer fake.fetchRemoteMutex.RUnlock()
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	fake.pushRefMutex.RLock()
	defer fake.pushRefMutex.RUnlock()
	fake.setCredentialHandlersMutex.RLock()
	defer fake.setCredentialHandlersMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeISyncMgr) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.ISyncMgr = new(FakeISyncMgr)
