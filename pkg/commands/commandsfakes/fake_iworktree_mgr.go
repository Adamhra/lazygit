// Code generated by counterfeiter. DO NOT EDIT.
package commandsfakes

import (
	"sync"

	"github.com/jesseduffield/lazygit/pkg/commands"
	"github.com/jesseduffield/lazygit/pkg/commands/models"
	"github.com/jesseduffield/lazygit/pkg/commands/types"
	"github.com/jesseduffield/lazygit/pkg/gui/filetree"
)

type FakeIWorktreeMgr struct {
	CheckoutFileStub        func(string, string) error
	checkoutFileMutex       sync.RWMutex
	checkoutFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	checkoutFileReturns struct {
		result1 error
	}
	checkoutFileReturnsOnCall map[int]struct {
		result1 error
	}
	DiscardAllDirChangesStub        func(*filetree.FileNode) error
	discardAllDirChangesMutex       sync.RWMutex
	discardAllDirChangesArgsForCall []struct {
		arg1 *filetree.FileNode
	}
	discardAllDirChangesReturns struct {
		result1 error
	}
	discardAllDirChangesReturnsOnCall map[int]struct {
		result1 error
	}
	DiscardAllFileChangesStub        func(*models.File) error
	discardAllFileChangesMutex       sync.RWMutex
	discardAllFileChangesArgsForCall []struct {
		arg1 *models.File
	}
	discardAllFileChangesReturns struct {
		result1 error
	}
	discardAllFileChangesReturnsOnCall map[int]struct {
		result1 error
	}
	DiscardAnyUnstagedFileChangesStub        func() error
	discardAnyUnstagedFileChangesMutex       sync.RWMutex
	discardAnyUnstagedFileChangesArgsForCall []struct {
	}
	discardAnyUnstagedFileChangesReturns struct {
		result1 error
	}
	discardAnyUnstagedFileChangesReturnsOnCall map[int]struct {
		result1 error
	}
	DiscardUnstagedDirChangesStub        func(*filetree.FileNode) error
	discardUnstagedDirChangesMutex       sync.RWMutex
	discardUnstagedDirChangesArgsForCall []struct {
		arg1 *filetree.FileNode
	}
	discardUnstagedDirChangesReturns struct {
		result1 error
	}
	discardUnstagedDirChangesReturnsOnCall map[int]struct {
		result1 error
	}
	DiscardUnstagedFileChangesStub        func(string) error
	discardUnstagedFileChangesMutex       sync.RWMutex
	discardUnstagedFileChangesArgsForCall []struct {
		arg1 string
	}
	discardUnstagedFileChangesReturns struct {
		result1 error
	}
	discardUnstagedFileChangesReturnsOnCall map[int]struct {
		result1 error
	}
	EditFileCmdObjStub        func(string) (types.ICmdObj, error)
	editFileCmdObjMutex       sync.RWMutex
	editFileCmdObjArgsForCall []struct {
		arg1 string
	}
	editFileCmdObjReturns struct {
		result1 types.ICmdObj
		result2 error
	}
	editFileCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
		result2 error
	}
	IgnoreStub        func(string) error
	ignoreMutex       sync.RWMutex
	ignoreArgsForCall []struct {
		arg1 string
	}
	ignoreReturns struct {
		result1 error
	}
	ignoreReturnsOnCall map[int]struct {
		result1 error
	}
	LoadStatusFilesStub        func(commands.LoadStatusFilesOpts) []*models.File
	loadStatusFilesMutex       sync.RWMutex
	loadStatusFilesArgsForCall []struct {
		arg1 commands.LoadStatusFilesOpts
	}
	loadStatusFilesReturns struct {
		result1 []*models.File
	}
	loadStatusFilesReturnsOnCall map[int]struct {
		result1 []*models.File
	}
	OpenMergeToolCmdObjStub        func() types.ICmdObj
	openMergeToolCmdObjMutex       sync.RWMutex
	openMergeToolCmdObjArgsForCall []struct {
	}
	openMergeToolCmdObjReturns struct {
		result1 types.ICmdObj
	}
	openMergeToolCmdObjReturnsOnCall map[int]struct {
		result1 types.ICmdObj
	}
	RemoveTrackedFilesStub        func(string) error
	removeTrackedFilesMutex       sync.RWMutex
	removeTrackedFilesArgsForCall []struct {
		arg1 string
	}
	removeTrackedFilesReturns struct {
		result1 error
	}
	removeTrackedFilesReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveUntrackedFilesStub        func() error
	removeUntrackedFilesMutex       sync.RWMutex
	removeUntrackedFilesArgsForCall []struct {
	}
	removeUntrackedFilesReturns struct {
		result1 error
	}
	removeUntrackedFilesReturnsOnCall map[int]struct {
		result1 error
	}
	ResetAndCleanStub        func() error
	resetAndCleanMutex       sync.RWMutex
	resetAndCleanArgsForCall []struct {
	}
	resetAndCleanReturns struct {
		result1 error
	}
	resetAndCleanReturnsOnCall map[int]struct {
		result1 error
	}
	StageAllStub        func() error
	stageAllMutex       sync.RWMutex
	stageAllArgsForCall []struct {
	}
	stageAllReturns struct {
		result1 error
	}
	stageAllReturnsOnCall map[int]struct {
		result1 error
	}
	StageFileStub        func(string) error
	stageFileMutex       sync.RWMutex
	stageFileArgsForCall []struct {
		arg1 string
	}
	stageFileReturns struct {
		result1 error
	}
	stageFileReturnsOnCall map[int]struct {
		result1 error
	}
	UnStageFileStub        func([]string, bool) error
	unStageFileMutex       sync.RWMutex
	unStageFileArgsForCall []struct {
		arg1 []string
		arg2 bool
	}
	unStageFileReturns struct {
		result1 error
	}
	unStageFileReturnsOnCall map[int]struct {
		result1 error
	}
	UnstageAllStub        func() error
	unstageAllMutex       sync.RWMutex
	unstageAllArgsForCall []struct {
	}
	unstageAllReturns struct {
		result1 error
	}
	unstageAllReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIWorktreeMgr) CheckoutFile(arg1 string, arg2 string) error {
	fake.checkoutFileMutex.Lock()
	ret, specificReturn := fake.checkoutFileReturnsOnCall[len(fake.checkoutFileArgsForCall)]
	fake.checkoutFileArgsForCall = append(fake.checkoutFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CheckoutFileStub
	fakeReturns := fake.checkoutFileReturns
	fake.recordInvocation("CheckoutFile", []interface{}{arg1, arg2})
	fake.checkoutFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) CheckoutFileCallCount() int {
	fake.checkoutFileMutex.RLock()
	defer fake.checkoutFileMutex.RUnlock()
	return len(fake.checkoutFileArgsForCall)
}

func (fake *FakeIWorktreeMgr) CheckoutFileCalls(stub func(string, string) error) {
	fake.checkoutFileMutex.Lock()
	defer fake.checkoutFileMutex.Unlock()
	fake.CheckoutFileStub = stub
}

func (fake *FakeIWorktreeMgr) CheckoutFileArgsForCall(i int) (string, string) {
	fake.checkoutFileMutex.RLock()
	defer fake.checkoutFileMutex.RUnlock()
	argsForCall := fake.checkoutFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIWorktreeMgr) CheckoutFileReturns(result1 error) {
	fake.checkoutFileMutex.Lock()
	defer fake.checkoutFileMutex.Unlock()
	fake.CheckoutFileStub = nil
	fake.checkoutFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) CheckoutFileReturnsOnCall(i int, result1 error) {
	fake.checkoutFileMutex.Lock()
	defer fake.checkoutFileMutex.Unlock()
	fake.CheckoutFileStub = nil
	if fake.checkoutFileReturnsOnCall == nil {
		fake.checkoutFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkoutFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) DiscardAllDirChanges(arg1 *filetree.FileNode) error {
	fake.discardAllDirChangesMutex.Lock()
	ret, specificReturn := fake.discardAllDirChangesReturnsOnCall[len(fake.discardAllDirChangesArgsForCall)]
	fake.discardAllDirChangesArgsForCall = append(fake.discardAllDirChangesArgsForCall, struct {
		arg1 *filetree.FileNode
	}{arg1})
	stub := fake.DiscardAllDirChangesStub
	fakeReturns := fake.discardAllDirChangesReturns
	fake.recordInvocation("DiscardAllDirChanges", []interface{}{arg1})
	fake.discardAllDirChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) DiscardAllDirChangesCallCount() int {
	fake.discardAllDirChangesMutex.RLock()
	defer fake.discardAllDirChangesMutex.RUnlock()
	return len(fake.discardAllDirChangesArgsForCall)
}

func (fake *FakeIWorktreeMgr) DiscardAllDirChangesCalls(stub func(*filetree.FileNode) error) {
	fake.discardAllDirChangesMutex.Lock()
	defer fake.discardAllDirChangesMutex.Unlock()
	fake.DiscardAllDirChangesStub = stub
}

func (fake *FakeIWorktreeMgr) DiscardAllDirChangesArgsForCall(i int) *filetree.FileNode {
	fake.discardAllDirChangesMutex.RLock()
	defer fake.discardAllDirChangesMutex.RUnlock()
	argsForCall := fake.discardAllDirChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIWorktreeMgr) DiscardAllDirChangesReturns(result1 error) {
	fake.discardAllDirChangesMutex.Lock()
	defer fake.discardAllDirChangesMutex.Unlock()
	fake.DiscardAllDirChangesStub = nil
	fake.discardAllDirChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) DiscardAllDirChangesReturnsOnCall(i int, result1 error) {
	fake.discardAllDirChangesMutex.Lock()
	defer fake.discardAllDirChangesMutex.Unlock()
	fake.DiscardAllDirChangesStub = nil
	if fake.discardAllDirChangesReturnsOnCall == nil {
		fake.discardAllDirChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardAllDirChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) DiscardAllFileChanges(arg1 *models.File) error {
	fake.discardAllFileChangesMutex.Lock()
	ret, specificReturn := fake.discardAllFileChangesReturnsOnCall[len(fake.discardAllFileChangesArgsForCall)]
	fake.discardAllFileChangesArgsForCall = append(fake.discardAllFileChangesArgsForCall, struct {
		arg1 *models.File
	}{arg1})
	stub := fake.DiscardAllFileChangesStub
	fakeReturns := fake.discardAllFileChangesReturns
	fake.recordInvocation("DiscardAllFileChanges", []interface{}{arg1})
	fake.discardAllFileChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) DiscardAllFileChangesCallCount() int {
	fake.discardAllFileChangesMutex.RLock()
	defer fake.discardAllFileChangesMutex.RUnlock()
	return len(fake.discardAllFileChangesArgsForCall)
}

func (fake *FakeIWorktreeMgr) DiscardAllFileChangesCalls(stub func(*models.File) error) {
	fake.discardAllFileChangesMutex.Lock()
	defer fake.discardAllFileChangesMutex.Unlock()
	fake.DiscardAllFileChangesStub = stub
}

func (fake *FakeIWorktreeMgr) DiscardAllFileChangesArgsForCall(i int) *models.File {
	fake.discardAllFileChangesMutex.RLock()
	defer fake.discardAllFileChangesMutex.RUnlock()
	argsForCall := fake.discardAllFileChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIWorktreeMgr) DiscardAllFileChangesReturns(result1 error) {
	fake.discardAllFileChangesMutex.Lock()
	defer fake.discardAllFileChangesMutex.Unlock()
	fake.DiscardAllFileChangesStub = nil
	fake.discardAllFileChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) DiscardAllFileChangesReturnsOnCall(i int, result1 error) {
	fake.discardAllFileChangesMutex.Lock()
	defer fake.discardAllFileChangesMutex.Unlock()
	fake.DiscardAllFileChangesStub = nil
	if fake.discardAllFileChangesReturnsOnCall == nil {
		fake.discardAllFileChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardAllFileChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) DiscardAnyUnstagedFileChanges() error {
	fake.discardAnyUnstagedFileChangesMutex.Lock()
	ret, specificReturn := fake.discardAnyUnstagedFileChangesReturnsOnCall[len(fake.discardAnyUnstagedFileChangesArgsForCall)]
	fake.discardAnyUnstagedFileChangesArgsForCall = append(fake.discardAnyUnstagedFileChangesArgsForCall, struct {
	}{})
	stub := fake.DiscardAnyUnstagedFileChangesStub
	fakeReturns := fake.discardAnyUnstagedFileChangesReturns
	fake.recordInvocation("DiscardAnyUnstagedFileChanges", []interface{}{})
	fake.discardAnyUnstagedFileChangesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) DiscardAnyUnstagedFileChangesCallCount() int {
	fake.discardAnyUnstagedFileChangesMutex.RLock()
	defer fake.discardAnyUnstagedFileChangesMutex.RUnlock()
	return len(fake.discardAnyUnstagedFileChangesArgsForCall)
}

func (fake *FakeIWorktreeMgr) DiscardAnyUnstagedFileChangesCalls(stub func() error) {
	fake.discardAnyUnstagedFileChangesMutex.Lock()
	defer fake.discardAnyUnstagedFileChangesMutex.Unlock()
	fake.DiscardAnyUnstagedFileChangesStub = stub
}

func (fake *FakeIWorktreeMgr) DiscardAnyUnstagedFileChangesReturns(result1 error) {
	fake.discardAnyUnstagedFileChangesMutex.Lock()
	defer fake.discardAnyUnstagedFileChangesMutex.Unlock()
	fake.DiscardAnyUnstagedFileChangesStub = nil
	fake.discardAnyUnstagedFileChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) DiscardAnyUnstagedFileChangesReturnsOnCall(i int, result1 error) {
	fake.discardAnyUnstagedFileChangesMutex.Lock()
	defer fake.discardAnyUnstagedFileChangesMutex.Unlock()
	fake.DiscardAnyUnstagedFileChangesStub = nil
	if fake.discardAnyUnstagedFileChangesReturnsOnCall == nil {
		fake.discardAnyUnstagedFileChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardAnyUnstagedFileChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedDirChanges(arg1 *filetree.FileNode) error {
	fake.discardUnstagedDirChangesMutex.Lock()
	ret, specificReturn := fake.discardUnstagedDirChangesReturnsOnCall[len(fake.discardUnstagedDirChangesArgsForCall)]
	fake.discardUnstagedDirChangesArgsForCall = append(fake.discardUnstagedDirChangesArgsForCall, struct {
		arg1 *filetree.FileNode
	}{arg1})
	stub := fake.DiscardUnstagedDirChangesStub
	fakeReturns := fake.discardUnstagedDirChangesReturns
	fake.recordInvocation("DiscardUnstagedDirChanges", []interface{}{arg1})
	fake.discardUnstagedDirChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedDirChangesCallCount() int {
	fake.discardUnstagedDirChangesMutex.RLock()
	defer fake.discardUnstagedDirChangesMutex.RUnlock()
	return len(fake.discardUnstagedDirChangesArgsForCall)
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedDirChangesCalls(stub func(*filetree.FileNode) error) {
	fake.discardUnstagedDirChangesMutex.Lock()
	defer fake.discardUnstagedDirChangesMutex.Unlock()
	fake.DiscardUnstagedDirChangesStub = stub
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedDirChangesArgsForCall(i int) *filetree.FileNode {
	fake.discardUnstagedDirChangesMutex.RLock()
	defer fake.discardUnstagedDirChangesMutex.RUnlock()
	argsForCall := fake.discardUnstagedDirChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedDirChangesReturns(result1 error) {
	fake.discardUnstagedDirChangesMutex.Lock()
	defer fake.discardUnstagedDirChangesMutex.Unlock()
	fake.DiscardUnstagedDirChangesStub = nil
	fake.discardUnstagedDirChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedDirChangesReturnsOnCall(i int, result1 error) {
	fake.discardUnstagedDirChangesMutex.Lock()
	defer fake.discardUnstagedDirChangesMutex.Unlock()
	fake.DiscardUnstagedDirChangesStub = nil
	if fake.discardUnstagedDirChangesReturnsOnCall == nil {
		fake.discardUnstagedDirChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardUnstagedDirChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedFileChanges(arg1 string) error {
	fake.discardUnstagedFileChangesMutex.Lock()
	ret, specificReturn := fake.discardUnstagedFileChangesReturnsOnCall[len(fake.discardUnstagedFileChangesArgsForCall)]
	fake.discardUnstagedFileChangesArgsForCall = append(fake.discardUnstagedFileChangesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DiscardUnstagedFileChangesStub
	fakeReturns := fake.discardUnstagedFileChangesReturns
	fake.recordInvocation("DiscardUnstagedFileChanges", []interface{}{arg1})
	fake.discardUnstagedFileChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedFileChangesCallCount() int {
	fake.discardUnstagedFileChangesMutex.RLock()
	defer fake.discardUnstagedFileChangesMutex.RUnlock()
	return len(fake.discardUnstagedFileChangesArgsForCall)
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedFileChangesCalls(stub func(string) error) {
	fake.discardUnstagedFileChangesMutex.Lock()
	defer fake.discardUnstagedFileChangesMutex.Unlock()
	fake.DiscardUnstagedFileChangesStub = stub
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedFileChangesArgsForCall(i int) string {
	fake.discardUnstagedFileChangesMutex.RLock()
	defer fake.discardUnstagedFileChangesMutex.RUnlock()
	argsForCall := fake.discardUnstagedFileChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedFileChangesReturns(result1 error) {
	fake.discardUnstagedFileChangesMutex.Lock()
	defer fake.discardUnstagedFileChangesMutex.Unlock()
	fake.DiscardUnstagedFileChangesStub = nil
	fake.discardUnstagedFileChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) DiscardUnstagedFileChangesReturnsOnCall(i int, result1 error) {
	fake.discardUnstagedFileChangesMutex.Lock()
	defer fake.discardUnstagedFileChangesMutex.Unlock()
	fake.DiscardUnstagedFileChangesStub = nil
	if fake.discardUnstagedFileChangesReturnsOnCall == nil {
		fake.discardUnstagedFileChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.discardUnstagedFileChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) EditFileCmdObj(arg1 string) (types.ICmdObj, error) {
	fake.editFileCmdObjMutex.Lock()
	ret, specificReturn := fake.editFileCmdObjReturnsOnCall[len(fake.editFileCmdObjArgsForCall)]
	fake.editFileCmdObjArgsForCall = append(fake.editFileCmdObjArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.EditFileCmdObjStub
	fakeReturns := fake.editFileCmdObjReturns
	fake.recordInvocation("EditFileCmdObj", []interface{}{arg1})
	fake.editFileCmdObjMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIWorktreeMgr) EditFileCmdObjCallCount() int {
	fake.editFileCmdObjMutex.RLock()
	defer fake.editFileCmdObjMutex.RUnlock()
	return len(fake.editFileCmdObjArgsForCall)
}

func (fake *FakeIWorktreeMgr) EditFileCmdObjCalls(stub func(string) (types.ICmdObj, error)) {
	fake.editFileCmdObjMutex.Lock()
	defer fake.editFileCmdObjMutex.Unlock()
	fake.EditFileCmdObjStub = stub
}

func (fake *FakeIWorktreeMgr) EditFileCmdObjArgsForCall(i int) string {
	fake.editFileCmdObjMutex.RLock()
	defer fake.editFileCmdObjMutex.RUnlock()
	argsForCall := fake.editFileCmdObjArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIWorktreeMgr) EditFileCmdObjReturns(result1 types.ICmdObj, result2 error) {
	fake.editFileCmdObjMutex.Lock()
	defer fake.editFileCmdObjMutex.Unlock()
	fake.EditFileCmdObjStub = nil
	fake.editFileCmdObjReturns = struct {
		result1 types.ICmdObj
		result2 error
	}{result1, result2}
}

func (fake *FakeIWorktreeMgr) EditFileCmdObjReturnsOnCall(i int, result1 types.ICmdObj, result2 error) {
	fake.editFileCmdObjMutex.Lock()
	defer fake.editFileCmdObjMutex.Unlock()
	fake.EditFileCmdObjStub = nil
	if fake.editFileCmdObjReturnsOnCall == nil {
		fake.editFileCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
			result2 error
		})
	}
	fake.editFileCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
		result2 error
	}{result1, result2}
}

func (fake *FakeIWorktreeMgr) Ignore(arg1 string) error {
	fake.ignoreMutex.Lock()
	ret, specificReturn := fake.ignoreReturnsOnCall[len(fake.ignoreArgsForCall)]
	fake.ignoreArgsForCall = append(fake.ignoreArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IgnoreStub
	fakeReturns := fake.ignoreReturns
	fake.recordInvocation("Ignore", []interface{}{arg1})
	fake.ignoreMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) IgnoreCallCount() int {
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	return len(fake.ignoreArgsForCall)
}

func (fake *FakeIWorktreeMgr) IgnoreCalls(stub func(string) error) {
	fake.ignoreMutex.Lock()
	defer fake.ignoreMutex.Unlock()
	fake.IgnoreStub = stub
}

func (fake *FakeIWorktreeMgr) IgnoreArgsForCall(i int) string {
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	argsForCall := fake.ignoreArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIWorktreeMgr) IgnoreReturns(result1 error) {
	fake.ignoreMutex.Lock()
	defer fake.ignoreMutex.Unlock()
	fake.IgnoreStub = nil
	fake.ignoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) IgnoreReturnsOnCall(i int, result1 error) {
	fake.ignoreMutex.Lock()
	defer fake.ignoreMutex.Unlock()
	fake.IgnoreStub = nil
	if fake.ignoreReturnsOnCall == nil {
		fake.ignoreReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ignoreReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) LoadStatusFiles(arg1 commands.LoadStatusFilesOpts) []*models.File {
	fake.loadStatusFilesMutex.Lock()
	ret, specificReturn := fake.loadStatusFilesReturnsOnCall[len(fake.loadStatusFilesArgsForCall)]
	fake.loadStatusFilesArgsForCall = append(fake.loadStatusFilesArgsForCall, struct {
		arg1 commands.LoadStatusFilesOpts
	}{arg1})
	stub := fake.LoadStatusFilesStub
	fakeReturns := fake.loadStatusFilesReturns
	fake.recordInvocation("LoadStatusFiles", []interface{}{arg1})
	fake.loadStatusFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) LoadStatusFilesCallCount() int {
	fake.loadStatusFilesMutex.RLock()
	defer fake.loadStatusFilesMutex.RUnlock()
	return len(fake.loadStatusFilesArgsForCall)
}

func (fake *FakeIWorktreeMgr) LoadStatusFilesCalls(stub func(commands.LoadStatusFilesOpts) []*models.File) {
	fake.loadStatusFilesMutex.Lock()
	defer fake.loadStatusFilesMutex.Unlock()
	fake.LoadStatusFilesStub = stub
}

func (fake *FakeIWorktreeMgr) LoadStatusFilesArgsForCall(i int) commands.LoadStatusFilesOpts {
	fake.loadStatusFilesMutex.RLock()
	defer fake.loadStatusFilesMutex.RUnlock()
	argsForCall := fake.loadStatusFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIWorktreeMgr) LoadStatusFilesReturns(result1 []*models.File) {
	fake.loadStatusFilesMutex.Lock()
	defer fake.loadStatusFilesMutex.Unlock()
	fake.LoadStatusFilesStub = nil
	fake.loadStatusFilesReturns = struct {
		result1 []*models.File
	}{result1}
}

func (fake *FakeIWorktreeMgr) LoadStatusFilesReturnsOnCall(i int, result1 []*models.File) {
	fake.loadStatusFilesMutex.Lock()
	defer fake.loadStatusFilesMutex.Unlock()
	fake.LoadStatusFilesStub = nil
	if fake.loadStatusFilesReturnsOnCall == nil {
		fake.loadStatusFilesReturnsOnCall = make(map[int]struct {
			result1 []*models.File
		})
	}
	fake.loadStatusFilesReturnsOnCall[i] = struct {
		result1 []*models.File
	}{result1}
}

func (fake *FakeIWorktreeMgr) OpenMergeToolCmdObj() types.ICmdObj {
	fake.openMergeToolCmdObjMutex.Lock()
	ret, specificReturn := fake.openMergeToolCmdObjReturnsOnCall[len(fake.openMergeToolCmdObjArgsForCall)]
	fake.openMergeToolCmdObjArgsForCall = append(fake.openMergeToolCmdObjArgsForCall, struct {
	}{})
	stub := fake.OpenMergeToolCmdObjStub
	fakeReturns := fake.openMergeToolCmdObjReturns
	fake.recordInvocation("OpenMergeToolCmdObj", []interface{}{})
	fake.openMergeToolCmdObjMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) OpenMergeToolCmdObjCallCount() int {
	fake.openMergeToolCmdObjMutex.RLock()
	defer fake.openMergeToolCmdObjMutex.RUnlock()
	return len(fake.openMergeToolCmdObjArgsForCall)
}

func (fake *FakeIWorktreeMgr) OpenMergeToolCmdObjCalls(stub func() types.ICmdObj) {
	fake.openMergeToolCmdObjMutex.Lock()
	defer fake.openMergeToolCmdObjMutex.Unlock()
	fake.OpenMergeToolCmdObjStub = stub
}

func (fake *FakeIWorktreeMgr) OpenMergeToolCmdObjReturns(result1 types.ICmdObj) {
	fake.openMergeToolCmdObjMutex.Lock()
	defer fake.openMergeToolCmdObjMutex.Unlock()
	fake.OpenMergeToolCmdObjStub = nil
	fake.openMergeToolCmdObjReturns = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIWorktreeMgr) OpenMergeToolCmdObjReturnsOnCall(i int, result1 types.ICmdObj) {
	fake.openMergeToolCmdObjMutex.Lock()
	defer fake.openMergeToolCmdObjMutex.Unlock()
	fake.OpenMergeToolCmdObjStub = nil
	if fake.openMergeToolCmdObjReturnsOnCall == nil {
		fake.openMergeToolCmdObjReturnsOnCall = make(map[int]struct {
			result1 types.ICmdObj
		})
	}
	fake.openMergeToolCmdObjReturnsOnCall[i] = struct {
		result1 types.ICmdObj
	}{result1}
}

func (fake *FakeIWorktreeMgr) RemoveTrackedFiles(arg1 string) error {
	fake.removeTrackedFilesMutex.Lock()
	ret, specificReturn := fake.removeTrackedFilesReturnsOnCall[len(fake.removeTrackedFilesArgsForCall)]
	fake.removeTrackedFilesArgsForCall = append(fake.removeTrackedFilesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveTrackedFilesStub
	fakeReturns := fake.removeTrackedFilesReturns
	fake.recordInvocation("RemoveTrackedFiles", []interface{}{arg1})
	fake.removeTrackedFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) RemoveTrackedFilesCallCount() int {
	fake.removeTrackedFilesMutex.RLock()
	defer fake.removeTrackedFilesMutex.RUnlock()
	return len(fake.removeTrackedFilesArgsForCall)
}

func (fake *FakeIWorktreeMgr) RemoveTrackedFilesCalls(stub func(string) error) {
	fake.removeTrackedFilesMutex.Lock()
	defer fake.removeTrackedFilesMutex.Unlock()
	fake.RemoveTrackedFilesStub = stub
}

func (fake *FakeIWorktreeMgr) RemoveTrackedFilesArgsForCall(i int) string {
	fake.removeTrackedFilesMutex.RLock()
	defer fake.removeTrackedFilesMutex.RUnlock()
	argsForCall := fake.removeTrackedFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIWorktreeMgr) RemoveTrackedFilesReturns(result1 error) {
	fake.removeTrackedFilesMutex.Lock()
	defer fake.removeTrackedFilesMutex.Unlock()
	fake.RemoveTrackedFilesStub = nil
	fake.removeTrackedFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) RemoveTrackedFilesReturnsOnCall(i int, result1 error) {
	fake.removeTrackedFilesMutex.Lock()
	defer fake.removeTrackedFilesMutex.Unlock()
	fake.RemoveTrackedFilesStub = nil
	if fake.removeTrackedFilesReturnsOnCall == nil {
		fake.removeTrackedFilesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeTrackedFilesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) RemoveUntrackedFiles() error {
	fake.removeUntrackedFilesMutex.Lock()
	ret, specificReturn := fake.removeUntrackedFilesReturnsOnCall[len(fake.removeUntrackedFilesArgsForCall)]
	fake.removeUntrackedFilesArgsForCall = append(fake.removeUntrackedFilesArgsForCall, struct {
	}{})
	stub := fake.RemoveUntrackedFilesStub
	fakeReturns := fake.removeUntrackedFilesReturns
	fake.recordInvocation("RemoveUntrackedFiles", []interface{}{})
	fake.removeUntrackedFilesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) RemoveUntrackedFilesCallCount() int {
	fake.removeUntrackedFilesMutex.RLock()
	defer fake.removeUntrackedFilesMutex.RUnlock()
	return len(fake.removeUntrackedFilesArgsForCall)
}

func (fake *FakeIWorktreeMgr) RemoveUntrackedFilesCalls(stub func() error) {
	fake.removeUntrackedFilesMutex.Lock()
	defer fake.removeUntrackedFilesMutex.Unlock()
	fake.RemoveUntrackedFilesStub = stub
}

func (fake *FakeIWorktreeMgr) RemoveUntrackedFilesReturns(result1 error) {
	fake.removeUntrackedFilesMutex.Lock()
	defer fake.removeUntrackedFilesMutex.Unlock()
	fake.RemoveUntrackedFilesStub = nil
	fake.removeUntrackedFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) RemoveUntrackedFilesReturnsOnCall(i int, result1 error) {
	fake.removeUntrackedFilesMutex.Lock()
	defer fake.removeUntrackedFilesMutex.Unlock()
	fake.RemoveUntrackedFilesStub = nil
	if fake.removeUntrackedFilesReturnsOnCall == nil {
		fake.removeUntrackedFilesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeUntrackedFilesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) ResetAndClean() error {
	fake.resetAndCleanMutex.Lock()
	ret, specificReturn := fake.resetAndCleanReturnsOnCall[len(fake.resetAndCleanArgsForCall)]
	fake.resetAndCleanArgsForCall = append(fake.resetAndCleanArgsForCall, struct {
	}{})
	stub := fake.ResetAndCleanStub
	fakeReturns := fake.resetAndCleanReturns
	fake.recordInvocation("ResetAndClean", []interface{}{})
	fake.resetAndCleanMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) ResetAndCleanCallCount() int {
	fake.resetAndCleanMutex.RLock()
	defer fake.resetAndCleanMutex.RUnlock()
	return len(fake.resetAndCleanArgsForCall)
}

func (fake *FakeIWorktreeMgr) ResetAndCleanCalls(stub func() error) {
	fake.resetAndCleanMutex.Lock()
	defer fake.resetAndCleanMutex.Unlock()
	fake.ResetAndCleanStub = stub
}

func (fake *FakeIWorktreeMgr) ResetAndCleanReturns(result1 error) {
	fake.resetAndCleanMutex.Lock()
	defer fake.resetAndCleanMutex.Unlock()
	fake.ResetAndCleanStub = nil
	fake.resetAndCleanReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) ResetAndCleanReturnsOnCall(i int, result1 error) {
	fake.resetAndCleanMutex.Lock()
	defer fake.resetAndCleanMutex.Unlock()
	fake.ResetAndCleanStub = nil
	if fake.resetAndCleanReturnsOnCall == nil {
		fake.resetAndCleanReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetAndCleanReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) StageAll() error {
	fake.stageAllMutex.Lock()
	ret, specificReturn := fake.stageAllReturnsOnCall[len(fake.stageAllArgsForCall)]
	fake.stageAllArgsForCall = append(fake.stageAllArgsForCall, struct {
	}{})
	stub := fake.StageAllStub
	fakeReturns := fake.stageAllReturns
	fake.recordInvocation("StageAll", []interface{}{})
	fake.stageAllMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) StageAllCallCount() int {
	fake.stageAllMutex.RLock()
	defer fake.stageAllMutex.RUnlock()
	return len(fake.stageAllArgsForCall)
}

func (fake *FakeIWorktreeMgr) StageAllCalls(stub func() error) {
	fake.stageAllMutex.Lock()
	defer fake.stageAllMutex.Unlock()
	fake.StageAllStub = stub
}

func (fake *FakeIWorktreeMgr) StageAllReturns(result1 error) {
	fake.stageAllMutex.Lock()
	defer fake.stageAllMutex.Unlock()
	fake.StageAllStub = nil
	fake.stageAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) StageAllReturnsOnCall(i int, result1 error) {
	fake.stageAllMutex.Lock()
	defer fake.stageAllMutex.Unlock()
	fake.StageAllStub = nil
	if fake.stageAllReturnsOnCall == nil {
		fake.stageAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stageAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) StageFile(arg1 string) error {
	fake.stageFileMutex.Lock()
	ret, specificReturn := fake.stageFileReturnsOnCall[len(fake.stageFileArgsForCall)]
	fake.stageFileArgsForCall = append(fake.stageFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StageFileStub
	fakeReturns := fake.stageFileReturns
	fake.recordInvocation("StageFile", []interface{}{arg1})
	fake.stageFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) StageFileCallCount() int {
	fake.stageFileMutex.RLock()
	defer fake.stageFileMutex.RUnlock()
	return len(fake.stageFileArgsForCall)
}

func (fake *FakeIWorktreeMgr) StageFileCalls(stub func(string) error) {
	fake.stageFileMutex.Lock()
	defer fake.stageFileMutex.Unlock()
	fake.StageFileStub = stub
}

func (fake *FakeIWorktreeMgr) StageFileArgsForCall(i int) string {
	fake.stageFileMutex.RLock()
	defer fake.stageFileMutex.RUnlock()
	argsForCall := fake.stageFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIWorktreeMgr) StageFileReturns(result1 error) {
	fake.stageFileMutex.Lock()
	defer fake.stageFileMutex.Unlock()
	fake.StageFileStub = nil
	fake.stageFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) StageFileReturnsOnCall(i int, result1 error) {
	fake.stageFileMutex.Lock()
	defer fake.stageFileMutex.Unlock()
	fake.StageFileStub = nil
	if fake.stageFileReturnsOnCall == nil {
		fake.stageFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stageFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) UnStageFile(arg1 []string, arg2 bool) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.unStageFileMutex.Lock()
	ret, specificReturn := fake.unStageFileReturnsOnCall[len(fake.unStageFileArgsForCall)]
	fake.unStageFileArgsForCall = append(fake.unStageFileArgsForCall, struct {
		arg1 []string
		arg2 bool
	}{arg1Copy, arg2})
	stub := fake.UnStageFileStub
	fakeReturns := fake.unStageFileReturns
	fake.recordInvocation("UnStageFile", []interface{}{arg1Copy, arg2})
	fake.unStageFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) UnStageFileCallCount() int {
	fake.unStageFileMutex.RLock()
	defer fake.unStageFileMutex.RUnlock()
	return len(fake.unStageFileArgsForCall)
}

func (fake *FakeIWorktreeMgr) UnStageFileCalls(stub func([]string, bool) error) {
	fake.unStageFileMutex.Lock()
	defer fake.unStageFileMutex.Unlock()
	fake.UnStageFileStub = stub
}

func (fake *FakeIWorktreeMgr) UnStageFileArgsForCall(i int) ([]string, bool) {
	fake.unStageFileMutex.RLock()
	defer fake.unStageFileMutex.RUnlock()
	argsForCall := fake.unStageFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIWorktreeMgr) UnStageFileReturns(result1 error) {
	fake.unStageFileMutex.Lock()
	defer fake.unStageFileMutex.Unlock()
	fake.UnStageFileStub = nil
	fake.unStageFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) UnStageFileReturnsOnCall(i int, result1 error) {
	fake.unStageFileMutex.Lock()
	defer fake.unStageFileMutex.Unlock()
	fake.UnStageFileStub = nil
	if fake.unStageFileReturnsOnCall == nil {
		fake.unStageFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unStageFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) UnstageAll() error {
	fake.unstageAllMutex.Lock()
	ret, specificReturn := fake.unstageAllReturnsOnCall[len(fake.unstageAllArgsForCall)]
	fake.unstageAllArgsForCall = append(fake.unstageAllArgsForCall, struct {
	}{})
	stub := fake.UnstageAllStub
	fakeReturns := fake.unstageAllReturns
	fake.recordInvocation("UnstageAll", []interface{}{})
	fake.unstageAllMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIWorktreeMgr) UnstageAllCallCount() int {
	fake.unstageAllMutex.RLock()
	defer fake.unstageAllMutex.RUnlock()
	return len(fake.unstageAllArgsForCall)
}

func (fake *FakeIWorktreeMgr) UnstageAllCalls(stub func() error) {
	fake.unstageAllMutex.Lock()
	defer fake.unstageAllMutex.Unlock()
	fake.UnstageAllStub = stub
}

func (fake *FakeIWorktreeMgr) UnstageAllReturns(result1 error) {
	fake.unstageAllMutex.Lock()
	defer fake.unstageAllMutex.Unlock()
	fake.UnstageAllStub = nil
	fake.unstageAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) UnstageAllReturnsOnCall(i int, result1 error) {
	fake.unstageAllMutex.Lock()
	defer fake.unstageAllMutex.Unlock()
	fake.UnstageAllStub = nil
	if fake.unstageAllReturnsOnCall == nil {
		fake.unstageAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unstageAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIWorktreeMgr) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkoutFileMutex.RLock()
	defer fake.checkoutFileMutex.RUnlock()
	fake.discardAllDirChangesMutex.RLock()
	defer fake.discardAllDirChangesMutex.RUnlock()
	fake.discardAllFileChangesMutex.RLock()
	defer fake.discardAllFileChangesMutex.RUnlock()
	fake.discardAnyUnstagedFileChangesMutex.RLock()
	defer fake.discardAnyUnstagedFileChangesMutex.RUnlock()
	fake.discardUnstagedDirChangesMutex.RLock()
	defer fake.discardUnstagedDirChangesMutex.RUnlock()
	fake.discardUnstagedFileChangesMutex.RLock()
	defer fake.discardUnstagedFileChangesMutex.RUnlock()
	fake.editFileCmdObjMutex.RLock()
	defer fake.editFileCmdObjMutex.RUnlock()
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	fake.loadStatusFilesMutex.RLock()
	defer fake.loadStatusFilesMutex.RUnlock()
	fake.openMergeToolCmdObjMutex.RLock()
	defer fake.openMergeToolCmdObjMutex.RUnlock()
	fake.removeTrackedFilesMutex.RLock()
	defer fake.removeTrackedFilesMutex.RUnlock()
	fake.removeUntrackedFilesMutex.RLock()
	defer fake.removeUntrackedFilesMutex.RUnlock()
	fake.resetAndCleanMutex.RLock()
	defer fake.resetAndCleanMutex.RUnlock()
	fake.stageAllMutex.RLock()
	defer fake.stageAllMutex.RUnlock()
	fake.stageFileMutex.RLock()
	defer fake.stageFileMutex.RUnlock()
	fake.unStageFileMutex.RLock()
	defer fake.unStageFileMutex.RUnlock()
	fake.unstageAllMutex.RLock()
	defer fake.unstageAllMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIWorktreeMgr) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.IWorktreeMgr = new(FakeIWorktreeMgr)
