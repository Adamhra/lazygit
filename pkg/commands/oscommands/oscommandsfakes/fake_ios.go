// Code generated by counterfeiter. DO NOT EDIT.
package oscommandsfakes

import (
	"os/exec"
	"sync"

	"github.com/jesseduffield/lazygit/pkg/commands/oscommands"
	"github.com/jesseduffield/lazygit/pkg/commands/types"
)

type FakeIOS struct {
	AppendLineToFileStub        func(string, string) error
	appendLineToFileMutex       sync.RWMutex
	appendLineToFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	appendLineToFileReturns struct {
		result1 error
	}
	appendLineToFileReturnsOnCall map[int]struct {
		result1 error
	}
	CatFileStub        func(string) (string, error)
	catFileMutex       sync.RWMutex
	catFileArgsForCall []struct {
		arg1 string
	}
	catFileReturns struct {
		result1 string
		result2 error
	}
	catFileReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CopyToClipboardStub        func(string) error
	copyToClipboardMutex       sync.RWMutex
	copyToClipboardArgsForCall []struct {
		arg1 string
	}
	copyToClipboardReturns struct {
		result1 error
	}
	copyToClipboardReturnsOnCall map[int]struct {
		result1 error
	}
	CreateFileWithContentStub        func(string, string) error
	createFileWithContentMutex       sync.RWMutex
	createFileWithContentArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createFileWithContentReturns struct {
		result1 error
	}
	createFileWithContentReturnsOnCall map[int]struct {
		result1 error
	}
	CreateTempFileStub        func(string, string) (string, error)
	createTempFileMutex       sync.RWMutex
	createTempFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createTempFileReturns struct {
		result1 string
		result2 error
	}
	createTempFileReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FileExistsStub        func(string) (bool, error)
	fileExistsMutex       sync.RWMutex
	fileExistsArgsForCall []struct {
		arg1 string
	}
	fileExistsReturns struct {
		result1 bool
		result2 error
	}
	fileExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FileTypeStub        func(string) string
	fileTypeMutex       sync.RWMutex
	fileTypeArgsForCall []struct {
		arg1 string
	}
	fileTypeReturns struct {
		result1 string
	}
	fileTypeReturnsOnCall map[int]struct {
		result1 string
	}
	GetLazygitPathStub        func() string
	getLazygitPathMutex       sync.RWMutex
	getLazygitPathArgsForCall []struct {
	}
	getLazygitPathReturns struct {
		result1 string
	}
	getLazygitPathReturnsOnCall map[int]struct {
		result1 string
	}
	GetenvStub        func(string) string
	getenvMutex       sync.RWMutex
	getenvArgsForCall []struct {
		arg1 string
	}
	getenvReturns struct {
		result1 string
	}
	getenvReturnsOnCall map[int]struct {
		result1 string
	}
	LogCmdStub        func(types.ICmdObj)
	logCmdMutex       sync.RWMutex
	logCmdArgsForCall []struct {
		arg1 types.ICmdObj
	}
	LogCommandStub        func(string, bool)
	logCommandMutex       sync.RWMutex
	logCommandArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	OpenFileStub        func(string) error
	openFileMutex       sync.RWMutex
	openFileArgsForCall []struct {
		arg1 string
	}
	openFileReturns struct {
		result1 error
	}
	openFileReturnsOnCall map[int]struct {
		result1 error
	}
	OpenLinkStub        func(string) error
	openLinkMutex       sync.RWMutex
	openLinkArgsForCall []struct {
		arg1 string
	}
	openLinkReturns struct {
		result1 error
	}
	openLinkReturnsOnCall map[int]struct {
		result1 error
	}
	PipeCommandsStub        func(...types.ICmdObj) error
	pipeCommandsMutex       sync.RWMutex
	pipeCommandsArgsForCall []struct {
		arg1 []types.ICmdObj
	}
	pipeCommandsReturns struct {
		result1 error
	}
	pipeCommandsReturnsOnCall map[int]struct {
		result1 error
	}
	QuoteStub        func(string) string
	quoteMutex       sync.RWMutex
	quoteArgsForCall []struct {
		arg1 string
	}
	quoteReturns struct {
		result1 string
	}
	quoteReturnsOnCall map[int]struct {
		result1 string
	}
	RemoveStub        func(string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveFileStub        func(string) error
	removeFileMutex       sync.RWMutex
	removeFileArgsForCall []struct {
		arg1 string
	}
	removeFileReturns struct {
		result1 error
	}
	removeFileReturnsOnCall map[int]struct {
		result1 error
	}
	RunStub        func(types.ICmdObj) error
	runMutex       sync.RWMutex
	runArgsForCall []struct {
		arg1 types.ICmdObj
	}
	runReturns struct {
		result1 error
	}
	runReturnsOnCall map[int]struct {
		result1 error
	}
	RunAndParseLinesStub        func(types.ICmdObj, func(line string) (bool, error)) error
	runAndParseLinesMutex       sync.RWMutex
	runAndParseLinesArgsForCall []struct {
		arg1 types.ICmdObj
		arg2 func(line string) (bool, error)
	}
	runAndParseLinesReturns struct {
		result1 error
	}
	runAndParseLinesReturnsOnCall map[int]struct {
		result1 error
	}
	RunAndParseWordsStub        func(types.ICmdObj, func(string) string) error
	runAndParseWordsMutex       sync.RWMutex
	runAndParseWordsArgsForCall []struct {
		arg1 types.ICmdObj
		arg2 func(string) string
	}
	runAndParseWordsReturns struct {
		result1 error
	}
	runAndParseWordsReturnsOnCall map[int]struct {
		result1 error
	}
	RunWithOutputStub        func(types.ICmdObj) (string, error)
	runWithOutputMutex       sync.RWMutex
	runWithOutputArgsForCall []struct {
		arg1 types.ICmdObj
	}
	runWithOutputReturns struct {
		result1 string
		result2 error
	}
	runWithOutputReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SetCommandStub        func(func(string, ...string) *exec.Cmd)
	setCommandMutex       sync.RWMutex
	setCommandArgsForCall []struct {
		arg1 func(string, ...string) *exec.Cmd
	}
	SetOnRunCommandStub        func(func(oscommands.CmdLogEntry))
	setOnRunCommandMutex       sync.RWMutex
	setOnRunCommandArgsForCall []struct {
		arg1 func(oscommands.CmdLogEntry)
	}
	SetRemoveFileStub        func(func(string) error)
	setRemoveFileMutex       sync.RWMutex
	setRemoveFileArgsForCall []struct {
		arg1 func(string) error
	}
	WithSpanStub        func(string) oscommands.IOS
	withSpanMutex       sync.RWMutex
	withSpanArgsForCall []struct {
		arg1 string
	}
	withSpanReturns struct {
		result1 oscommands.IOS
	}
	withSpanReturnsOnCall map[int]struct {
		result1 oscommands.IOS
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIOS) AppendLineToFile(arg1 string, arg2 string) error {
	fake.appendLineToFileMutex.Lock()
	ret, specificReturn := fake.appendLineToFileReturnsOnCall[len(fake.appendLineToFileArgsForCall)]
	fake.appendLineToFileArgsForCall = append(fake.appendLineToFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AppendLineToFileStub
	fakeReturns := fake.appendLineToFileReturns
	fake.recordInvocation("AppendLineToFile", []interface{}{arg1, arg2})
	fake.appendLineToFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) AppendLineToFileCallCount() int {
	fake.appendLineToFileMutex.RLock()
	defer fake.appendLineToFileMutex.RUnlock()
	return len(fake.appendLineToFileArgsForCall)
}

func (fake *FakeIOS) AppendLineToFileCalls(stub func(string, string) error) {
	fake.appendLineToFileMutex.Lock()
	defer fake.appendLineToFileMutex.Unlock()
	fake.AppendLineToFileStub = stub
}

func (fake *FakeIOS) AppendLineToFileArgsForCall(i int) (string, string) {
	fake.appendLineToFileMutex.RLock()
	defer fake.appendLineToFileMutex.RUnlock()
	argsForCall := fake.appendLineToFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIOS) AppendLineToFileReturns(result1 error) {
	fake.appendLineToFileMutex.Lock()
	defer fake.appendLineToFileMutex.Unlock()
	fake.AppendLineToFileStub = nil
	fake.appendLineToFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) AppendLineToFileReturnsOnCall(i int, result1 error) {
	fake.appendLineToFileMutex.Lock()
	defer fake.appendLineToFileMutex.Unlock()
	fake.AppendLineToFileStub = nil
	if fake.appendLineToFileReturnsOnCall == nil {
		fake.appendLineToFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appendLineToFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) CatFile(arg1 string) (string, error) {
	fake.catFileMutex.Lock()
	ret, specificReturn := fake.catFileReturnsOnCall[len(fake.catFileArgsForCall)]
	fake.catFileArgsForCall = append(fake.catFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CatFileStub
	fakeReturns := fake.catFileReturns
	fake.recordInvocation("CatFile", []interface{}{arg1})
	fake.catFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIOS) CatFileCallCount() int {
	fake.catFileMutex.RLock()
	defer fake.catFileMutex.RUnlock()
	return len(fake.catFileArgsForCall)
}

func (fake *FakeIOS) CatFileCalls(stub func(string) (string, error)) {
	fake.catFileMutex.Lock()
	defer fake.catFileMutex.Unlock()
	fake.CatFileStub = stub
}

func (fake *FakeIOS) CatFileArgsForCall(i int) string {
	fake.catFileMutex.RLock()
	defer fake.catFileMutex.RUnlock()
	argsForCall := fake.catFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) CatFileReturns(result1 string, result2 error) {
	fake.catFileMutex.Lock()
	defer fake.catFileMutex.Unlock()
	fake.CatFileStub = nil
	fake.catFileReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIOS) CatFileReturnsOnCall(i int, result1 string, result2 error) {
	fake.catFileMutex.Lock()
	defer fake.catFileMutex.Unlock()
	fake.CatFileStub = nil
	if fake.catFileReturnsOnCall == nil {
		fake.catFileReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.catFileReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIOS) CopyToClipboard(arg1 string) error {
	fake.copyToClipboardMutex.Lock()
	ret, specificReturn := fake.copyToClipboardReturnsOnCall[len(fake.copyToClipboardArgsForCall)]
	fake.copyToClipboardArgsForCall = append(fake.copyToClipboardArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CopyToClipboardStub
	fakeReturns := fake.copyToClipboardReturns
	fake.recordInvocation("CopyToClipboard", []interface{}{arg1})
	fake.copyToClipboardMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) CopyToClipboardCallCount() int {
	fake.copyToClipboardMutex.RLock()
	defer fake.copyToClipboardMutex.RUnlock()
	return len(fake.copyToClipboardArgsForCall)
}

func (fake *FakeIOS) CopyToClipboardCalls(stub func(string) error) {
	fake.copyToClipboardMutex.Lock()
	defer fake.copyToClipboardMutex.Unlock()
	fake.CopyToClipboardStub = stub
}

func (fake *FakeIOS) CopyToClipboardArgsForCall(i int) string {
	fake.copyToClipboardMutex.RLock()
	defer fake.copyToClipboardMutex.RUnlock()
	argsForCall := fake.copyToClipboardArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) CopyToClipboardReturns(result1 error) {
	fake.copyToClipboardMutex.Lock()
	defer fake.copyToClipboardMutex.Unlock()
	fake.CopyToClipboardStub = nil
	fake.copyToClipboardReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) CopyToClipboardReturnsOnCall(i int, result1 error) {
	fake.copyToClipboardMutex.Lock()
	defer fake.copyToClipboardMutex.Unlock()
	fake.CopyToClipboardStub = nil
	if fake.copyToClipboardReturnsOnCall == nil {
		fake.copyToClipboardReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copyToClipboardReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) CreateFileWithContent(arg1 string, arg2 string) error {
	fake.createFileWithContentMutex.Lock()
	ret, specificReturn := fake.createFileWithContentReturnsOnCall[len(fake.createFileWithContentArgsForCall)]
	fake.createFileWithContentArgsForCall = append(fake.createFileWithContentArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateFileWithContentStub
	fakeReturns := fake.createFileWithContentReturns
	fake.recordInvocation("CreateFileWithContent", []interface{}{arg1, arg2})
	fake.createFileWithContentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) CreateFileWithContentCallCount() int {
	fake.createFileWithContentMutex.RLock()
	defer fake.createFileWithContentMutex.RUnlock()
	return len(fake.createFileWithContentArgsForCall)
}

func (fake *FakeIOS) CreateFileWithContentCalls(stub func(string, string) error) {
	fake.createFileWithContentMutex.Lock()
	defer fake.createFileWithContentMutex.Unlock()
	fake.CreateFileWithContentStub = stub
}

func (fake *FakeIOS) CreateFileWithContentArgsForCall(i int) (string, string) {
	fake.createFileWithContentMutex.RLock()
	defer fake.createFileWithContentMutex.RUnlock()
	argsForCall := fake.createFileWithContentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIOS) CreateFileWithContentReturns(result1 error) {
	fake.createFileWithContentMutex.Lock()
	defer fake.createFileWithContentMutex.Unlock()
	fake.CreateFileWithContentStub = nil
	fake.createFileWithContentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) CreateFileWithContentReturnsOnCall(i int, result1 error) {
	fake.createFileWithContentMutex.Lock()
	defer fake.createFileWithContentMutex.Unlock()
	fake.CreateFileWithContentStub = nil
	if fake.createFileWithContentReturnsOnCall == nil {
		fake.createFileWithContentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createFileWithContentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) CreateTempFile(arg1 string, arg2 string) (string, error) {
	fake.createTempFileMutex.Lock()
	ret, specificReturn := fake.createTempFileReturnsOnCall[len(fake.createTempFileArgsForCall)]
	fake.createTempFileArgsForCall = append(fake.createTempFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateTempFileStub
	fakeReturns := fake.createTempFileReturns
	fake.recordInvocation("CreateTempFile", []interface{}{arg1, arg2})
	fake.createTempFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIOS) CreateTempFileCallCount() int {
	fake.createTempFileMutex.RLock()
	defer fake.createTempFileMutex.RUnlock()
	return len(fake.createTempFileArgsForCall)
}

func (fake *FakeIOS) CreateTempFileCalls(stub func(string, string) (string, error)) {
	fake.createTempFileMutex.Lock()
	defer fake.createTempFileMutex.Unlock()
	fake.CreateTempFileStub = stub
}

func (fake *FakeIOS) CreateTempFileArgsForCall(i int) (string, string) {
	fake.createTempFileMutex.RLock()
	defer fake.createTempFileMutex.RUnlock()
	argsForCall := fake.createTempFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIOS) CreateTempFileReturns(result1 string, result2 error) {
	fake.createTempFileMutex.Lock()
	defer fake.createTempFileMutex.Unlock()
	fake.CreateTempFileStub = nil
	fake.createTempFileReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIOS) CreateTempFileReturnsOnCall(i int, result1 string, result2 error) {
	fake.createTempFileMutex.Lock()
	defer fake.createTempFileMutex.Unlock()
	fake.CreateTempFileStub = nil
	if fake.createTempFileReturnsOnCall == nil {
		fake.createTempFileReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createTempFileReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIOS) FileExists(arg1 string) (bool, error) {
	fake.fileExistsMutex.Lock()
	ret, specificReturn := fake.fileExistsReturnsOnCall[len(fake.fileExistsArgsForCall)]
	fake.fileExistsArgsForCall = append(fake.fileExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FileExistsStub
	fakeReturns := fake.fileExistsReturns
	fake.recordInvocation("FileExists", []interface{}{arg1})
	fake.fileExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIOS) FileExistsCallCount() int {
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	return len(fake.fileExistsArgsForCall)
}

func (fake *FakeIOS) FileExistsCalls(stub func(string) (bool, error)) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = stub
}

func (fake *FakeIOS) FileExistsArgsForCall(i int) string {
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	argsForCall := fake.fileExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) FileExistsReturns(result1 bool, result2 error) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = nil
	fake.fileExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIOS) FileExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = nil
	if fake.fileExistsReturnsOnCall == nil {
		fake.fileExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.fileExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIOS) FileType(arg1 string) string {
	fake.fileTypeMutex.Lock()
	ret, specificReturn := fake.fileTypeReturnsOnCall[len(fake.fileTypeArgsForCall)]
	fake.fileTypeArgsForCall = append(fake.fileTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FileTypeStub
	fakeReturns := fake.fileTypeReturns
	fake.recordInvocation("FileType", []interface{}{arg1})
	fake.fileTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) FileTypeCallCount() int {
	fake.fileTypeMutex.RLock()
	defer fake.fileTypeMutex.RUnlock()
	return len(fake.fileTypeArgsForCall)
}

func (fake *FakeIOS) FileTypeCalls(stub func(string) string) {
	fake.fileTypeMutex.Lock()
	defer fake.fileTypeMutex.Unlock()
	fake.FileTypeStub = stub
}

func (fake *FakeIOS) FileTypeArgsForCall(i int) string {
	fake.fileTypeMutex.RLock()
	defer fake.fileTypeMutex.RUnlock()
	argsForCall := fake.fileTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) FileTypeReturns(result1 string) {
	fake.fileTypeMutex.Lock()
	defer fake.fileTypeMutex.Unlock()
	fake.FileTypeStub = nil
	fake.fileTypeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIOS) FileTypeReturnsOnCall(i int, result1 string) {
	fake.fileTypeMutex.Lock()
	defer fake.fileTypeMutex.Unlock()
	fake.FileTypeStub = nil
	if fake.fileTypeReturnsOnCall == nil {
		fake.fileTypeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.fileTypeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIOS) GetLazygitPath() string {
	fake.getLazygitPathMutex.Lock()
	ret, specificReturn := fake.getLazygitPathReturnsOnCall[len(fake.getLazygitPathArgsForCall)]
	fake.getLazygitPathArgsForCall = append(fake.getLazygitPathArgsForCall, struct {
	}{})
	stub := fake.GetLazygitPathStub
	fakeReturns := fake.getLazygitPathReturns
	fake.recordInvocation("GetLazygitPath", []interface{}{})
	fake.getLazygitPathMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) GetLazygitPathCallCount() int {
	fake.getLazygitPathMutex.RLock()
	defer fake.getLazygitPathMutex.RUnlock()
	return len(fake.getLazygitPathArgsForCall)
}

func (fake *FakeIOS) GetLazygitPathCalls(stub func() string) {
	fake.getLazygitPathMutex.Lock()
	defer fake.getLazygitPathMutex.Unlock()
	fake.GetLazygitPathStub = stub
}

func (fake *FakeIOS) GetLazygitPathReturns(result1 string) {
	fake.getLazygitPathMutex.Lock()
	defer fake.getLazygitPathMutex.Unlock()
	fake.GetLazygitPathStub = nil
	fake.getLazygitPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIOS) GetLazygitPathReturnsOnCall(i int, result1 string) {
	fake.getLazygitPathMutex.Lock()
	defer fake.getLazygitPathMutex.Unlock()
	fake.GetLazygitPathStub = nil
	if fake.getLazygitPathReturnsOnCall == nil {
		fake.getLazygitPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getLazygitPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIOS) Getenv(arg1 string) string {
	fake.getenvMutex.Lock()
	ret, specificReturn := fake.getenvReturnsOnCall[len(fake.getenvArgsForCall)]
	fake.getenvArgsForCall = append(fake.getenvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetenvStub
	fakeReturns := fake.getenvReturns
	fake.recordInvocation("Getenv", []interface{}{arg1})
	fake.getenvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) GetenvCallCount() int {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return len(fake.getenvArgsForCall)
}

func (fake *FakeIOS) GetenvCalls(stub func(string) string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = stub
}

func (fake *FakeIOS) GetenvArgsForCall(i int) string {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	argsForCall := fake.getenvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) GetenvReturns(result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	fake.getenvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIOS) GetenvReturnsOnCall(i int, result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	if fake.getenvReturnsOnCall == nil {
		fake.getenvReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getenvReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIOS) LogCmd(arg1 types.ICmdObj) {
	fake.logCmdMutex.Lock()
	fake.logCmdArgsForCall = append(fake.logCmdArgsForCall, struct {
		arg1 types.ICmdObj
	}{arg1})
	stub := fake.LogCmdStub
	fake.recordInvocation("LogCmd", []interface{}{arg1})
	fake.logCmdMutex.Unlock()
	if stub != nil {
		fake.LogCmdStub(arg1)
	}
}

func (fake *FakeIOS) LogCmdCallCount() int {
	fake.logCmdMutex.RLock()
	defer fake.logCmdMutex.RUnlock()
	return len(fake.logCmdArgsForCall)
}

func (fake *FakeIOS) LogCmdCalls(stub func(types.ICmdObj)) {
	fake.logCmdMutex.Lock()
	defer fake.logCmdMutex.Unlock()
	fake.LogCmdStub = stub
}

func (fake *FakeIOS) LogCmdArgsForCall(i int) types.ICmdObj {
	fake.logCmdMutex.RLock()
	defer fake.logCmdMutex.RUnlock()
	argsForCall := fake.logCmdArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) LogCommand(arg1 string, arg2 bool) {
	fake.logCommandMutex.Lock()
	fake.logCommandArgsForCall = append(fake.logCommandArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	stub := fake.LogCommandStub
	fake.recordInvocation("LogCommand", []interface{}{arg1, arg2})
	fake.logCommandMutex.Unlock()
	if stub != nil {
		fake.LogCommandStub(arg1, arg2)
	}
}

func (fake *FakeIOS) LogCommandCallCount() int {
	fake.logCommandMutex.RLock()
	defer fake.logCommandMutex.RUnlock()
	return len(fake.logCommandArgsForCall)
}

func (fake *FakeIOS) LogCommandCalls(stub func(string, bool)) {
	fake.logCommandMutex.Lock()
	defer fake.logCommandMutex.Unlock()
	fake.LogCommandStub = stub
}

func (fake *FakeIOS) LogCommandArgsForCall(i int) (string, bool) {
	fake.logCommandMutex.RLock()
	defer fake.logCommandMutex.RUnlock()
	argsForCall := fake.logCommandArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIOS) OpenFile(arg1 string) error {
	fake.openFileMutex.Lock()
	ret, specificReturn := fake.openFileReturnsOnCall[len(fake.openFileArgsForCall)]
	fake.openFileArgsForCall = append(fake.openFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OpenFileStub
	fakeReturns := fake.openFileReturns
	fake.recordInvocation("OpenFile", []interface{}{arg1})
	fake.openFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) OpenFileCallCount() int {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	return len(fake.openFileArgsForCall)
}

func (fake *FakeIOS) OpenFileCalls(stub func(string) error) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = stub
}

func (fake *FakeIOS) OpenFileArgsForCall(i int) string {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	argsForCall := fake.openFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) OpenFileReturns(result1 error) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = nil
	fake.openFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) OpenFileReturnsOnCall(i int, result1 error) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = nil
	if fake.openFileReturnsOnCall == nil {
		fake.openFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.openFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) OpenLink(arg1 string) error {
	fake.openLinkMutex.Lock()
	ret, specificReturn := fake.openLinkReturnsOnCall[len(fake.openLinkArgsForCall)]
	fake.openLinkArgsForCall = append(fake.openLinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OpenLinkStub
	fakeReturns := fake.openLinkReturns
	fake.recordInvocation("OpenLink", []interface{}{arg1})
	fake.openLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) OpenLinkCallCount() int {
	fake.openLinkMutex.RLock()
	defer fake.openLinkMutex.RUnlock()
	return len(fake.openLinkArgsForCall)
}

func (fake *FakeIOS) OpenLinkCalls(stub func(string) error) {
	fake.openLinkMutex.Lock()
	defer fake.openLinkMutex.Unlock()
	fake.OpenLinkStub = stub
}

func (fake *FakeIOS) OpenLinkArgsForCall(i int) string {
	fake.openLinkMutex.RLock()
	defer fake.openLinkMutex.RUnlock()
	argsForCall := fake.openLinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) OpenLinkReturns(result1 error) {
	fake.openLinkMutex.Lock()
	defer fake.openLinkMutex.Unlock()
	fake.OpenLinkStub = nil
	fake.openLinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) OpenLinkReturnsOnCall(i int, result1 error) {
	fake.openLinkMutex.Lock()
	defer fake.openLinkMutex.Unlock()
	fake.OpenLinkStub = nil
	if fake.openLinkReturnsOnCall == nil {
		fake.openLinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.openLinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) PipeCommands(arg1 ...types.ICmdObj) error {
	fake.pipeCommandsMutex.Lock()
	ret, specificReturn := fake.pipeCommandsReturnsOnCall[len(fake.pipeCommandsArgsForCall)]
	fake.pipeCommandsArgsForCall = append(fake.pipeCommandsArgsForCall, struct {
		arg1 []types.ICmdObj
	}{arg1})
	stub := fake.PipeCommandsStub
	fakeReturns := fake.pipeCommandsReturns
	fake.recordInvocation("PipeCommands", []interface{}{arg1})
	fake.pipeCommandsMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) PipeCommandsCallCount() int {
	fake.pipeCommandsMutex.RLock()
	defer fake.pipeCommandsMutex.RUnlock()
	return len(fake.pipeCommandsArgsForCall)
}

func (fake *FakeIOS) PipeCommandsCalls(stub func(...types.ICmdObj) error) {
	fake.pipeCommandsMutex.Lock()
	defer fake.pipeCommandsMutex.Unlock()
	fake.PipeCommandsStub = stub
}

func (fake *FakeIOS) PipeCommandsArgsForCall(i int) []types.ICmdObj {
	fake.pipeCommandsMutex.RLock()
	defer fake.pipeCommandsMutex.RUnlock()
	argsForCall := fake.pipeCommandsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) PipeCommandsReturns(result1 error) {
	fake.pipeCommandsMutex.Lock()
	defer fake.pipeCommandsMutex.Unlock()
	fake.PipeCommandsStub = nil
	fake.pipeCommandsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) PipeCommandsReturnsOnCall(i int, result1 error) {
	fake.pipeCommandsMutex.Lock()
	defer fake.pipeCommandsMutex.Unlock()
	fake.PipeCommandsStub = nil
	if fake.pipeCommandsReturnsOnCall == nil {
		fake.pipeCommandsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pipeCommandsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) Quote(arg1 string) string {
	fake.quoteMutex.Lock()
	ret, specificReturn := fake.quoteReturnsOnCall[len(fake.quoteArgsForCall)]
	fake.quoteArgsForCall = append(fake.quoteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.QuoteStub
	fakeReturns := fake.quoteReturns
	fake.recordInvocation("Quote", []interface{}{arg1})
	fake.quoteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) QuoteCallCount() int {
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	return len(fake.quoteArgsForCall)
}

func (fake *FakeIOS) QuoteCalls(stub func(string) string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = stub
}

func (fake *FakeIOS) QuoteArgsForCall(i int) string {
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	argsForCall := fake.quoteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) QuoteReturns(result1 string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = nil
	fake.quoteReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIOS) QuoteReturnsOnCall(i int, result1 string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = nil
	if fake.quoteReturnsOnCall == nil {
		fake.quoteReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.quoteReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIOS) Remove(arg1 string) error {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveStub
	fakeReturns := fake.removeReturns
	fake.recordInvocation("Remove", []interface{}{arg1})
	fake.removeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeIOS) RemoveCalls(stub func(string) error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *FakeIOS) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) RemoveReturns(result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) RemoveReturnsOnCall(i int, result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) RemoveFile(arg1 string) error {
	fake.removeFileMutex.Lock()
	ret, specificReturn := fake.removeFileReturnsOnCall[len(fake.removeFileArgsForCall)]
	fake.removeFileArgsForCall = append(fake.removeFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveFileStub
	fakeReturns := fake.removeFileReturns
	fake.recordInvocation("RemoveFile", []interface{}{arg1})
	fake.removeFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) RemoveFileCallCount() int {
	fake.removeFileMutex.RLock()
	defer fake.removeFileMutex.RUnlock()
	return len(fake.removeFileArgsForCall)
}

func (fake *FakeIOS) RemoveFileCalls(stub func(string) error) {
	fake.removeFileMutex.Lock()
	defer fake.removeFileMutex.Unlock()
	fake.RemoveFileStub = stub
}

func (fake *FakeIOS) RemoveFileArgsForCall(i int) string {
	fake.removeFileMutex.RLock()
	defer fake.removeFileMutex.RUnlock()
	argsForCall := fake.removeFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) RemoveFileReturns(result1 error) {
	fake.removeFileMutex.Lock()
	defer fake.removeFileMutex.Unlock()
	fake.RemoveFileStub = nil
	fake.removeFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) RemoveFileReturnsOnCall(i int, result1 error) {
	fake.removeFileMutex.Lock()
	defer fake.removeFileMutex.Unlock()
	fake.RemoveFileStub = nil
	if fake.removeFileReturnsOnCall == nil {
		fake.removeFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) Run(arg1 types.ICmdObj) error {
	fake.runMutex.Lock()
	ret, specificReturn := fake.runReturnsOnCall[len(fake.runArgsForCall)]
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		arg1 types.ICmdObj
	}{arg1})
	stub := fake.RunStub
	fakeReturns := fake.runReturns
	fake.recordInvocation("Run", []interface{}{arg1})
	fake.runMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeIOS) RunCalls(stub func(types.ICmdObj) error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = stub
}

func (fake *FakeIOS) RunArgsForCall(i int) types.ICmdObj {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	argsForCall := fake.runArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) RunReturns(result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) RunReturnsOnCall(i int, result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	if fake.runReturnsOnCall == nil {
		fake.runReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) RunAndParseLines(arg1 types.ICmdObj, arg2 func(line string) (bool, error)) error {
	fake.runAndParseLinesMutex.Lock()
	ret, specificReturn := fake.runAndParseLinesReturnsOnCall[len(fake.runAndParseLinesArgsForCall)]
	fake.runAndParseLinesArgsForCall = append(fake.runAndParseLinesArgsForCall, struct {
		arg1 types.ICmdObj
		arg2 func(line string) (bool, error)
	}{arg1, arg2})
	stub := fake.RunAndParseLinesStub
	fakeReturns := fake.runAndParseLinesReturns
	fake.recordInvocation("RunAndParseLines", []interface{}{arg1, arg2})
	fake.runAndParseLinesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) RunAndParseLinesCallCount() int {
	fake.runAndParseLinesMutex.RLock()
	defer fake.runAndParseLinesMutex.RUnlock()
	return len(fake.runAndParseLinesArgsForCall)
}

func (fake *FakeIOS) RunAndParseLinesCalls(stub func(types.ICmdObj, func(line string) (bool, error)) error) {
	fake.runAndParseLinesMutex.Lock()
	defer fake.runAndParseLinesMutex.Unlock()
	fake.RunAndParseLinesStub = stub
}

func (fake *FakeIOS) RunAndParseLinesArgsForCall(i int) (types.ICmdObj, func(line string) (bool, error)) {
	fake.runAndParseLinesMutex.RLock()
	defer fake.runAndParseLinesMutex.RUnlock()
	argsForCall := fake.runAndParseLinesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIOS) RunAndParseLinesReturns(result1 error) {
	fake.runAndParseLinesMutex.Lock()
	defer fake.runAndParseLinesMutex.Unlock()
	fake.RunAndParseLinesStub = nil
	fake.runAndParseLinesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) RunAndParseLinesReturnsOnCall(i int, result1 error) {
	fake.runAndParseLinesMutex.Lock()
	defer fake.runAndParseLinesMutex.Unlock()
	fake.RunAndParseLinesStub = nil
	if fake.runAndParseLinesReturnsOnCall == nil {
		fake.runAndParseLinesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runAndParseLinesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) RunAndParseWords(arg1 types.ICmdObj, arg2 func(string) string) error {
	fake.runAndParseWordsMutex.Lock()
	ret, specificReturn := fake.runAndParseWordsReturnsOnCall[len(fake.runAndParseWordsArgsForCall)]
	fake.runAndParseWordsArgsForCall = append(fake.runAndParseWordsArgsForCall, struct {
		arg1 types.ICmdObj
		arg2 func(string) string
	}{arg1, arg2})
	stub := fake.RunAndParseWordsStub
	fakeReturns := fake.runAndParseWordsReturns
	fake.recordInvocation("RunAndParseWords", []interface{}{arg1, arg2})
	fake.runAndParseWordsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) RunAndParseWordsCallCount() int {
	fake.runAndParseWordsMutex.RLock()
	defer fake.runAndParseWordsMutex.RUnlock()
	return len(fake.runAndParseWordsArgsForCall)
}

func (fake *FakeIOS) RunAndParseWordsCalls(stub func(types.ICmdObj, func(string) string) error) {
	fake.runAndParseWordsMutex.Lock()
	defer fake.runAndParseWordsMutex.Unlock()
	fake.RunAndParseWordsStub = stub
}

func (fake *FakeIOS) RunAndParseWordsArgsForCall(i int) (types.ICmdObj, func(string) string) {
	fake.runAndParseWordsMutex.RLock()
	defer fake.runAndParseWordsMutex.RUnlock()
	argsForCall := fake.runAndParseWordsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIOS) RunAndParseWordsReturns(result1 error) {
	fake.runAndParseWordsMutex.Lock()
	defer fake.runAndParseWordsMutex.Unlock()
	fake.RunAndParseWordsStub = nil
	fake.runAndParseWordsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) RunAndParseWordsReturnsOnCall(i int, result1 error) {
	fake.runAndParseWordsMutex.Lock()
	defer fake.runAndParseWordsMutex.Unlock()
	fake.RunAndParseWordsStub = nil
	if fake.runAndParseWordsReturnsOnCall == nil {
		fake.runAndParseWordsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runAndParseWordsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIOS) RunWithOutput(arg1 types.ICmdObj) (string, error) {
	fake.runWithOutputMutex.Lock()
	ret, specificReturn := fake.runWithOutputReturnsOnCall[len(fake.runWithOutputArgsForCall)]
	fake.runWithOutputArgsForCall = append(fake.runWithOutputArgsForCall, struct {
		arg1 types.ICmdObj
	}{arg1})
	stub := fake.RunWithOutputStub
	fakeReturns := fake.runWithOutputReturns
	fake.recordInvocation("RunWithOutput", []interface{}{arg1})
	fake.runWithOutputMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIOS) RunWithOutputCallCount() int {
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	return len(fake.runWithOutputArgsForCall)
}

func (fake *FakeIOS) RunWithOutputCalls(stub func(types.ICmdObj) (string, error)) {
	fake.runWithOutputMutex.Lock()
	defer fake.runWithOutputMutex.Unlock()
	fake.RunWithOutputStub = stub
}

func (fake *FakeIOS) RunWithOutputArgsForCall(i int) types.ICmdObj {
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	argsForCall := fake.runWithOutputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) RunWithOutputReturns(result1 string, result2 error) {
	fake.runWithOutputMutex.Lock()
	defer fake.runWithOutputMutex.Unlock()
	fake.RunWithOutputStub = nil
	fake.runWithOutputReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIOS) RunWithOutputReturnsOnCall(i int, result1 string, result2 error) {
	fake.runWithOutputMutex.Lock()
	defer fake.runWithOutputMutex.Unlock()
	fake.RunWithOutputStub = nil
	if fake.runWithOutputReturnsOnCall == nil {
		fake.runWithOutputReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.runWithOutputReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIOS) SetCommand(arg1 func(string, ...string) *exec.Cmd) {
	fake.setCommandMutex.Lock()
	fake.setCommandArgsForCall = append(fake.setCommandArgsForCall, struct {
		arg1 func(string, ...string) *exec.Cmd
	}{arg1})
	stub := fake.SetCommandStub
	fake.recordInvocation("SetCommand", []interface{}{arg1})
	fake.setCommandMutex.Unlock()
	if stub != nil {
		fake.SetCommandStub(arg1)
	}
}

func (fake *FakeIOS) SetCommandCallCount() int {
	fake.setCommandMutex.RLock()
	defer fake.setCommandMutex.RUnlock()
	return len(fake.setCommandArgsForCall)
}

func (fake *FakeIOS) SetCommandCalls(stub func(func(string, ...string) *exec.Cmd)) {
	fake.setCommandMutex.Lock()
	defer fake.setCommandMutex.Unlock()
	fake.SetCommandStub = stub
}

func (fake *FakeIOS) SetCommandArgsForCall(i int) func(string, ...string) *exec.Cmd {
	fake.setCommandMutex.RLock()
	defer fake.setCommandMutex.RUnlock()
	argsForCall := fake.setCommandArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) SetOnRunCommand(arg1 func(oscommands.CmdLogEntry)) {
	fake.setOnRunCommandMutex.Lock()
	fake.setOnRunCommandArgsForCall = append(fake.setOnRunCommandArgsForCall, struct {
		arg1 func(oscommands.CmdLogEntry)
	}{arg1})
	stub := fake.SetOnRunCommandStub
	fake.recordInvocation("SetOnRunCommand", []interface{}{arg1})
	fake.setOnRunCommandMutex.Unlock()
	if stub != nil {
		fake.SetOnRunCommandStub(arg1)
	}
}

func (fake *FakeIOS) SetOnRunCommandCallCount() int {
	fake.setOnRunCommandMutex.RLock()
	defer fake.setOnRunCommandMutex.RUnlock()
	return len(fake.setOnRunCommandArgsForCall)
}

func (fake *FakeIOS) SetOnRunCommandCalls(stub func(func(oscommands.CmdLogEntry))) {
	fake.setOnRunCommandMutex.Lock()
	defer fake.setOnRunCommandMutex.Unlock()
	fake.SetOnRunCommandStub = stub
}

func (fake *FakeIOS) SetOnRunCommandArgsForCall(i int) func(oscommands.CmdLogEntry) {
	fake.setOnRunCommandMutex.RLock()
	defer fake.setOnRunCommandMutex.RUnlock()
	argsForCall := fake.setOnRunCommandArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) SetRemoveFile(arg1 func(string) error) {
	fake.setRemoveFileMutex.Lock()
	fake.setRemoveFileArgsForCall = append(fake.setRemoveFileArgsForCall, struct {
		arg1 func(string) error
	}{arg1})
	stub := fake.SetRemoveFileStub
	fake.recordInvocation("SetRemoveFile", []interface{}{arg1})
	fake.setRemoveFileMutex.Unlock()
	if stub != nil {
		fake.SetRemoveFileStub(arg1)
	}
}

func (fake *FakeIOS) SetRemoveFileCallCount() int {
	fake.setRemoveFileMutex.RLock()
	defer fake.setRemoveFileMutex.RUnlock()
	return len(fake.setRemoveFileArgsForCall)
}

func (fake *FakeIOS) SetRemoveFileCalls(stub func(func(string) error)) {
	fake.setRemoveFileMutex.Lock()
	defer fake.setRemoveFileMutex.Unlock()
	fake.SetRemoveFileStub = stub
}

func (fake *FakeIOS) SetRemoveFileArgsForCall(i int) func(string) error {
	fake.setRemoveFileMutex.RLock()
	defer fake.setRemoveFileMutex.RUnlock()
	argsForCall := fake.setRemoveFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) WithSpan(arg1 string) oscommands.IOS {
	fake.withSpanMutex.Lock()
	ret, specificReturn := fake.withSpanReturnsOnCall[len(fake.withSpanArgsForCall)]
	fake.withSpanArgsForCall = append(fake.withSpanArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WithSpanStub
	fakeReturns := fake.withSpanReturns
	fake.recordInvocation("WithSpan", []interface{}{arg1})
	fake.withSpanMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIOS) WithSpanCallCount() int {
	fake.withSpanMutex.RLock()
	defer fake.withSpanMutex.RUnlock()
	return len(fake.withSpanArgsForCall)
}

func (fake *FakeIOS) WithSpanCalls(stub func(string) oscommands.IOS) {
	fake.withSpanMutex.Lock()
	defer fake.withSpanMutex.Unlock()
	fake.WithSpanStub = stub
}

func (fake *FakeIOS) WithSpanArgsForCall(i int) string {
	fake.withSpanMutex.RLock()
	defer fake.withSpanMutex.RUnlock()
	argsForCall := fake.withSpanArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIOS) WithSpanReturns(result1 oscommands.IOS) {
	fake.withSpanMutex.Lock()
	defer fake.withSpanMutex.Unlock()
	fake.WithSpanStub = nil
	fake.withSpanReturns = struct {
		result1 oscommands.IOS
	}{result1}
}

func (fake *FakeIOS) WithSpanReturnsOnCall(i int, result1 oscommands.IOS) {
	fake.withSpanMutex.Lock()
	defer fake.withSpanMutex.Unlock()
	fake.WithSpanStub = nil
	if fake.withSpanReturnsOnCall == nil {
		fake.withSpanReturnsOnCall = make(map[int]struct {
			result1 oscommands.IOS
		})
	}
	fake.withSpanReturnsOnCall[i] = struct {
		result1 oscommands.IOS
	}{result1}
}

func (fake *FakeIOS) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appendLineToFileMutex.RLock()
	defer fake.appendLineToFileMutex.RUnlock()
	fake.catFileMutex.RLock()
	defer fake.catFileMutex.RUnlock()
	fake.copyToClipboardMutex.RLock()
	defer fake.copyToClipboardMutex.RUnlock()
	fake.createFileWithContentMutex.RLock()
	defer fake.createFileWithContentMutex.RUnlock()
	fake.createTempFileMutex.RLock()
	defer fake.createTempFileMutex.RUnlock()
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	fake.fileTypeMutex.RLock()
	defer fake.fileTypeMutex.RUnlock()
	fake.getLazygitPathMutex.RLock()
	defer fake.getLazygitPathMutex.RUnlock()
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	fake.logCmdMutex.RLock()
	defer fake.logCmdMutex.RUnlock()
	fake.logCommandMutex.RLock()
	defer fake.logCommandMutex.RUnlock()
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	fake.openLinkMutex.RLock()
	defer fake.openLinkMutex.RUnlock()
	fake.pipeCommandsMutex.RLock()
	defer fake.pipeCommandsMutex.RUnlock()
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.removeFileMutex.RLock()
	defer fake.removeFileMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.runAndParseLinesMutex.RLock()
	defer fake.runAndParseLinesMutex.RUnlock()
	fake.runAndParseWordsMutex.RLock()
	defer fake.runAndParseWordsMutex.RUnlock()
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	fake.setCommandMutex.RLock()
	defer fake.setCommandMutex.RUnlock()
	fake.setOnRunCommandMutex.RLock()
	defer fake.setOnRunCommandMutex.RUnlock()
	fake.setRemoveFileMutex.RLock()
	defer fake.setRemoveFileMutex.RUnlock()
	fake.withSpanMutex.RLock()
	defer fake.withSpanMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIOS) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ oscommands.IOS = new(FakeIOS)
