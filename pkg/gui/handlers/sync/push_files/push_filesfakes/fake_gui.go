// Code generated by counterfeiter. DO NOT EDIT.
package push_filesfakes

import (
	"sync"

	"github.com/jesseduffield/lazygit/pkg/commands"
	"github.com/jesseduffield/lazygit/pkg/commands/models"
	"github.com/jesseduffield/lazygit/pkg/config"
	"github.com/jesseduffield/lazygit/pkg/gui/types"
	"github.com/jesseduffield/lazygit/pkg/i18n"
)

type FakeGui struct {
	AskStub        func(types.AskOpts) error
	askMutex       sync.RWMutex
	askArgsForCall []struct {
		arg1 types.AskOpts
	}
	askReturns struct {
		result1 error
	}
	askReturnsOnCall map[int]struct {
		result1 error
	}
	CreateErrorPanelStub        func(string) error
	createErrorPanelMutex       sync.RWMutex
	createErrorPanelArgsForCall []struct {
		arg1 string
	}
	createErrorPanelReturns struct {
		result1 error
	}
	createErrorPanelReturnsOnCall map[int]struct {
		result1 error
	}
	CurrentBranchStub        func() *models.Branch
	currentBranchMutex       sync.RWMutex
	currentBranchArgsForCall []struct {
	}
	currentBranchReturns struct {
		result1 *models.Branch
	}
	currentBranchReturnsOnCall map[int]struct {
		result1 *models.Branch
	}
	GetGitCommandStub        func() commands.IGit
	getGitCommandMutex       sync.RWMutex
	getGitCommandArgsForCall []struct {
	}
	getGitCommandReturns struct {
		result1 commands.IGit
	}
	getGitCommandReturnsOnCall map[int]struct {
		result1 commands.IGit
	}
	GetTrStub        func() *i18n.TranslationSet
	getTrMutex       sync.RWMutex
	getTrArgsForCall []struct {
	}
	getTrReturns struct {
		result1 *i18n.TranslationSet
	}
	getTrReturnsOnCall map[int]struct {
		result1 *i18n.TranslationSet
	}
	GetUserConfigStub        func() *config.UserConfig
	getUserConfigMutex       sync.RWMutex
	getUserConfigArgsForCall []struct {
	}
	getUserConfigReturns struct {
		result1 *config.UserConfig
	}
	getUserConfigReturnsOnCall map[int]struct {
		result1 *config.UserConfig
	}
	InformOnCredentialsOutcomeStub        func(error)
	informOnCredentialsOutcomeMutex       sync.RWMutex
	informOnCredentialsOutcomeArgsForCall []struct {
		arg1 error
	}
	PopupPanelFocusedStub        func() bool
	popupPanelFocusedMutex       sync.RWMutex
	popupPanelFocusedArgsForCall []struct {
	}
	popupPanelFocusedReturns struct {
		result1 bool
	}
	popupPanelFocusedReturnsOnCall map[int]struct {
		result1 bool
	}
	PromptStub        func(types.PromptOpts) error
	promptMutex       sync.RWMutex
	promptArgsForCall []struct {
		arg1 types.PromptOpts
	}
	promptReturns struct {
		result1 error
	}
	promptReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshSidePanelsStub        func(types.RefreshOptions) error
	refreshSidePanelsMutex       sync.RWMutex
	refreshSidePanelsArgsForCall []struct {
		arg1 types.RefreshOptions
	}
	refreshSidePanelsReturns struct {
		result1 error
	}
	refreshSidePanelsReturnsOnCall map[int]struct {
		result1 error
	}
	SurfaceErrorStub        func(error) error
	surfaceErrorMutex       sync.RWMutex
	surfaceErrorArgsForCall []struct {
		arg1 error
	}
	surfaceErrorReturns struct {
		result1 error
	}
	surfaceErrorReturnsOnCall map[int]struct {
		result1 error
	}
	WithPopupWaitingStatusStub        func(string, func() error) error
	withPopupWaitingStatusMutex       sync.RWMutex
	withPopupWaitingStatusArgsForCall []struct {
		arg1 string
		arg2 func() error
	}
	withPopupWaitingStatusReturns struct {
		result1 error
	}
	withPopupWaitingStatusReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGui) Ask(arg1 types.AskOpts) error {
	fake.askMutex.Lock()
	ret, specificReturn := fake.askReturnsOnCall[len(fake.askArgsForCall)]
	fake.askArgsForCall = append(fake.askArgsForCall, struct {
		arg1 types.AskOpts
	}{arg1})
	stub := fake.AskStub
	fakeReturns := fake.askReturns
	fake.recordInvocation("Ask", []interface{}{arg1})
	fake.askMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGui) AskCallCount() int {
	fake.askMutex.RLock()
	defer fake.askMutex.RUnlock()
	return len(fake.askArgsForCall)
}

func (fake *FakeGui) AskCalls(stub func(types.AskOpts) error) {
	fake.askMutex.Lock()
	defer fake.askMutex.Unlock()
	fake.AskStub = stub
}

func (fake *FakeGui) AskArgsForCall(i int) types.AskOpts {
	fake.askMutex.RLock()
	defer fake.askMutex.RUnlock()
	argsForCall := fake.askArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGui) AskReturns(result1 error) {
	fake.askMutex.Lock()
	defer fake.askMutex.Unlock()
	fake.AskStub = nil
	fake.askReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) AskReturnsOnCall(i int, result1 error) {
	fake.askMutex.Lock()
	defer fake.askMutex.Unlock()
	fake.AskStub = nil
	if fake.askReturnsOnCall == nil {
		fake.askReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.askReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) CreateErrorPanel(arg1 string) error {
	fake.createErrorPanelMutex.Lock()
	ret, specificReturn := fake.createErrorPanelReturnsOnCall[len(fake.createErrorPanelArgsForCall)]
	fake.createErrorPanelArgsForCall = append(fake.createErrorPanelArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CreateErrorPanelStub
	fakeReturns := fake.createErrorPanelReturns
	fake.recordInvocation("CreateErrorPanel", []interface{}{arg1})
	fake.createErrorPanelMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGui) CreateErrorPanelCallCount() int {
	fake.createErrorPanelMutex.RLock()
	defer fake.createErrorPanelMutex.RUnlock()
	return len(fake.createErrorPanelArgsForCall)
}

func (fake *FakeGui) CreateErrorPanelCalls(stub func(string) error) {
	fake.createErrorPanelMutex.Lock()
	defer fake.createErrorPanelMutex.Unlock()
	fake.CreateErrorPanelStub = stub
}

func (fake *FakeGui) CreateErrorPanelArgsForCall(i int) string {
	fake.createErrorPanelMutex.RLock()
	defer fake.createErrorPanelMutex.RUnlock()
	argsForCall := fake.createErrorPanelArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGui) CreateErrorPanelReturns(result1 error) {
	fake.createErrorPanelMutex.Lock()
	defer fake.createErrorPanelMutex.Unlock()
	fake.CreateErrorPanelStub = nil
	fake.createErrorPanelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) CreateErrorPanelReturnsOnCall(i int, result1 error) {
	fake.createErrorPanelMutex.Lock()
	defer fake.createErrorPanelMutex.Unlock()
	fake.CreateErrorPanelStub = nil
	if fake.createErrorPanelReturnsOnCall == nil {
		fake.createErrorPanelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createErrorPanelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) CurrentBranch() *models.Branch {
	fake.currentBranchMutex.Lock()
	ret, specificReturn := fake.currentBranchReturnsOnCall[len(fake.currentBranchArgsForCall)]
	fake.currentBranchArgsForCall = append(fake.currentBranchArgsForCall, struct {
	}{})
	stub := fake.CurrentBranchStub
	fakeReturns := fake.currentBranchReturns
	fake.recordInvocation("CurrentBranch", []interface{}{})
	fake.currentBranchMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGui) CurrentBranchCallCount() int {
	fake.currentBranchMutex.RLock()
	defer fake.currentBranchMutex.RUnlock()
	return len(fake.currentBranchArgsForCall)
}

func (fake *FakeGui) CurrentBranchCalls(stub func() *models.Branch) {
	fake.currentBranchMutex.Lock()
	defer fake.currentBranchMutex.Unlock()
	fake.CurrentBranchStub = stub
}

func (fake *FakeGui) CurrentBranchReturns(result1 *models.Branch) {
	fake.currentBranchMutex.Lock()
	defer fake.currentBranchMutex.Unlock()
	fake.CurrentBranchStub = nil
	fake.currentBranchReturns = struct {
		result1 *models.Branch
	}{result1}
}

func (fake *FakeGui) CurrentBranchReturnsOnCall(i int, result1 *models.Branch) {
	fake.currentBranchMutex.Lock()
	defer fake.currentBranchMutex.Unlock()
	fake.CurrentBranchStub = nil
	if fake.currentBranchReturnsOnCall == nil {
		fake.currentBranchReturnsOnCall = make(map[int]struct {
			result1 *models.Branch
		})
	}
	fake.currentBranchReturnsOnCall[i] = struct {
		result1 *models.Branch
	}{result1}
}

func (fake *FakeGui) GetGitCommand() commands.IGit {
	fake.getGitCommandMutex.Lock()
	ret, specificReturn := fake.getGitCommandReturnsOnCall[len(fake.getGitCommandArgsForCall)]
	fake.getGitCommandArgsForCall = append(fake.getGitCommandArgsForCall, struct {
	}{})
	stub := fake.GetGitCommandStub
	fakeReturns := fake.getGitCommandReturns
	fake.recordInvocation("GetGitCommand", []interface{}{})
	fake.getGitCommandMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGui) GetGitCommandCallCount() int {
	fake.getGitCommandMutex.RLock()
	defer fake.getGitCommandMutex.RUnlock()
	return len(fake.getGitCommandArgsForCall)
}

func (fake *FakeGui) GetGitCommandCalls(stub func() commands.IGit) {
	fake.getGitCommandMutex.Lock()
	defer fake.getGitCommandMutex.Unlock()
	fake.GetGitCommandStub = stub
}

func (fake *FakeGui) GetGitCommandReturns(result1 commands.IGit) {
	fake.getGitCommandMutex.Lock()
	defer fake.getGitCommandMutex.Unlock()
	fake.GetGitCommandStub = nil
	fake.getGitCommandReturns = struct {
		result1 commands.IGit
	}{result1}
}

func (fake *FakeGui) GetGitCommandReturnsOnCall(i int, result1 commands.IGit) {
	fake.getGitCommandMutex.Lock()
	defer fake.getGitCommandMutex.Unlock()
	fake.GetGitCommandStub = nil
	if fake.getGitCommandReturnsOnCall == nil {
		fake.getGitCommandReturnsOnCall = make(map[int]struct {
			result1 commands.IGit
		})
	}
	fake.getGitCommandReturnsOnCall[i] = struct {
		result1 commands.IGit
	}{result1}
}

func (fake *FakeGui) GetTr() *i18n.TranslationSet {
	fake.getTrMutex.Lock()
	ret, specificReturn := fake.getTrReturnsOnCall[len(fake.getTrArgsForCall)]
	fake.getTrArgsForCall = append(fake.getTrArgsForCall, struct {
	}{})
	stub := fake.GetTrStub
	fakeReturns := fake.getTrReturns
	fake.recordInvocation("GetTr", []interface{}{})
	fake.getTrMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGui) GetTrCallCount() int {
	fake.getTrMutex.RLock()
	defer fake.getTrMutex.RUnlock()
	return len(fake.getTrArgsForCall)
}

func (fake *FakeGui) GetTrCalls(stub func() *i18n.TranslationSet) {
	fake.getTrMutex.Lock()
	defer fake.getTrMutex.Unlock()
	fake.GetTrStub = stub
}

func (fake *FakeGui) GetTrReturns(result1 *i18n.TranslationSet) {
	fake.getTrMutex.Lock()
	defer fake.getTrMutex.Unlock()
	fake.GetTrStub = nil
	fake.getTrReturns = struct {
		result1 *i18n.TranslationSet
	}{result1}
}

func (fake *FakeGui) GetTrReturnsOnCall(i int, result1 *i18n.TranslationSet) {
	fake.getTrMutex.Lock()
	defer fake.getTrMutex.Unlock()
	fake.GetTrStub = nil
	if fake.getTrReturnsOnCall == nil {
		fake.getTrReturnsOnCall = make(map[int]struct {
			result1 *i18n.TranslationSet
		})
	}
	fake.getTrReturnsOnCall[i] = struct {
		result1 *i18n.TranslationSet
	}{result1}
}

func (fake *FakeGui) GetUserConfig() *config.UserConfig {
	fake.getUserConfigMutex.Lock()
	ret, specificReturn := fake.getUserConfigReturnsOnCall[len(fake.getUserConfigArgsForCall)]
	fake.getUserConfigArgsForCall = append(fake.getUserConfigArgsForCall, struct {
	}{})
	stub := fake.GetUserConfigStub
	fakeReturns := fake.getUserConfigReturns
	fake.recordInvocation("GetUserConfig", []interface{}{})
	fake.getUserConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGui) GetUserConfigCallCount() int {
	fake.getUserConfigMutex.RLock()
	defer fake.getUserConfigMutex.RUnlock()
	return len(fake.getUserConfigArgsForCall)
}

func (fake *FakeGui) GetUserConfigCalls(stub func() *config.UserConfig) {
	fake.getUserConfigMutex.Lock()
	defer fake.getUserConfigMutex.Unlock()
	fake.GetUserConfigStub = stub
}

func (fake *FakeGui) GetUserConfigReturns(result1 *config.UserConfig) {
	fake.getUserConfigMutex.Lock()
	defer fake.getUserConfigMutex.Unlock()
	fake.GetUserConfigStub = nil
	fake.getUserConfigReturns = struct {
		result1 *config.UserConfig
	}{result1}
}

func (fake *FakeGui) GetUserConfigReturnsOnCall(i int, result1 *config.UserConfig) {
	fake.getUserConfigMutex.Lock()
	defer fake.getUserConfigMutex.Unlock()
	fake.GetUserConfigStub = nil
	if fake.getUserConfigReturnsOnCall == nil {
		fake.getUserConfigReturnsOnCall = make(map[int]struct {
			result1 *config.UserConfig
		})
	}
	fake.getUserConfigReturnsOnCall[i] = struct {
		result1 *config.UserConfig
	}{result1}
}

func (fake *FakeGui) InformOnCredentialsOutcome(arg1 error) {
	fake.informOnCredentialsOutcomeMutex.Lock()
	fake.informOnCredentialsOutcomeArgsForCall = append(fake.informOnCredentialsOutcomeArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.InformOnCredentialsOutcomeStub
	fake.recordInvocation("InformOnCredentialsOutcome", []interface{}{arg1})
	fake.informOnCredentialsOutcomeMutex.Unlock()
	if stub != nil {
		fake.InformOnCredentialsOutcomeStub(arg1)
	}
}

func (fake *FakeGui) InformOnCredentialsOutcomeCallCount() int {
	fake.informOnCredentialsOutcomeMutex.RLock()
	defer fake.informOnCredentialsOutcomeMutex.RUnlock()
	return len(fake.informOnCredentialsOutcomeArgsForCall)
}

func (fake *FakeGui) InformOnCredentialsOutcomeCalls(stub func(error)) {
	fake.informOnCredentialsOutcomeMutex.Lock()
	defer fake.informOnCredentialsOutcomeMutex.Unlock()
	fake.InformOnCredentialsOutcomeStub = stub
}

func (fake *FakeGui) InformOnCredentialsOutcomeArgsForCall(i int) error {
	fake.informOnCredentialsOutcomeMutex.RLock()
	defer fake.informOnCredentialsOutcomeMutex.RUnlock()
	argsForCall := fake.informOnCredentialsOutcomeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGui) PopupPanelFocused() bool {
	fake.popupPanelFocusedMutex.Lock()
	ret, specificReturn := fake.popupPanelFocusedReturnsOnCall[len(fake.popupPanelFocusedArgsForCall)]
	fake.popupPanelFocusedArgsForCall = append(fake.popupPanelFocusedArgsForCall, struct {
	}{})
	stub := fake.PopupPanelFocusedStub
	fakeReturns := fake.popupPanelFocusedReturns
	fake.recordInvocation("PopupPanelFocused", []interface{}{})
	fake.popupPanelFocusedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGui) PopupPanelFocusedCallCount() int {
	fake.popupPanelFocusedMutex.RLock()
	defer fake.popupPanelFocusedMutex.RUnlock()
	return len(fake.popupPanelFocusedArgsForCall)
}

func (fake *FakeGui) PopupPanelFocusedCalls(stub func() bool) {
	fake.popupPanelFocusedMutex.Lock()
	defer fake.popupPanelFocusedMutex.Unlock()
	fake.PopupPanelFocusedStub = stub
}

func (fake *FakeGui) PopupPanelFocusedReturns(result1 bool) {
	fake.popupPanelFocusedMutex.Lock()
	defer fake.popupPanelFocusedMutex.Unlock()
	fake.PopupPanelFocusedStub = nil
	fake.popupPanelFocusedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGui) PopupPanelFocusedReturnsOnCall(i int, result1 bool) {
	fake.popupPanelFocusedMutex.Lock()
	defer fake.popupPanelFocusedMutex.Unlock()
	fake.PopupPanelFocusedStub = nil
	if fake.popupPanelFocusedReturnsOnCall == nil {
		fake.popupPanelFocusedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.popupPanelFocusedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGui) Prompt(arg1 types.PromptOpts) error {
	fake.promptMutex.Lock()
	ret, specificReturn := fake.promptReturnsOnCall[len(fake.promptArgsForCall)]
	fake.promptArgsForCall = append(fake.promptArgsForCall, struct {
		arg1 types.PromptOpts
	}{arg1})
	stub := fake.PromptStub
	fakeReturns := fake.promptReturns
	fake.recordInvocation("Prompt", []interface{}{arg1})
	fake.promptMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGui) PromptCallCount() int {
	fake.promptMutex.RLock()
	defer fake.promptMutex.RUnlock()
	return len(fake.promptArgsForCall)
}

func (fake *FakeGui) PromptCalls(stub func(types.PromptOpts) error) {
	fake.promptMutex.Lock()
	defer fake.promptMutex.Unlock()
	fake.PromptStub = stub
}

func (fake *FakeGui) PromptArgsForCall(i int) types.PromptOpts {
	fake.promptMutex.RLock()
	defer fake.promptMutex.RUnlock()
	argsForCall := fake.promptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGui) PromptReturns(result1 error) {
	fake.promptMutex.Lock()
	defer fake.promptMutex.Unlock()
	fake.PromptStub = nil
	fake.promptReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) PromptReturnsOnCall(i int, result1 error) {
	fake.promptMutex.Lock()
	defer fake.promptMutex.Unlock()
	fake.PromptStub = nil
	if fake.promptReturnsOnCall == nil {
		fake.promptReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.promptReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) RefreshSidePanels(arg1 types.RefreshOptions) error {
	fake.refreshSidePanelsMutex.Lock()
	ret, specificReturn := fake.refreshSidePanelsReturnsOnCall[len(fake.refreshSidePanelsArgsForCall)]
	fake.refreshSidePanelsArgsForCall = append(fake.refreshSidePanelsArgsForCall, struct {
		arg1 types.RefreshOptions
	}{arg1})
	stub := fake.RefreshSidePanelsStub
	fakeReturns := fake.refreshSidePanelsReturns
	fake.recordInvocation("RefreshSidePanels", []interface{}{arg1})
	fake.refreshSidePanelsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGui) RefreshSidePanelsCallCount() int {
	fake.refreshSidePanelsMutex.RLock()
	defer fake.refreshSidePanelsMutex.RUnlock()
	return len(fake.refreshSidePanelsArgsForCall)
}

func (fake *FakeGui) RefreshSidePanelsCalls(stub func(types.RefreshOptions) error) {
	fake.refreshSidePanelsMutex.Lock()
	defer fake.refreshSidePanelsMutex.Unlock()
	fake.RefreshSidePanelsStub = stub
}

func (fake *FakeGui) RefreshSidePanelsArgsForCall(i int) types.RefreshOptions {
	fake.refreshSidePanelsMutex.RLock()
	defer fake.refreshSidePanelsMutex.RUnlock()
	argsForCall := fake.refreshSidePanelsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGui) RefreshSidePanelsReturns(result1 error) {
	fake.refreshSidePanelsMutex.Lock()
	defer fake.refreshSidePanelsMutex.Unlock()
	fake.RefreshSidePanelsStub = nil
	fake.refreshSidePanelsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) RefreshSidePanelsReturnsOnCall(i int, result1 error) {
	fake.refreshSidePanelsMutex.Lock()
	defer fake.refreshSidePanelsMutex.Unlock()
	fake.RefreshSidePanelsStub = nil
	if fake.refreshSidePanelsReturnsOnCall == nil {
		fake.refreshSidePanelsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.refreshSidePanelsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) SurfaceError(arg1 error) error {
	fake.surfaceErrorMutex.Lock()
	ret, specificReturn := fake.surfaceErrorReturnsOnCall[len(fake.surfaceErrorArgsForCall)]
	fake.surfaceErrorArgsForCall = append(fake.surfaceErrorArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.SurfaceErrorStub
	fakeReturns := fake.surfaceErrorReturns
	fake.recordInvocation("SurfaceError", []interface{}{arg1})
	fake.surfaceErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGui) SurfaceErrorCallCount() int {
	fake.surfaceErrorMutex.RLock()
	defer fake.surfaceErrorMutex.RUnlock()
	return len(fake.surfaceErrorArgsForCall)
}

func (fake *FakeGui) SurfaceErrorCalls(stub func(error) error) {
	fake.surfaceErrorMutex.Lock()
	defer fake.surfaceErrorMutex.Unlock()
	fake.SurfaceErrorStub = stub
}

func (fake *FakeGui) SurfaceErrorArgsForCall(i int) error {
	fake.surfaceErrorMutex.RLock()
	defer fake.surfaceErrorMutex.RUnlock()
	argsForCall := fake.surfaceErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGui) SurfaceErrorReturns(result1 error) {
	fake.surfaceErrorMutex.Lock()
	defer fake.surfaceErrorMutex.Unlock()
	fake.SurfaceErrorStub = nil
	fake.surfaceErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) SurfaceErrorReturnsOnCall(i int, result1 error) {
	fake.surfaceErrorMutex.Lock()
	defer fake.surfaceErrorMutex.Unlock()
	fake.SurfaceErrorStub = nil
	if fake.surfaceErrorReturnsOnCall == nil {
		fake.surfaceErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.surfaceErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) WithPopupWaitingStatus(arg1 string, arg2 func() error) error {
	fake.withPopupWaitingStatusMutex.Lock()
	ret, specificReturn := fake.withPopupWaitingStatusReturnsOnCall[len(fake.withPopupWaitingStatusArgsForCall)]
	fake.withPopupWaitingStatusArgsForCall = append(fake.withPopupWaitingStatusArgsForCall, struct {
		arg1 string
		arg2 func() error
	}{arg1, arg2})
	stub := fake.WithPopupWaitingStatusStub
	fakeReturns := fake.withPopupWaitingStatusReturns
	fake.recordInvocation("WithPopupWaitingStatus", []interface{}{arg1, arg2})
	fake.withPopupWaitingStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGui) WithPopupWaitingStatusCallCount() int {
	fake.withPopupWaitingStatusMutex.RLock()
	defer fake.withPopupWaitingStatusMutex.RUnlock()
	return len(fake.withPopupWaitingStatusArgsForCall)
}

func (fake *FakeGui) WithPopupWaitingStatusCalls(stub func(string, func() error) error) {
	fake.withPopupWaitingStatusMutex.Lock()
	defer fake.withPopupWaitingStatusMutex.Unlock()
	fake.WithPopupWaitingStatusStub = stub
}

func (fake *FakeGui) WithPopupWaitingStatusArgsForCall(i int) (string, func() error) {
	fake.withPopupWaitingStatusMutex.RLock()
	defer fake.withPopupWaitingStatusMutex.RUnlock()
	argsForCall := fake.withPopupWaitingStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGui) WithPopupWaitingStatusReturns(result1 error) {
	fake.withPopupWaitingStatusMutex.Lock()
	defer fake.withPopupWaitingStatusMutex.Unlock()
	fake.WithPopupWaitingStatusStub = nil
	fake.withPopupWaitingStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) WithPopupWaitingStatusReturnsOnCall(i int, result1 error) {
	fake.withPopupWaitingStatusMutex.Lock()
	defer fake.withPopupWaitingStatusMutex.Unlock()
	fake.WithPopupWaitingStatusStub = nil
	if fake.withPopupWaitingStatusReturnsOnCall == nil {
		fake.withPopupWaitingStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.withPopupWaitingStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGui) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.askMutex.RLock()
	defer fake.askMutex.RUnlock()
	fake.createErrorPanelMutex.RLock()
	defer fake.createErrorPanelMutex.RUnlock()
	fake.currentBranchMutex.RLock()
	defer fake.currentBranchMutex.RUnlock()
	fake.getGitCommandMutex.RLock()
	defer fake.getGitCommandMutex.RUnlock()
	fake.getTrMutex.RLock()
	defer fake.getTrMutex.RUnlock()
	fake.getUserConfigMutex.RLock()
	defer fake.getUserConfigMutex.RUnlock()
	fake.informOnCredentialsOutcomeMutex.RLock()
	defer fake.informOnCredentialsOutcomeMutex.RUnlock()
	fake.popupPanelFocusedMutex.RLock()
	defer fake.popupPanelFocusedMutex.RUnlock()
	fake.promptMutex.RLock()
	defer fake.promptMutex.RUnlock()
	fake.refreshSidePanelsMutex.RLock()
	defer fake.refreshSidePanelsMutex.RUnlock()
	fake.surfaceErrorMutex.RLock()
	defer fake.surfaceErrorMutex.RUnlock()
	fake.withPopupWaitingStatusMutex.RLock()
	defer fake.withPopupWaitingStatusMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGui) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
